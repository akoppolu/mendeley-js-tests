'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _getIterator = require('babel-runtime/core-js/get-iterator')['default'];

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _events = require('events');

var _events2 = _interopRequireDefault(_events);

var _appiumBaseDriver = require('appium-base-driver');

var _logger = require('./logger');

var _logger2 = _interopRequireDefault(_logger);

var _teen_process = require('teen_process');

var _installer = require('./installer');

//import { retryInterval } from 'asyncbox';

var _child_process = require('child_process');

var _child_process2 = _interopRequireDefault(_child_process);

var _bluebird = require('bluebird');

var _bluebird2 = _interopRequireDefault(_bluebird);

var REQD_PARAMS = ['app'];
var DEFAULT_WAD_HOST = '127.0.0.1';
var DEFAULT_WAD_PORT = 4724; //  should be non-4723 to avoid conflict on the same box

var WinAppDriver = (function (_events$EventEmitter) {
  _inherits(WinAppDriver, _events$EventEmitter);

  function WinAppDriver() {
    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, WinAppDriver);

    var host = opts.host;
    var port = opts.port;

    _get(Object.getPrototypeOf(WinAppDriver.prototype), 'constructor', this).call(this);

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = _getIterator(REQD_PARAMS), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var req = _step.value;

        if (!opts || !opts[req]) {
          throw new Error('Option \'' + req + '\' is required!');
        }
        this[req] = opts[req];
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator['return']) {
          _iterator['return']();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    this.proxyHost = host || DEFAULT_WAD_HOST;
    this.proxyPort = port || DEFAULT_WAD_PORT;
    this.proc = null;
    this.state = WinAppDriver.STATE_STOPPED;
    this.jwproxy = new _appiumBaseDriver.JWProxy({ server: this.proxyHost, port: this.proxyPort });
  }

  _createClass(WinAppDriver, [{
    key: 'start',
    value: function start() {
      var args, startDetector, processIsAlive, _arr, _loop, _i;

      return _regeneratorRuntime.async(function start$(context$2$0) {
        var _this = this;

        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.next = 2;
            return _regeneratorRuntime.awrap((0, _installer.verifyWAD)());

          case 2:
            if (context$2$0.sent) {
              context$2$0.next = 4;
              break;
            }

            throw new Error("Could not verify WinAppDriver install; re-run install");

          case 4:

            this.changeState(WinAppDriver.STATE_STARTING);

            // XXXYD TODO: would be better if WinAppDriver didn't require passing in /wd/hub as a param
            args = [this.proxyPort + "/wd/hub"];

            startDetector = function startDetector(stdout) {
              return stdout.indexOf("listening for requests") !== -1;
            };

            processIsAlive = false;
            context$2$0.prev = 8;
            context$2$0.next = 11;
            return _regeneratorRuntime.awrap(this.killAll());

          case 11:

            // set up our subprocess object
            this.proc = new _teen_process.SubProcess(_installer.WAD_INSTALL_PATH, args, {
              encoding: 'ucs2'
            });
            processIsAlive = true;

            // handle log output
            _arr = ['STDOUT', 'STDERR'];

            _loop = function () {
              var stream = _arr[_i];
              _this.proc.on('lines-' + stream.toLowerCase(), function (lines) {
                var _iteratorNormalCompletion2 = true;
                var _didIteratorError2 = false;
                var _iteratorError2 = undefined;

                try {
                  for (var _iterator2 = _getIterator(lines), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                    var l = _step2.value;

                    _logger2['default'].info('[' + stream + '] ' + l.trim());
                  }
                } catch (err) {
                  _didIteratorError2 = true;
                  _iteratorError2 = err;
                } finally {
                  try {
                    if (!_iteratorNormalCompletion2 && _iterator2['return']) {
                      _iterator2['return']();
                    }
                  } finally {
                    if (_didIteratorError2) {
                      throw _iteratorError2;
                    }
                  }
                }
              });
            };

            for (_i = 0; _i < _arr.length; _i++) {
              _loop();
            }

            // handle out-of-bound exit by simply emitting a stopped state
            this.proc.on('exit', function (code, signal) {
              processIsAlive = false;
              if (_this.state !== WinAppDriver.STATE_STOPPED && _this.state !== WinAppDriver.STATE_STOPPING) {
                var msg = 'WinAppDriver exited unexpectedly with code ' + code + ', ' + ('signal ' + signal);
                _logger2['default'].error(msg);
                _this.changeState(WinAppDriver.STATE_STOPPED);
              }
            });
            _logger2['default'].info('Spawning winappdriver with: ' + this.winappdriver + ' ' + ('' + args.join(' ')));

            // start subproc and wait for startDetector
            context$2$0.next = 20;
            return _regeneratorRuntime.awrap(this.proc.start(startDetector));

          case 20:
            context$2$0.next = 22;
            return _regeneratorRuntime.awrap(this.waitForOnline());

          case 22:
            this.changeState(WinAppDriver.STATE_ONLINE);
            context$2$0.next = 32;
            break;

          case 25:
            context$2$0.prev = 25;
            context$2$0.t0 = context$2$0['catch'](8);

            this.emit(WinAppDriver.EVENT_ERROR, context$2$0.t0);
            // just because we had an error doesn't mean the winappdriver process
            // finished; we should clean up if necessary

            if (!processIsAlive) {
              context$2$0.next = 31;
              break;
            }

            context$2$0.next = 31;
            return _regeneratorRuntime.awrap(this.proc.stop());

          case 31:
            _logger2['default'].errorAndThrow(context$2$0.t0);

          case 32:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this, [[8, 25]]);
    }
  }, {
    key: 'sessionId',
    value: function sessionId() {
      if (this.state !== WinAppDriver.STATE_ONLINE) {
        return null;
      }

      return this.jwproxy.sessionId;
    }
  }, {
    key: 'waitForOnline',
    value: function waitForOnline() {
      return _regeneratorRuntime.async(function waitForOnline$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            return context$2$0.abrupt('return', true);

          case 1:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }, {
    key: 'getStatus',

    // we need to make sure WAD hasn't crashed
    /*
    let winappdriverStopped = false;
    await retryInterval(20, 200, async () => {
      if (this.state === WinAppDriver.STATE_STOPPED) {
        // we are either stopped or stopping, so something went wrong
        winappdriverStopped = true;
        return;
      }
      await this.getStatus();
    });
    if (winappdriverStopped) {
      throw new Error('WinAppDriver crashed during startup.');
    }*/
    value: function getStatus() {
      return _regeneratorRuntime.async(function getStatus$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.next = 2;
            return _regeneratorRuntime.awrap(this.jwproxy.command('/status', 'GET'));

          case 2:
            return context$2$0.abrupt('return', context$2$0.sent);

          case 3:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }, {
    key: 'startSession',
    value: function startSession(caps) {
      return _regeneratorRuntime.async(function startSession$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            this.proxyReqRes = this.jwproxy.proxyReqRes.bind(this.jwproxy);
            context$2$0.next = 3;
            return _regeneratorRuntime.awrap(this.jwproxy.command('/session', 'POST', { desiredCapabilities: caps }));

          case 3:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }, {
    key: 'stop',
    value: function stop() {
      var emitStates = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];
      return _regeneratorRuntime.async(function stop$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            if (emitStates) {
              this.changeState(WinAppDriver.STATE_STOPPING);
            }
            context$2$0.prev = 1;

            if (!this.proc) {
              context$2$0.next = 5;
              break;
            }

            context$2$0.next = 5;
            return _regeneratorRuntime.awrap(this.proc.stop());

          case 5:
            if (emitStates) {
              this.changeState(WinAppDriver.STATE_STOPPED);
            }
            context$2$0.next = 11;
            break;

          case 8:
            context$2$0.prev = 8;
            context$2$0.t0 = context$2$0['catch'](1);

            _logger2['default'].error(context$2$0.t0);

          case 11:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this, [[1, 8]]);
    }
  }, {
    key: 'changeState',
    value: function changeState(state) {
      this.state = state;
      _logger2['default'].debug('WinAppDriver changed state to \'' + state + '\'');
      this.emit(WinAppDriver.EVENT_CHANGED, { state: state });
    }
  }, {
    key: 'sendCommand',
    value: function sendCommand(url, method, body) {
      return _regeneratorRuntime.async(function sendCommand$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.next = 2;
            return _regeneratorRuntime.awrap(this.jwproxy.command(url, method, body));

          case 2:
            return context$2$0.abrupt('return', context$2$0.sent);

          case 3:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }, {
    key: 'proxyReq',
    value: function proxyReq(req, res) {
      return _regeneratorRuntime.async(function proxyReq$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.next = 2;
            return _regeneratorRuntime.awrap(this.jwproxy.proxyReqRes(req, res));

          case 2:
            return context$2$0.abrupt('return', context$2$0.sent);

          case 3:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }, {
    key: 'killAll',
    value: function killAll() {
      var cmd;
      return _regeneratorRuntime.async(function killAll$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            cmd = undefined;

            // js hint cannot handle backticks, even escaped, within template literals
            cmd = "FOR /F \"usebackq tokens=5\" %a in (`netstat -nao ^| " + "findstr /R /C:\"" + this.proxyPort + " \"`) do (" + "FOR /F \"usebackq\" %b in (`TASKLIST /FI \"PID eq %a\" ^| " + "findstr /I winappdriver.exe`) do (IF NOT %b==\"\" TASKKILL " + "/F /PID %a))";
            _logger2['default'].info('Killing any old WinAppDrivers on same port, running: ' + cmd);
            context$2$0.prev = 3;
            context$2$0.next = 6;
            return _regeneratorRuntime.awrap(_bluebird2['default'].promisify(_child_process2['default'].exec)(cmd));

          case 6:
            _logger2['default'].info("Successfully cleaned up old WinAppDrivers");
            context$2$0.next = 12;
            break;

          case 9:
            context$2$0.prev = 9;
            context$2$0.t0 = context$2$0['catch'](3);

            _logger2['default'].info("No old WinAppDrivers seemed to exist");

          case 12:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this, [[3, 9]]);
    }
  }, {
    key: 'deleteSession',
    value: function deleteSession() {
      return _regeneratorRuntime.async(function deleteSession$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            _logger2['default'].debug('Deleting WinAppDriver server session');
            // rely on jwproxy's intelligence to know what we're talking about and
            // delete the current session
            context$2$0.prev = 1;
            context$2$0.next = 4;
            return _regeneratorRuntime.awrap(this.jwproxy.command('/', 'DELETE'));

          case 4:
            context$2$0.next = 9;
            break;

          case 6:
            context$2$0.prev = 6;
            context$2$0.t0 = context$2$0['catch'](1);

            _logger2['default'].warn('Did not get confirmation WinAppDriver deleteSession worked; ' + ('Error was: ' + context$2$0.t0));

          case 9:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this, [[1, 6]]);
    }
  }]);

  return WinAppDriver;
})(_events2['default'].EventEmitter);

WinAppDriver.EVENT_ERROR = 'winappdriver_error';
WinAppDriver.EVENT_CHANGED = 'stateChanged';
WinAppDriver.STATE_STOPPED = 'stopped';
WinAppDriver.STATE_STARTING = 'starting';
WinAppDriver.STATE_ONLINE = 'online';
WinAppDriver.STATE_STOPPING = 'stopping';

exports.WinAppDriver = WinAppDriver;
exports.DEFAULT_WAD_HOST = DEFAULT_WAD_HOST;
exports.DEFAULT_WAD_PORT = DEFAULT_WAD_PORT;
exports['default'] = WinAppDriver;

// XXXYD TODO: bring this back once WinAppDriver supports status correctly

// TODO WAD doesn't support the status command correctly, so just return
// true for now

// use cp.exec instead of teen process because of crazy windows quoting
//# sourceMappingURL=data:application/json;charset=utf8;base64,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QUFoQixnQkFBZ0I7cUJBQzFDLFlBQVkiLCJmaWxlIjoibGliL3dpbmFwcGRyaXZlci5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBldmVudHMgZnJvbSAnZXZlbnRzJztcbmltcG9ydCB7IEpXUHJveHkgfSBmcm9tICdhcHBpdW0tYmFzZS1kcml2ZXInO1xuaW1wb3J0IGxvZyBmcm9tICcuL2xvZ2dlcic7XG5pbXBvcnQgeyBTdWJQcm9jZXNzIH0gZnJvbSAndGVlbl9wcm9jZXNzJztcbmltcG9ydCB7IFdBRF9JTlNUQUxMX1BBVEgsIHZlcmlmeVdBRCB9IGZyb20gJy4vaW5zdGFsbGVyJztcbi8vaW1wb3J0IHsgcmV0cnlJbnRlcnZhbCB9IGZyb20gJ2FzeW5jYm94JztcbmltcG9ydCBjcCBmcm9tICdjaGlsZF9wcm9jZXNzJztcbmltcG9ydCBCIGZyb20gJ2JsdWViaXJkJztcblxuY29uc3QgUkVRRF9QQVJBTVMgPSBbJ2FwcCddO1xuY29uc3QgREVGQVVMVF9XQURfSE9TVCA9ICcxMjcuMC4wLjEnO1xuY29uc3QgREVGQVVMVF9XQURfUE9SVCA9IDQ3MjQ7IC8vICBzaG91bGQgYmUgbm9uLTQ3MjMgdG8gYXZvaWQgY29uZmxpY3Qgb24gdGhlIHNhbWUgYm94XG5cbmNsYXNzIFdpbkFwcERyaXZlciBleHRlbmRzIGV2ZW50cy5FdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvciAob3B0cyA9IHt9KSB7XG4gICAgY29uc3Qge2hvc3QsIHBvcnR9ID0gb3B0cztcbiAgICBzdXBlcigpO1xuXG4gICAgZm9yIChsZXQgcmVxIG9mIFJFUURfUEFSQU1TKSB7XG4gICAgICBpZiAoIW9wdHMgfHwgIW9wdHNbcmVxXSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE9wdGlvbiAnJHtyZXF9JyBpcyByZXF1aXJlZCFgKTtcbiAgICAgIH1cbiAgICAgIHRoaXNbcmVxXSA9IG9wdHNbcmVxXTtcbiAgICB9XG5cbiAgICB0aGlzLnByb3h5SG9zdCA9IGhvc3QgfHwgREVGQVVMVF9XQURfSE9TVDtcbiAgICB0aGlzLnByb3h5UG9ydCA9IHBvcnQgfHwgREVGQVVMVF9XQURfUE9SVDtcbiAgICB0aGlzLnByb2MgPSBudWxsO1xuICAgIHRoaXMuc3RhdGUgPSBXaW5BcHBEcml2ZXIuU1RBVEVfU1RPUFBFRDtcbiAgICB0aGlzLmp3cHJveHkgPSBuZXcgSldQcm94eSh7c2VydmVyOiB0aGlzLnByb3h5SG9zdCwgcG9ydDogdGhpcy5wcm94eVBvcnR9KTtcbiAgfVxuXG4gIGFzeW5jIHN0YXJ0ICgpIHtcbiAgICBpZiAoIWF3YWl0IHZlcmlmeVdBRCgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgdmVyaWZ5IFdpbkFwcERyaXZlciBpbnN0YWxsOyByZS1ydW4gaW5zdGFsbFwiKTtcbiAgICB9XG4gICAgICAgIFxuICAgIHRoaXMuY2hhbmdlU3RhdGUoV2luQXBwRHJpdmVyLlNUQVRFX1NUQVJUSU5HKTtcbiAgICBcbiAgICAvLyBYWFhZRCBUT0RPOiB3b3VsZCBiZSBiZXR0ZXIgaWYgV2luQXBwRHJpdmVyIGRpZG4ndCByZXF1aXJlIHBhc3NpbmcgaW4gL3dkL2h1YiBhcyBhIHBhcmFtXG4gICAgbGV0IGFyZ3MgPSBbdGhpcy5wcm94eVBvcnQgKyBcIi93ZC9odWJcIl07XG5cbiAgICBjb25zdCBzdGFydERldGVjdG9yID0gKHN0ZG91dCkgPT4ge1xuICAgICAgcmV0dXJuIHN0ZG91dC5pbmRleE9mKFwibGlzdGVuaW5nIGZvciByZXF1ZXN0c1wiKSAhPT0gLTE7ICAgICAgICBcbiAgICB9O1xuXG4gICAgbGV0IHByb2Nlc3NJc0FsaXZlID0gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMua2lsbEFsbCgpO1xuXG4gICAgICAvLyBzZXQgdXAgb3VyIHN1YnByb2Nlc3Mgb2JqZWN0XG4gICAgICB0aGlzLnByb2MgPSBuZXcgU3ViUHJvY2VzcyhXQURfSU5TVEFMTF9QQVRILCBhcmdzLCB7XG4gICAgICAgIGVuY29kaW5nOiAndWNzMidcbiAgICAgIH0pO1xuICAgICAgcHJvY2Vzc0lzQWxpdmUgPSB0cnVlO1xuXG4gICAgICAvLyBoYW5kbGUgbG9nIG91dHB1dFxuICAgICAgZm9yIChsZXQgc3RyZWFtIG9mIFsnU1RET1VUJywgJ1NUREVSUiddKSB7XG4gICAgICAgIHRoaXMucHJvYy5vbihgbGluZXMtJHtzdHJlYW0udG9Mb3dlckNhc2UoKX1gLCAobGluZXMpID0+IHtcbiAgICAgICAgICBmb3IgKGxldCBsIG9mIGxpbmVzKSB7XG4gICAgICAgICAgICBsb2cuaW5mbyhgWyR7c3RyZWFtfV0gJHtsLnRyaW0oKX1gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBoYW5kbGUgb3V0LW9mLWJvdW5kIGV4aXQgYnkgc2ltcGx5IGVtaXR0aW5nIGEgc3RvcHBlZCBzdGF0ZVxuICAgICAgdGhpcy5wcm9jLm9uKCdleGl0JywgKGNvZGUsIHNpZ25hbCkgPT4ge1xuICAgICAgICBwcm9jZXNzSXNBbGl2ZSA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gV2luQXBwRHJpdmVyLlNUQVRFX1NUT1BQRUQgJiZcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgIT09IFdpbkFwcERyaXZlci5TVEFURV9TVE9QUElORykge1xuICAgICAgICAgIGxldCBtc2cgPSBgV2luQXBwRHJpdmVyIGV4aXRlZCB1bmV4cGVjdGVkbHkgd2l0aCBjb2RlICR7Y29kZX0sIGAgK1xuICAgICAgICAgICAgICAgICAgICBgc2lnbmFsICR7c2lnbmFsfWA7XG4gICAgICAgICAgbG9nLmVycm9yKG1zZyk7XG4gICAgICAgICAgdGhpcy5jaGFuZ2VTdGF0ZShXaW5BcHBEcml2ZXIuU1RBVEVfU1RPUFBFRCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgbG9nLmluZm8oYFNwYXduaW5nIHdpbmFwcGRyaXZlciB3aXRoOiAke3RoaXMud2luYXBwZHJpdmVyfSBgICtcbiAgICAgICAgICAgICAgIGAke2FyZ3Muam9pbignICcpfWApO1xuXG4gICAgICAvLyBzdGFydCBzdWJwcm9jIGFuZCB3YWl0IGZvciBzdGFydERldGVjdG9yXG4gICAgICBhd2FpdCB0aGlzLnByb2Muc3RhcnQoc3RhcnREZXRlY3Rvcik7XG5cbiAgICAgIC8vIFhYWFlEIFRPRE86IGJyaW5nIHRoaXMgYmFjayBvbmNlIFdpbkFwcERyaXZlciBzdXBwb3J0cyBzdGF0dXMgY29ycmVjdGx5XG4gICAgICBhd2FpdCB0aGlzLndhaXRGb3JPbmxpbmUoKTtcbiAgICAgIHRoaXMuY2hhbmdlU3RhdGUoV2luQXBwRHJpdmVyLlNUQVRFX09OTElORSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhpcy5lbWl0KFdpbkFwcERyaXZlci5FVkVOVF9FUlJPUiwgZSk7XG4gICAgICAvLyBqdXN0IGJlY2F1c2Ugd2UgaGFkIGFuIGVycm9yIGRvZXNuJ3QgbWVhbiB0aGUgd2luYXBwZHJpdmVyIHByb2Nlc3NcbiAgICAgIC8vIGZpbmlzaGVkOyB3ZSBzaG91bGQgY2xlYW4gdXAgaWYgbmVjZXNzYXJ5XG4gICAgICBpZiAocHJvY2Vzc0lzQWxpdmUpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5wcm9jLnN0b3AoKTtcbiAgICAgIH1cbiAgICAgIGxvZy5lcnJvckFuZFRocm93KGUpO1xuICAgIH1cbiAgfSAgICAgIFxuXG4gIHNlc3Npb25JZCAoKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUgIT09IFdpbkFwcERyaXZlci5TVEFURV9PTkxJTkUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmp3cHJveHkuc2Vzc2lvbklkO1xuICB9XG5cbiAgYXN5bmMgd2FpdEZvck9ubGluZSAoKSB7XG4gICAgLy8gVE9ETyBXQUQgZG9lc24ndCBzdXBwb3J0IHRoZSBzdGF0dXMgY29tbWFuZCBjb3JyZWN0bHksIHNvIGp1c3QgcmV0dXJuXG4gICAgLy8gdHJ1ZSBmb3Igbm93XG4gICAgcmV0dXJuIHRydWU7XG5cbiAgICAvLyB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSBXQUQgaGFzbid0IGNyYXNoZWRcbiAgICAvKlxuICAgIGxldCB3aW5hcHBkcml2ZXJTdG9wcGVkID0gZmFsc2U7XG4gICAgYXdhaXQgcmV0cnlJbnRlcnZhbCgyMCwgMjAwLCBhc3luYyAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gV2luQXBwRHJpdmVyLlNUQVRFX1NUT1BQRUQpIHtcbiAgICAgICAgLy8gd2UgYXJlIGVpdGhlciBzdG9wcGVkIG9yIHN0b3BwaW5nLCBzbyBzb21ldGhpbmcgd2VudCB3cm9uZ1xuICAgICAgICB3aW5hcHBkcml2ZXJTdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgYXdhaXQgdGhpcy5nZXRTdGF0dXMoKTtcbiAgICB9KTtcbiAgICBpZiAod2luYXBwZHJpdmVyU3RvcHBlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdXaW5BcHBEcml2ZXIgY3Jhc2hlZCBkdXJpbmcgc3RhcnR1cC4nKTtcbiAgICB9Ki9cbiAgfVxuXG4gIGFzeW5jIGdldFN0YXR1cyAoKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuandwcm94eS5jb21tYW5kKCcvc3RhdHVzJywgJ0dFVCcpO1xuICB9XG5cbiAgYXN5bmMgc3RhcnRTZXNzaW9uIChjYXBzKSB7XG4gICAgdGhpcy5wcm94eVJlcVJlcyA9IHRoaXMuandwcm94eS5wcm94eVJlcVJlcy5iaW5kKHRoaXMuandwcm94eSk7XG4gICAgYXdhaXQgdGhpcy5qd3Byb3h5LmNvbW1hbmQoJy9zZXNzaW9uJywgJ1BPU1QnLCB7ZGVzaXJlZENhcGFiaWxpdGllczogY2Fwc30pO1xuICB9XG5cbiAgYXN5bmMgc3RvcCAoZW1pdFN0YXRlcyA9IHRydWUpIHtcbiAgICBpZiAoZW1pdFN0YXRlcykge1xuICAgICAgdGhpcy5jaGFuZ2VTdGF0ZShXaW5BcHBEcml2ZXIuU1RBVEVfU1RPUFBJTkcpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgaWYgKHRoaXMucHJvYykge1xuICAgICAgICBhd2FpdCB0aGlzLnByb2Muc3RvcCgpO1xuICAgICAgfVxuICAgICAgaWYgKGVtaXRTdGF0ZXMpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VTdGF0ZShXaW5BcHBEcml2ZXIuU1RBVEVfU1RPUFBFRCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgbG9nLmVycm9yKGUpO1xuICAgIH1cbiAgfVxuXG4gIGNoYW5nZVN0YXRlIChzdGF0ZSkge1xuICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICBsb2cuZGVidWcoYFdpbkFwcERyaXZlciBjaGFuZ2VkIHN0YXRlIHRvICcke3N0YXRlfSdgKTtcbiAgICB0aGlzLmVtaXQoV2luQXBwRHJpdmVyLkVWRU5UX0NIQU5HRUQsIHtzdGF0ZX0pO1xuICB9XG5cbiAgYXN5bmMgc2VuZENvbW1hbmQgKHVybCwgbWV0aG9kLCBib2R5KSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuandwcm94eS5jb21tYW5kKHVybCwgbWV0aG9kLCBib2R5KTtcbiAgfVxuXG4gIGFzeW5jIHByb3h5UmVxIChyZXEsIHJlcykge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmp3cHJveHkucHJveHlSZXFSZXMocmVxLCByZXMpO1xuICB9XG5cbiAgYXN5bmMga2lsbEFsbCAoKSB7XG4gICAgbGV0IGNtZDtcbiAgICAvLyBqcyBoaW50IGNhbm5vdCBoYW5kbGUgYmFja3RpY2tzLCBldmVuIGVzY2FwZWQsIHdpdGhpbiB0ZW1wbGF0ZSBsaXRlcmFsc1xuICAgIGNtZCA9IFwiRk9SIC9GIFxcXCJ1c2ViYWNrcSB0b2tlbnM9NVxcXCIgJWEgaW4gKGBuZXRzdGF0IC1uYW8gXnwgXCIgK1xuICAgICAgICAgIFwiZmluZHN0ciAvUiAvQzpcXFwiXCIgKyB0aGlzLnByb3h5UG9ydCArIFwiIFxcXCJgKSBkbyAoXCIgK1xuICAgICAgICAgIFwiRk9SIC9GIFxcXCJ1c2ViYWNrcVxcXCIgJWIgaW4gKGBUQVNLTElTVCAvRkkgXFxcIlBJRCBlcSAlYVxcXCIgXnwgXCIgK1xuICAgICAgICAgIFwiZmluZHN0ciAvSSB3aW5hcHBkcml2ZXIuZXhlYCkgZG8gKElGIE5PVCAlYj09XFxcIlxcXCIgVEFTS0tJTEwgXCIgK1xuICAgICAgICAgIFwiL0YgL1BJRCAlYSkpXCI7XG4gICAgbG9nLmluZm8oYEtpbGxpbmcgYW55IG9sZCBXaW5BcHBEcml2ZXJzIG9uIHNhbWUgcG9ydCwgcnVubmluZzogJHtjbWR9YCk7XG4gICAgdHJ5IHtcbiAgICAgIC8vIHVzZSBjcC5leGVjIGluc3RlYWQgb2YgdGVlbiBwcm9jZXNzIGJlY2F1c2Ugb2YgY3Jhenkgd2luZG93cyBxdW90aW5nXG4gICAgICBhd2FpdCAoQi5wcm9taXNpZnkoY3AuZXhlYykpKGNtZCk7XG4gICAgICBsb2cuaW5mbyhcIlN1Y2Nlc3NmdWxseSBjbGVhbmVkIHVwIG9sZCBXaW5BcHBEcml2ZXJzXCIpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgbG9nLmluZm8oXCJObyBvbGQgV2luQXBwRHJpdmVycyBzZWVtZWQgdG8gZXhpc3RcIik7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZGVsZXRlU2Vzc2lvbiAoKSB7XG4gICAgbG9nLmRlYnVnKCdEZWxldGluZyBXaW5BcHBEcml2ZXIgc2VydmVyIHNlc3Npb24nKTtcbiAgICAvLyByZWx5IG9uIGp3cHJveHkncyBpbnRlbGxpZ2VuY2UgdG8ga25vdyB3aGF0IHdlJ3JlIHRhbGtpbmcgYWJvdXQgYW5kXG4gICAgLy8gZGVsZXRlIHRoZSBjdXJyZW50IHNlc3Npb25cbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5qd3Byb3h5LmNvbW1hbmQoJy8nLCAnREVMRVRFJyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBsb2cud2FybihgRGlkIG5vdCBnZXQgY29uZmlybWF0aW9uIFdpbkFwcERyaXZlciBkZWxldGVTZXNzaW9uIHdvcmtlZDsgYCArXG4gICAgICAgIGBFcnJvciB3YXM6ICR7ZXJyfWApO1xuICAgIH1cbiAgfVxufVxuXG5XaW5BcHBEcml2ZXIuRVZFTlRfRVJST1IgPSAnd2luYXBwZHJpdmVyX2Vycm9yJztcbldpbkFwcERyaXZlci5FVkVOVF9DSEFOR0VEID0gJ3N0YXRlQ2hhbmdlZCc7XG5XaW5BcHBEcml2ZXIuU1RBVEVfU1RPUFBFRCA9ICdzdG9wcGVkJztcbldpbkFwcERyaXZlci5TVEFURV9TVEFSVElORyA9ICdzdGFydGluZyc7XG5XaW5BcHBEcml2ZXIuU1RBVEVfT05MSU5FID0gJ29ubGluZSc7XG5XaW5BcHBEcml2ZXIuU1RBVEVfU1RPUFBJTkcgPSAnc3RvcHBpbmcnO1xuXG5leHBvcnQgeyBXaW5BcHBEcml2ZXIsIERFRkFVTFRfV0FEX0hPU1QsIERFRkFVTFRfV0FEX1BPUlR9O1xuZXhwb3J0IGRlZmF1bHQgV2luQXBwRHJpdmVyO1xuIl0sInNvdXJjZVJvb3QiOiIuLi8uLiJ9
