/* This library is originated from temp.js at http://github.com/bruce/node-temp */
'use strict';

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _fs = require('./fs');

var _fs2 = _interopRequireDefault(_fs);

var _os = require('os');

var _os2 = _interopRequireDefault(_os);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _constants = require('constants');

var _constants2 = _interopRequireDefault(_constants);

var _logger = require('./logger');

var _logger2 = _interopRequireDefault(_logger);

var RDWR_EXCL = _constants2['default'].O_CREAT | _constants2['default'].O_TRUNC | _constants2['default'].O_RDWR | _constants2['default'].O_EXCL;

function tempDir() {
  var now, filePath;
  return _regeneratorRuntime.async(function tempDir$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        now = new Date();
        filePath = _path2['default'].join(_os2['default'].tmpdir(), [now.getFullYear(), now.getMonth(), now.getDate(), '-', process.pid, '-', (Math.random() * 0x100000000 + 1).toString(36)].join(''));
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(_fs2['default'].mkdir(filePath));

      case 4:
        return context$1$0.abrupt('return', filePath);

      case 5:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

function path(rawAffixes, defaultPrefix) {
  var affixes, name, tempDirectory;
  return _regeneratorRuntime.async(function path$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        affixes = parseAffixes(rawAffixes, defaultPrefix);
        name = [affixes.prefix, affixes.suffix].join('');
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(tempDir());

      case 4:
        tempDirectory = context$1$0.sent;
        return context$1$0.abrupt('return', _path2['default'].join(tempDirectory, name));

      case 6:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

function open(affixes) {
  var filePath, fd;
  return _regeneratorRuntime.async(function open$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(path(affixes, 'f-'));

      case 2:
        filePath = context$1$0.sent;
        context$1$0.prev = 3;
        context$1$0.next = 6;
        return _regeneratorRuntime.awrap(_fs2['default'].open(filePath, RDWR_EXCL, 384));

      case 6:
        fd = context$1$0.sent;
        return context$1$0.abrupt('return', { path: filePath, fd: fd });

      case 10:
        context$1$0.prev = 10;
        context$1$0.t0 = context$1$0['catch'](3);

        _logger2['default'].errorAndThrow(context$1$0.t0);

      case 13:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[3, 10]]);
}

function parseAffixes(rawAffixes, defaultPrefix) {
  var affixes = { prefix: null, suffix: null };
  if (rawAffixes) {
    switch (typeof rawAffixes) {
      case 'string':
        affixes.prefix = rawAffixes;
        break;
      case 'object':
        affixes = rawAffixes;
        break;
      default:
        throw new Error('Unknown affix declaration: ' + affixes);
    }
  } else {
    affixes.prefix = defaultPrefix;
  }
  return affixes;
}

var _static = tempDir();
var openDir = tempDir;

function staticDir() {
  return _regeneratorRuntime.async(function staticDir$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        return context$1$0.abrupt('return', _static);

      case 1:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

exports.open = open;
exports.path = path;
exports.openDir = openDir;
exports.staticDir = staticDir;

// creates a temp directory using the date and a random string

// opens the file in mode 384
//# sourceMappingURL=data:application/json;charset=utf8;base64,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U0FBUyIsImZpbGUiOiJsaWIvdGVtcGRpci5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIFRoaXMgbGlicmFyeSBpcyBvcmlnaW5hdGVkIGZyb20gdGVtcC5qcyBhdCBodHRwOi8vZ2l0aHViLmNvbS9icnVjZS9ub2RlLXRlbXAgKi9cbmltcG9ydCBmcyBmcm9tICcuL2ZzJztcbmltcG9ydCBvcyBmcm9tICdvcyc7XG5pbXBvcnQgbm9kZVBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgY25zdCBmcm9tICdjb25zdGFudHMnO1xuaW1wb3J0IGxvZyBmcm9tICcuL2xvZ2dlcic7XG5cbmNvbnN0IFJEV1JfRVhDTCA9IGNuc3QuT19DUkVBVCB8IGNuc3QuT19UUlVOQyB8IGNuc3QuT19SRFdSIHwgY25zdC5PX0VYQ0w7XG5cbmFzeW5jIGZ1bmN0aW9uIHRlbXBEaXIgKCkge1xuICBsZXQgbm93ID0gbmV3IERhdGUoKTtcbiAgbGV0IGZpbGVQYXRoID0gbm9kZVBhdGguam9pbihvcy50bXBkaXIoKSxcbiAgICBbbm93LmdldEZ1bGxZZWFyKCksIG5vdy5nZXRNb250aCgpLCBub3cuZ2V0RGF0ZSgpLFxuICAgICctJyxcbiAgICBwcm9jZXNzLnBpZCxcbiAgICAnLScsXG4gICAgKE1hdGgucmFuZG9tKCkgKiAweDEwMDAwMDAwMCArIDEpLnRvU3RyaW5nKDM2KV0uam9pbignJykpO1xuICAvLyBjcmVhdGVzIGEgdGVtcCBkaXJlY3RvcnkgdXNpbmcgdGhlIGRhdGUgYW5kIGEgcmFuZG9tIHN0cmluZ1xuXG4gIGF3YWl0IGZzLm1rZGlyKGZpbGVQYXRoKTtcblxuICByZXR1cm4gZmlsZVBhdGg7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHBhdGggKHJhd0FmZml4ZXMsIGRlZmF1bHRQcmVmaXgpIHtcbiAgbGV0IGFmZml4ZXMgPSBwYXJzZUFmZml4ZXMocmF3QWZmaXhlcywgZGVmYXVsdFByZWZpeCk7XG4gIGxldCBuYW1lID0gW2FmZml4ZXMucHJlZml4LCBhZmZpeGVzLnN1ZmZpeF0uam9pbignJyk7XG4gIGxldCB0ZW1wRGlyZWN0b3J5ID0gYXdhaXQgdGVtcERpcigpO1xuICByZXR1cm4gbm9kZVBhdGguam9pbih0ZW1wRGlyZWN0b3J5LCBuYW1lKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gb3BlbiAoYWZmaXhlcykge1xuICBsZXQgZmlsZVBhdGggPSBhd2FpdCBwYXRoKGFmZml4ZXMsICdmLScpO1xuICB0cnkge1xuICAgIGxldCBmZCA9IGF3YWl0IGZzLm9wZW4oZmlsZVBhdGgsIFJEV1JfRVhDTCwgMG82MDApO1xuICAgIC8vIG9wZW5zIHRoZSBmaWxlIGluIG1vZGUgMzg0XG4gICAgcmV0dXJuIHtwYXRoOiBmaWxlUGF0aCwgZmR9O1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBsb2cuZXJyb3JBbmRUaHJvdyhlcnIpO1xuICB9XG5cbn1cblxuZnVuY3Rpb24gcGFyc2VBZmZpeGVzIChyYXdBZmZpeGVzLCBkZWZhdWx0UHJlZml4KSB7XG4gIGxldCBhZmZpeGVzID0ge3ByZWZpeDogbnVsbCwgc3VmZml4OiBudWxsfTtcbiAgaWYgKHJhd0FmZml4ZXMpIHtcbiAgICBzd2l0Y2ggKHR5cGVvZihyYXdBZmZpeGVzKSkge1xuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgYWZmaXhlcy5wcmVmaXggPSByYXdBZmZpeGVzO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIGFmZml4ZXMgPSByYXdBZmZpeGVzO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBhZmZpeCBkZWNsYXJhdGlvbjogJHthZmZpeGVzfWApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBhZmZpeGVzLnByZWZpeCA9IGRlZmF1bHRQcmVmaXg7XG4gIH1cbiAgcmV0dXJuIGFmZml4ZXM7XG59XG5cbmNvbnN0IF9zdGF0aWMgPSB0ZW1wRGlyKCk7XG5jb25zdCBvcGVuRGlyID0gdGVtcERpcjtcblxuYXN5bmMgZnVuY3Rpb24gc3RhdGljRGlyICgpIHtcbiAgcmV0dXJuIF9zdGF0aWM7XG59XG5cbmV4cG9ydCB7IG9wZW4sIHBhdGgsIG9wZW5EaXIsIHN0YXRpY0RpciB9O1xuIl0sInNvdXJjZVJvb3QiOiIuLi8uLiJ9
