'use strict';

var _slicedToArray = require('babel-runtime/helpers/sliced-to-array')['default'];

var _getIterator = require('babel-runtime/core-js/get-iterator')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _npmlog = require('npmlog');

var _npmlog2 = _interopRequireDefault(_npmlog);

// levels that are available from `npmlog`
var NPM_LEVELS = ['silly', 'verbose', 'debug', 'info', 'http', 'warn', 'error'];
var MAX_LOG_RECORDS_COUNT = 3000;

// mock log object used in testing mode
var mockLog = {};
var _iteratorNormalCompletion = true;
var _didIteratorError = false;
var _iteratorError = undefined;

try {
  for (var _iterator = _getIterator(NPM_LEVELS), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
    var level = _step.value;

    mockLog[level] = function () {};
  }
} catch (err) {
  _didIteratorError = true;
  _iteratorError = err;
} finally {
  try {
    if (!_iteratorNormalCompletion && _iterator['return']) {
      _iterator['return']();
    }
  } finally {
    if (_didIteratorError) {
      throw _iteratorError;
    }
  }
}

function patchLogger(logger) {
  if (!logger.debug) {
    logger.addLevel('debug', 1000, { fg: 'blue', bg: 'black' }, 'dbug');
  }
}

function _getLogger() {
  // check if the user set the `_TESTING` or `_FORCE_LOGS` flag
  var testingMode = parseInt(process.env._TESTING, 10) === 1;
  var forceLogMode = parseInt(process.env._FORCE_LOGS, 10) === 1;

  // if is possible that there is a logger instance that is already around,
  // in which case we want t o use that
  var usingGlobalLog = !!global._global_npmlog;
  var logger = undefined;
  if (testingMode && !forceLogMode) {
    // in testing mode, use a mock logger object that we can query
    logger = mockLog;
  } else {
    // otherwise, either use the global, or a new `npmlog` object
    logger = global._global_npmlog || _npmlog2['default'];
    // The default value is 10000, which causes excessive memory usage
    logger.maxRecordSize = MAX_LOG_RECORDS_COUNT;
  }
  patchLogger(logger);
  return [logger, usingGlobalLog];
}

function getLogger() {
  var prefix = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];

  var _getLogger2 = _getLogger();

  var _getLogger22 = _slicedToArray(_getLogger2, 2);

  var logger = _getLogger22[0];
  var usingGlobalLog = _getLogger22[1];

  // wrap the logger so that we can catch and modify any logging
  var wrappedLogger = { unwrap: function unwrap() {
      return logger;
    } };

  // allow access to the level of the underlying logger
  Object.defineProperty(wrappedLogger, 'level', {
    get: function get() {
      return logger.level;
    },
    set: function set(newValue) {
      logger.level = newValue;
    },
    enumerable: true,
    configurable: true
  });
  // add all the levels from `npmlog`, and map to the underlying logger
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = _getIterator(NPM_LEVELS), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var level = _step2.value;

      wrappedLogger[level] = logger[level].bind(logger, prefix);
    }
    // add method to log an error, and throw it, for convenience
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2['return']) {
        _iterator2['return']();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  wrappedLogger.errorAndThrow = function (err) {
    // make sure we have an `Error` object. Wrap if necessary
    if (!(err instanceof Error)) {
      err = new Error(err);
    }
    // log and throw
    this.error(err);
    throw err;
  };
  if (!usingGlobalLog) {
    // if we're not using a global log specified from some top-level package,
    // set the log level to a default of verbose. Otherwise, let the top-level
    // package set the log level
    wrappedLogger.level = 'verbose';
  }
  wrappedLogger.levels = NPM_LEVELS;
  return wrappedLogger;
}

// export a default logger with no prefix
var log = getLogger();

exports.log = log;
exports.patchLogger = patchLogger;
exports.getLogger = getLogger;
exports['default'] = log;
//# sourceMappingURL=data:application/json;charset=utf8;base64,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QztHQUNYLENBQUM7QUFDRixNQUFJLENBQUMsY0FBYyxFQUFFOzs7O0FBSW5CLGlCQUFhLENBQUMsS0FBSyxHQUFHLFNBQVMsQ0FBQztHQUNqQztBQUNELGVBQWEsQ0FBQyxNQUFNLEdBQUcsVUFBVSxDQUFDO0FBQ2xDLFNBQU8sYUFBYSxDQUFDO0NBQ3RCOzs7QUFHRCxJQUFNLEdBQUcsR0FBRyxTQUFTLEVBQUUsQ0FBQzs7UUFFZixHQUFHLEdBQUgsR0FBRztRQUFFLFdBQVcsR0FBWCxXQUFXO1FBQUUsU0FBUyxHQUFULFNBQVM7cUJBQ3JCLEdBQUciLCJmaWxlIjoibGliL2xvZ2dpbmcuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbnBtbG9nIGZyb20gJ25wbWxvZyc7XG5cblxuLy8gbGV2ZWxzIHRoYXQgYXJlIGF2YWlsYWJsZSBmcm9tIGBucG1sb2dgXG5jb25zdCBOUE1fTEVWRUxTID0gWydzaWxseScsICd2ZXJib3NlJywgJ2RlYnVnJywgJ2luZm8nLCAnaHR0cCcsICd3YXJuJywgJ2Vycm9yJ107XG5jb25zdCBNQVhfTE9HX1JFQ09SRFNfQ09VTlQgPSAzMDAwO1xuXG4vLyBtb2NrIGxvZyBvYmplY3QgdXNlZCBpbiB0ZXN0aW5nIG1vZGVcbmxldCBtb2NrTG9nID0ge307XG5mb3IgKGxldCBsZXZlbCBvZiBOUE1fTEVWRUxTKSB7XG4gIG1vY2tMb2dbbGV2ZWxdID0gKCkgPT4ge307XG59XG5cbmZ1bmN0aW9uIHBhdGNoTG9nZ2VyIChsb2dnZXIpIHtcbiAgaWYgKCFsb2dnZXIuZGVidWcpIHtcbiAgICBsb2dnZXIuYWRkTGV2ZWwoJ2RlYnVnJywgMTAwMCwgeyBmZzogJ2JsdWUnLCBiZzogJ2JsYWNrJyB9LCAnZGJ1ZycpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9nZXRMb2dnZXIgKCkge1xuICAvLyBjaGVjayBpZiB0aGUgdXNlciBzZXQgdGhlIGBfVEVTVElOR2Agb3IgYF9GT1JDRV9MT0dTYCBmbGFnXG4gIGNvbnN0IHRlc3RpbmdNb2RlID0gcGFyc2VJbnQocHJvY2Vzcy5lbnYuX1RFU1RJTkcsIDEwKSA9PT0gMTtcbiAgY29uc3QgZm9yY2VMb2dNb2RlID0gcGFyc2VJbnQocHJvY2Vzcy5lbnYuX0ZPUkNFX0xPR1MsIDEwKSA9PT0gMTtcblxuICAvLyBpZiBpcyBwb3NzaWJsZSB0aGF0IHRoZXJlIGlzIGEgbG9nZ2VyIGluc3RhbmNlIHRoYXQgaXMgYWxyZWFkeSBhcm91bmQsXG4gIC8vIGluIHdoaWNoIGNhc2Ugd2Ugd2FudCB0IG8gdXNlIHRoYXRcbiAgY29uc3QgdXNpbmdHbG9iYWxMb2cgPSAhIWdsb2JhbC5fZ2xvYmFsX25wbWxvZztcbiAgbGV0IGxvZ2dlcjtcbiAgaWYgKHRlc3RpbmdNb2RlICYmICFmb3JjZUxvZ01vZGUpIHtcbiAgICAvLyBpbiB0ZXN0aW5nIG1vZGUsIHVzZSBhIG1vY2sgbG9nZ2VyIG9iamVjdCB0aGF0IHdlIGNhbiBxdWVyeVxuICAgIGxvZ2dlciA9IG1vY2tMb2c7XG4gIH0gZWxzZSB7XG4gICAgLy8gb3RoZXJ3aXNlLCBlaXRoZXIgdXNlIHRoZSBnbG9iYWwsIG9yIGEgbmV3IGBucG1sb2dgIG9iamVjdFxuICAgIGxvZ2dlciA9IGdsb2JhbC5fZ2xvYmFsX25wbWxvZyB8fCBucG1sb2c7XG4gICAgLy8gVGhlIGRlZmF1bHQgdmFsdWUgaXMgMTAwMDAsIHdoaWNoIGNhdXNlcyBleGNlc3NpdmUgbWVtb3J5IHVzYWdlXG4gICAgbG9nZ2VyLm1heFJlY29yZFNpemUgPSBNQVhfTE9HX1JFQ09SRFNfQ09VTlQ7XG4gIH1cbiAgcGF0Y2hMb2dnZXIobG9nZ2VyKTtcbiAgcmV0dXJuIFtsb2dnZXIsIHVzaW5nR2xvYmFsTG9nXTtcbn1cblxuZnVuY3Rpb24gZ2V0TG9nZ2VyIChwcmVmaXggPSBudWxsKSB7XG4gIGxldCBbbG9nZ2VyLCB1c2luZ0dsb2JhbExvZ10gPSBfZ2V0TG9nZ2VyKCk7XG5cbiAgLy8gd3JhcCB0aGUgbG9nZ2VyIHNvIHRoYXQgd2UgY2FuIGNhdGNoIGFuZCBtb2RpZnkgYW55IGxvZ2dpbmdcbiAgbGV0IHdyYXBwZWRMb2dnZXIgPSB7dW53cmFwOiAoKSA9PiBsb2dnZXJ9O1xuXG4gIC8vIGFsbG93IGFjY2VzcyB0byB0aGUgbGV2ZWwgb2YgdGhlIHVuZGVybHlpbmcgbG9nZ2VyXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3cmFwcGVkTG9nZ2VyLCAnbGV2ZWwnLCB7XG4gICAgZ2V0OiAoKSA9PiB7IHJldHVybiBsb2dnZXIubGV2ZWw7IH0sXG4gICAgc2V0OiAobmV3VmFsdWUpID0+IHsgbG9nZ2VyLmxldmVsID0gbmV3VmFsdWU7IH0sXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIC8vIGFkZCBhbGwgdGhlIGxldmVscyBmcm9tIGBucG1sb2dgLCBhbmQgbWFwIHRvIHRoZSB1bmRlcmx5aW5nIGxvZ2dlclxuICBmb3IgKGxldCBsZXZlbCBvZiBOUE1fTEVWRUxTKSB7XG4gICAgd3JhcHBlZExvZ2dlcltsZXZlbF0gPSBsb2dnZXJbbGV2ZWxdLmJpbmQobG9nZ2VyLCBwcmVmaXgpO1xuICB9XG4gIC8vIGFkZCBtZXRob2QgdG8gbG9nIGFuIGVycm9yLCBhbmQgdGhyb3cgaXQsIGZvciBjb252ZW5pZW5jZVxuICB3cmFwcGVkTG9nZ2VyLmVycm9yQW5kVGhyb3cgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgLy8gbWFrZSBzdXJlIHdlIGhhdmUgYW4gYEVycm9yYCBvYmplY3QuIFdyYXAgaWYgbmVjZXNzYXJ5XG4gICAgaWYgKCEoZXJyIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICBlcnIgPSBuZXcgRXJyb3IoZXJyKTtcbiAgICB9XG4gICAgLy8gbG9nIGFuZCB0aHJvd1xuICAgIHRoaXMuZXJyb3IoZXJyKTtcbiAgICB0aHJvdyBlcnI7XG4gIH07XG4gIGlmICghdXNpbmdHbG9iYWxMb2cpIHtcbiAgICAvLyBpZiB3ZSdyZSBub3QgdXNpbmcgYSBnbG9iYWwgbG9nIHNwZWNpZmllZCBmcm9tIHNvbWUgdG9wLWxldmVsIHBhY2thZ2UsXG4gICAgLy8gc2V0IHRoZSBsb2cgbGV2ZWwgdG8gYSBkZWZhdWx0IG9mIHZlcmJvc2UuIE90aGVyd2lzZSwgbGV0IHRoZSB0b3AtbGV2ZWxcbiAgICAvLyBwYWNrYWdlIHNldCB0aGUgbG9nIGxldmVsXG4gICAgd3JhcHBlZExvZ2dlci5sZXZlbCA9ICd2ZXJib3NlJztcbiAgfVxuICB3cmFwcGVkTG9nZ2VyLmxldmVscyA9IE5QTV9MRVZFTFM7XG4gIHJldHVybiB3cmFwcGVkTG9nZ2VyO1xufVxuXG4vLyBleHBvcnQgYSBkZWZhdWx0IGxvZ2dlciB3aXRoIG5vIHByZWZpeFxuY29uc3QgbG9nID0gZ2V0TG9nZ2VyKCk7XG5cbmV4cG9ydCB7IGxvZywgcGF0Y2hMb2dnZXIsIGdldExvZ2dlciB9O1xuZXhwb3J0IGRlZmF1bHQgbG9nO1xuIl0sInNvdXJjZVJvb3QiOiIuLi8uLiJ9
