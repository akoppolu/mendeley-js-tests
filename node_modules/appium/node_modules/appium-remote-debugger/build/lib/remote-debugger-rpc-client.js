// jshint ignore: start
'use strict';

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _slicedToArray = require('babel-runtime/helpers/sliced-to-array')['default'];

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _logger = require('./logger');

var _logger2 = _interopRequireDefault(_logger);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _bplistCreator = require('bplist-creator');

var _bplistCreator2 = _interopRequireDefault(_bplistCreator);

var _bplistParser = require('bplist-parser');

var _bplistParser2 = _interopRequireDefault(_bplistParser);

var _bufferpack = require('bufferpack');

var _bufferpack2 = _interopRequireDefault(_bufferpack);

var _bluebird = require('bluebird');

var _bluebird2 = _interopRequireDefault(_bluebird);

var _remoteDebugger = require('./remote-debugger');

var _uuid = require('uuid');

var _uuid2 = _interopRequireDefault(_uuid);

var _net = require('net');

var _net2 = _interopRequireDefault(_net);

var _remoteDebuggerMessageHandler = require('./remote-debugger-message-handler');

var _remoteDebuggerMessageHandler2 = _interopRequireDefault(_remoteDebuggerMessageHandler);

var _remoteMessages = require('./remote-messages');

var _remoteMessages2 = _interopRequireDefault(_remoteMessages);

var _helpers = require('./helpers');

var RemoteDebuggerRpcClient = (function () {
  function RemoteDebuggerRpcClient(host) {
    var port = arguments.length <= 1 || arguments[1] === undefined ? _remoteDebugger.REMOTE_DEBUGGER_PORT : arguments[1];
    var specialMessageHandlers = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

    _classCallCheck(this, RemoteDebuggerRpcClient);

    // socket and connection configuration
    this.socket = null;
    this.host = host;
    this.port = port;
    this.connected = false;
    this.connId = _uuid2['default'].v4();
    this.senderId = _uuid2['default'].v4();
    this.curMsgId = 0;
    this.received = new Buffer(0);
    this.readPos = 0;

    // message handlers
    this.specialMessageHandlers = specialMessageHandlers;
    this.messageHandler = null;
  }

  _createClass(RemoteDebuggerRpcClient, [{
    key: 'connect',
    value: function connect() {
      return _regeneratorRuntime.async(function connect$(context$2$0) {
        var _this = this;

        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            this.messageHandler = new _remoteDebuggerMessageHandler2['default'](this.specialMessageHandlers);

            // create socket and handle its messages
            this.socket = new _net2['default'].Socket({ type: 'tcp6' });
            this.socket.setNoDelay(true);
            this.socket.on('close', function () {
              if (_this.connected) {
                _logger2['default'].debug('Debugger socket disconnected');
              }
              _this.connected = false;
              _this.socket = null;
            });
            this.socket.on('end', function () {
              _this.connected = false;
            });
            this.socket.on('data', this.receive.bind(this));

            // connect the socket
            context$2$0.next = 8;
            return _regeneratorRuntime.awrap(new _bluebird2['default'](function (resolve, reject) {
              // only resolve this function when we are actually connected
              _this.socket.connect(_this.port, '::1');
              _this.socket.on('connect', function callee$3$0() {
                return _regeneratorRuntime.async(function callee$3$0$(context$4$0) {
                  while (1) switch (context$4$0.prev = context$4$0.next) {
                    case 0:
                      _logger2['default'].debug('Debugger socket connected to ' + this.socket.remoteAddress + ':' + this.socket.remotePort);
                      this.connected = true;

                      resolve();

                    case 3:
                    case 'end':
                      return context$4$0.stop();
                  }
                }, null, _this);
              });
              _this.socket.on('error', function (exception) {
                if (_this.connected) {
                  _logger2['default'].error('Socket error: ' + exception.message);
                  _this.connected = false;
                }

                // the connection was refused, so reject the connect promise
                reject(exception);
              });
            }));

          case 8:
            return context$2$0.abrupt('return', context$2$0.sent);

          case 9:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }, {
    key: 'disconnect',
    value: function disconnect() {
      return _regeneratorRuntime.async(function disconnect$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            if (this.isConnected()) {
              _logger2['default'].debug('Disconnecting from remote debugger');
              this.socket.destroy();
            }
            this.connected = false;

          case 2:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }, {
    key: 'isConnected',
    value: function isConnected() {
      return this.connected;
    }
  }, {
    key: 'setSpecialMessageHandler',
    value: function setSpecialMessageHandler(key, errorHandler, handler) {
      this.messageHandler.setSpecialMessageHandler(key, errorHandler, handler);
    }
  }, {
    key: 'getSpecialMessageHandler',
    value: function getSpecialMessageHandler(key) {
      return this.messageHandler.getSpecialMessageHandler(key);
    }
  }, {
    key: 'setDataMessageHandler',
    value: function setDataMessageHandler(key, errorHandler, handler) {
      this.messageHandler.setDataMessageHandler(key, errorHandler, handler);
    }
  }, {
    key: 'allowNavigationWithoutReload',
    value: function allowNavigationWithoutReload() {
      var allow = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];

      this.messageHandler.allowNavigationWithoutReload(allow);
    }
  }, {
    key: 'selectApp',
    value: function selectApp(appIdKey, applicationConnectedHandler) {
      return _regeneratorRuntime.async(function selectApp$(context$2$0) {
        var _this2 = this;

        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.next = 2;
            return _regeneratorRuntime.awrap(new _bluebird2['default'](function (resolve, reject) {
              // local callback, temporarily added as callback to
              // `_rpc_applicationConnected:` remote debugger response
              // to handle the initial connection
              var onAppChange = function onAppChange(dict) {
                var oldAppIdKey, correctAppIdKey;
                return _regeneratorRuntime.async(function onAppChange$(context$4$0) {
                  while (1) switch (context$4$0.prev = context$4$0.next) {
                    case 0:
                      oldAppIdKey = dict.WIRHostApplicationIdentifierKey;
                      correctAppIdKey = dict.WIRApplicationIdentifierKey;

                      // if this is a report of a proxy redirect from the remote debugger
                      // we want to update our dictionary and get a new app id
                      if (oldAppIdKey && correctAppIdKey !== oldAppIdKey) {
                        _logger2['default'].debug('We were notified we might have connected to the wrong app. ' + ('Using id ' + correctAppIdKey + ' instead of ' + oldAppIdKey));
                      }

                      applicationConnectedHandler(dict);
                      reject('New application has connected');

                    case 5:
                    case 'end':
                      return context$4$0.stop();
                  }
                }, null, _this2);
              };
              _this2.setSpecialMessageHandler('_rpc_applicationConnected:', reject, onAppChange);

              // do the actual connecting to the app
              return (function callee$3$0() {
                var _ref, _ref2, connectedAppIdKey, pageDict, msg;

                return _regeneratorRuntime.async(function callee$3$0$(context$4$0) {
                  while (1) switch (context$4$0.prev = context$4$0.next) {
                    case 0:
                      context$4$0.next = 2;
                      return _regeneratorRuntime.awrap(this.send('connectToApp', {
                        appIdKey: appIdKey
                      }));

                    case 2:
                      _ref = context$4$0.sent;
                      _ref2 = _slicedToArray(_ref, 2);
                      connectedAppIdKey = _ref2[0];
                      pageDict = _ref2[1];

                      // sometimes the connect logic happens, but with an empty dictionary
                      // which leads to the remote debugger getting disconnected, and into a loop
                      if (_lodash2['default'].isEmpty(pageDict)) {
                        msg = 'Empty page dictionary received';

                        _logger2['default'].debug(msg);
                        reject(new Error(msg));
                      } else {
                        resolve([connectedAppIdKey, pageDict]);
                      }

                    case 7:
                    case 'end':
                      return context$4$0.stop();
                  }
                }, null, _this2);
              })();
            })['finally'](function () {
              // no matter what, we want to restore the handler that was changed.
              _this2.setSpecialMessageHandler('_rpc_applicationConnected:', null, applicationConnectedHandler);
            }));

          case 2:
            return context$2$0.abrupt('return', context$2$0.sent);

          case 3:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }, {
    key: 'send',
    value: function send(command) {
      var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
      var onSocketError;
      return _regeneratorRuntime.async(function send$(context$2$0) {
        var _this3 = this;

        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            onSocketError = undefined;
            context$2$0.next = 3;
            return _regeneratorRuntime.awrap(new _bluebird2['default'](function (resolve, reject) {
              // promise to be resolved whenever remote debugger
              // replies to our request

              // retrieve the correct command to send
              opts = _lodash2['default'].defaults({ connId: _this3.connId, senderId: _this3.senderId }, opts);
              var data = (0, _remoteMessages2['default'])(command, opts);

              // most of the time we don't care when socket.write does
              // so give it an empty function
              var socketCb = _lodash2['default'].noop;

              // handle socket problems
              onSocketError = function (exception) {
                if (_this3.connected) {
                  _logger2['default'].error('Socket error: ' + exception.message);
                }

                // the connection was refused, so reject the connect promise
                reject(exception);
              };
              _this3.socket.on('error', onSocketError);
              if (_this3.messageHandler.hasSpecialMessageHandler(data.__selector)) {
                (function () {
                  // special replies will return any number of arguments
                  // temporarily wrap with promise handling
                  var specialMessageHandler = _this3.getSpecialMessageHandler(data.__selector);
                  _this3.setSpecialMessageHandler(data.__selector, reject, (function () {
                    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                      args[_key] = arguments[_key];
                    }

                    _logger2['default'].debug('Received response from socket send: \'' + _lodash2['default'].truncate(JSON.stringify(args), { length: 50 }) + '\'');

                    // call the original listener, and put it back, if necessary
                    specialMessageHandler.apply(undefined, args);
                    if (this.messageHandler.hasSpecialMessageHandler(data.__selector)) {
                      // this means that the system has not removed this listener
                      this.setSpecialMessageHandler(data.__selector, null, specialMessageHandler);
                    }

                    resolve(args);
                  }).bind(_this3));
                })();
              } else if (data.__argument && data.__argument.WIRSocketDataKey) {
                // keep track of the messages coming and going using
                // a simple sequential id
                _this3.curMsgId++;
                _this3.setDataMessageHandler(_this3.curMsgId.toString(), reject, function (value) {
                  var msg = _lodash2['default'].truncate(_lodash2['default'].isString(value) ? value : JSON.stringify(value), { length: 50 });
                  _logger2['default'].debug('Received data response from socket send: \'' + msg + '\'');
                  _logger2['default'].debug('Original command: ' + command);
                  resolve(value);
                });
                data.__argument.WIRSocketDataKey.id = _this3.curMsgId;
                data.__argument.WIRSocketDataKey = new Buffer(JSON.stringify(data.__argument.WIRSocketDataKey));
              } else {
                // we want to immediately resolve this socket.write
                // any long term callbacks will do their business in the background
                socketCb = resolve;
              }

              _logger2['default'].debug('Sending \'' + data.__selector + '\' message to remote debugger');

              // remote debugger expects a binary plist as data
              var plist = undefined;
              try {
                plist = (0, _bplistCreator2['default'])(data);
              } catch (e) {
                var msg = 'Could not create binary plist from data: ' + e.message;
                _logger2['default'].error(msg);
                return reject(new Error(msg));
              }

              if (_this3.socket && _this3.connected) {
                // cork and uncork in order to not buffer the write
                // on some systems this is necessary or the server
                // gets confused.
                _this3.socket.cork();
                _this3.socket.write(_bufferpack2['default'].pack('L', [plist.length]));
                _this3.socket.write(plist, socketCb);
                _this3.socket.uncork();
              } else {
                var msg = 'Attempted to write data to socket after it was closed!';
                _logger2['default'].error(msg);
                reject(new Error(msg));
              }
            })['finally'](function () {
              // remove this listener, so we don't exhaust the system
              _this3.socket.removeListener('error', onSocketError);
            }));

          case 3:
            return context$2$0.abrupt('return', context$2$0.sent);

          case 4:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }, {
    key: 'receive',
    value: function receive(data) {
      // Append this new data to the existing Buffer
      this.received = Buffer.concat([this.received, data]);
      var dataLeftOver = true;

      // Parse multiple messages in the same packet
      while (dataLeftOver) {
        // Store a reference to where we were
        var oldReadPos = this.readPos;

        // Read the prefix (plist length) to see how far to read next
        // It's always 4 bytes long
        var prefix = this.received.slice(this.readPos, this.readPos + 4);

        var msgLength = undefined;
        try {
          msgLength = _bufferpack2['default'].unpack('L', prefix)[0];
        } catch (e) {
          _logger2['default'].error('Buffer could not unpack: ' + e);
          return;
        }

        // Jump forward 4 bytes
        this.readPos += 4;

        // Is there enough data here?
        // If not, jump back to our original position and gtfo
        if (this.received.length < msgLength + this.readPos) {
          this.readPos = oldReadPos;
          break;
        }

        // Extract the main body of the message (where the plist should be)
        var body = this.received.slice(this.readPos, msgLength + this.readPos);

        // Extract the plist
        var plist = undefined;
        try {
          plist = _bplistParser2['default'].parseBuffer(body);
        } catch (e) {
          _logger2['default'].error('Error parsing binary plist: ' + e);
          return;
        }

        // bplistParse.parseBuffer returns an array
        if (plist.length === 1) {
          plist = plist[0];
        }

        var _arr = ['WIRMessageDataKey', 'WIRDestinationKey', 'WIRSocketDataKey'];
        for (var _i = 0; _i < _arr.length; _i++) {
          var key = _arr[_i];
          if (!_lodash2['default'].isUndefined(plist[key])) {
            plist[key] = plist[key].toString("utf8");
          }
        }

        if (plist.__selector === "_rpc_applicationSentData:") {
          _logger2['default'].debug('Received applicationSentData response');
        } else {
          _logger2['default'].debug('Receiving data from remote debugger: \'' + (0, _helpers.simpleStringify)(plist) + '\'');
        }

        // Jump forward the length of the plist
        this.readPos += msgLength;

        // Calculate how much buffer is left
        var leftOver = this.received.length - this.readPos;

        // Is there some left over?
        if (leftOver !== 0) {
          // Copy what's left over into a new buffer, and save it for next time
          var chunk = new Buffer(leftOver);
          this.received.copy(chunk, 0, this.readPos);
          this.received = chunk;
        } else {
          // Otherwise, empty the buffer and get out of the loop
          this.received = new Buffer(0);
          dataLeftOver = false;
        }

        // Reset the read position
        this.readPos = 0;

        // Now do something with the plist
        if (plist) {
          this.messageHandler.handleMessage(plist);
        }
      }
    }
  }, {
    key: 'setTimelineEventHandler',
    value: function setTimelineEventHandler(timelineEventHandler) {
      this.timelineEventHandler = timelineEventHandler;
      this.messageHandler.setTimelineEventHandler(timelineEventHandler);
    }
  }]);

  return RemoteDebuggerRpcClient;
})();

exports['default'] = RemoteDebuggerRpcClient;
module.exports = exports['default'];

// from the dictionary returned, get the ids

// error listener, which needs to be removed after the promise is resolved
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9yZW1vdGUtZGVidWdnZXItcnBjLWNsaWVudC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztzQkFDZ0IsVUFBVTs7OztzQkFDWixRQUFROzs7OzZCQUNHLGdCQUFnQjs7Ozs0QkFDakIsZUFBZTs7OzswQkFDaEIsWUFBWTs7Ozt3QkFDZixVQUFVOzs7OzhCQUNPLG1CQUFtQjs7b0JBQ3ZDLE1BQU07Ozs7bUJBQ1AsS0FBSzs7Ozs0Q0FDUyxtQ0FBbUM7Ozs7OEJBQ3BDLG1CQUFtQjs7Ozt1QkFDaEIsV0FBVzs7SUFHdEIsdUJBQXVCO0FBQzlCLFdBRE8sdUJBQXVCLENBQzdCLElBQUksRUFBNEQ7UUFBMUQsSUFBSTtRQUF5QixzQkFBc0IseURBQUcsRUFBRTs7MEJBRHhELHVCQUF1Qjs7O0FBR3hDLFFBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDO0FBQ25CLFFBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDO0FBQ2pCLFFBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDO0FBQ2pCLFFBQUksQ0FBQyxTQUFTLEdBQUcsS0FBSyxDQUFDO0FBQ3ZCLFFBQUksQ0FBQyxNQUFNLEdBQUcsa0JBQUssRUFBRSxFQUFFLENBQUM7QUFDeEIsUUFBSSxDQUFDLFFBQVEsR0FBRyxrQkFBSyxFQUFFLEVBQUUsQ0FBQztBQUMxQixRQUFJLENBQUMsUUFBUSxHQUFHLENBQUMsQ0FBQztBQUNsQixRQUFJLENBQUMsUUFBUSxHQUFHLElBQUksTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQzlCLFFBQUksQ0FBQyxPQUFPLEdBQUcsQ0FBQyxDQUFDOzs7QUFHakIsUUFBSSxDQUFDLHNCQUFzQixHQUFHLHNCQUFzQixDQUFDO0FBQ3JELFFBQUksQ0FBQyxjQUFjLEdBQUcsSUFBSSxDQUFDO0dBQzVCOztlQWhCa0IsdUJBQXVCOztXQWtCNUI7Ozs7OztBQUNaLGdCQUFJLENBQUMsY0FBYyxHQUFHLDhDQUFzQixJQUFJLENBQUMs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QUFLLENBQUM7U0FDdEI7OztBQUdELFlBQUksQ0FBQyxPQUFPLEdBQUcsQ0FBQyxDQUFDOzs7QUFHakIsWUFBSSxLQUFLLEVBQUU7QUFDVCxjQUFJLENBQUMsY0FBYyxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsQ0FBQztTQUMxQztPQUNGO0tBQ0Y7OztXQUV1QixpQ0FBQyxvQkFBb0IsRUFBRTtBQUM3QyxVQUFJLENBQUMsb0JBQW9CLEdBQUcsb0JBQW9CLENBQUM7QUFDakQsVUFBSSxDQUFDLGNBQWMsQ0FBQyx1QkFBdUIsQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDO0tBQ25FOzs7U0ExVGtCLHVCQUF1Qjs7O3FCQUF2Qix1QkFBdUIiLCJmaWxlIjoibGliL3JlbW90ZS1kZWJ1Z2dlci1ycGMtY2xpZW50LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8ganNoaW50IGlnbm9yZTogc3RhcnRcbmltcG9ydCBsb2cgZnJvbSAnLi9sb2dnZXInO1xuaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBicGxpc3RDcmVhdGUgZnJvbSAnYnBsaXN0LWNyZWF0b3InO1xuaW1wb3J0IGJwbGlzdFBhcnNlIGZyb20gJ2JwbGlzdC1wYXJzZXInO1xuaW1wb3J0IGJ1ZmZlcnBhY2sgZnJvbSAnYnVmZmVycGFjayc7XG5pbXBvcnQgUHJvbWlzZSBmcm9tICdibHVlYmlyZCc7XG5pbXBvcnQgeyBSRU1PVEVfREVCVUdHRVJfUE9SVCB9IGZyb20gJy4vcmVtb3RlLWRlYnVnZ2VyJztcbmltcG9ydCB1dWlkIGZyb20gJ3V1aWQnO1xuaW1wb3J0IG5ldCBmcm9tICduZXQnO1xuaW1wb3J0IFJwY01lc3NhZ2VIYW5kbGVyIGZyb20gJy4vcmVtb3RlLWRlYnVnZ2VyLW1lc3NhZ2UtaGFuZGxlcic7XG5pbXBvcnQgZ2V0UmVtb3RlQ29tbWFuZCBmcm9tICcuL3JlbW90ZS1tZXNzYWdlcyc7XG5pbXBvcnQgeyBzaW1wbGVTdHJpbmdpZnkgfSBmcm9tICcuL2hlbHBlcnMnO1xuXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlbW90ZURlYnVnZ2VyUnBjQ2xpZW50IHtcbiAgY29uc3RydWN0b3IgKGhvc3QsIHBvcnQgPSBSRU1PVEVfREVCVUdHRVJfUE9SVCwgc3BlY2lhbE1lc3NhZ2VIYW5kbGVycyA9IHt9KSB7XG4gICAgLy8gc29ja2V0IGFuZCBjb25uZWN0aW9uIGNvbmZpZ3VyYXRpb25cbiAgICB0aGlzLnNvY2tldCA9IG51bGw7XG4gICAgdGhpcy5ob3N0ID0gaG9zdDtcbiAgICB0aGlzLnBvcnQgPSBwb3J0O1xuICAgIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG4gICAgdGhpcy5jb25uSWQgPSB1dWlkLnY0KCk7XG4gICAgdGhpcy5zZW5kZXJJZCA9IHV1aWQudjQoKTtcbiAgICB0aGlzLmN1ck1zZ0lkID0gMDtcbiAgICB0aGlzLnJlY2VpdmVkID0gbmV3IEJ1ZmZlcigwKTtcbiAgICB0aGlzLnJlYWRQb3MgPSAwO1xuXG4gICAgLy8gbWVzc2FnZSBoYW5kbGVyc1xuICAgIHRoaXMuc3BlY2lhbE1lc3NhZ2VIYW5kbGVycyA9IHNwZWNpYWxNZXNzYWdlSGFuZGxlcnM7XG4gICAgdGhpcy5tZXNzYWdlSGFuZGxlciA9IG51bGw7XG4gIH1cblxuICBhc3luYyBjb25uZWN0ICgpIHtcbiAgICB0aGlzLm1lc3NhZ2VIYW5kbGVyID0gbmV3IFJwY01lc3NhZ2VIYW5kbGVyKHRoaXMuc3BlY2lhbE1lc3NhZ2VIYW5kbGVycyk7XG5cbiAgICAvLyBjcmVhdGUgc29ja2V0IGFuZCBoYW5kbGUgaXRzIG1lc3NhZ2VzXG4gICAgdGhpcy5zb2NrZXQgPSBuZXcgbmV0LlNvY2tldCh7dHlwZTogJ3RjcDYnfSk7XG4gICAgdGhpcy5zb2NrZXQuc2V0Tm9EZWxheSh0cnVlKTtcbiAgICB0aGlzLnNvY2tldC5vbignY2xvc2UnLCAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5jb25uZWN0ZWQpIHtcbiAgICAgICAgbG9nLmRlYnVnKCdEZWJ1Z2dlciBzb2NrZXQgZGlzY29ubmVjdGVkJyk7XG4gICAgICB9XG4gICAgICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5zb2NrZXQgPSBudWxsO1xuICAgIH0pO1xuICAgIHRoaXMuc29ja2V0Lm9uKCdlbmQnLCAoKSA9PiB7XG4gICAgICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xuICAgIH0pO1xuICAgIHRoaXMuc29ja2V0Lm9uKCdkYXRhJywgdGhpcy5yZWNlaXZlLmJpbmQodGhpcykpO1xuXG4gICAgLy8gY29ubmVjdCB0aGUgc29ja2V0XG4gICAgcmV0dXJuIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIC8vIG9ubHkgcmVzb2x2ZSB0aGlzIGZ1bmN0aW9uIHdoZW4gd2UgYXJlIGFjdHVhbGx5IGNvbm5lY3RlZFxuICAgICAgdGhpcy5zb2NrZXQuY29ubmVjdCh0aGlzLnBvcnQsICc6OjEnKTtcbiAgICAgIHRoaXMuc29ja2V0Lm9uKCdjb25uZWN0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBsb2cuZGVidWcoYERlYnVnZ2VyIHNvY2tldCBjb25uZWN0ZWQgdG8gJHt0aGlzLnNvY2tldC5yZW1vdGVBZGRyZXNzfToke3RoaXMuc29ja2V0LnJlbW90ZVBvcnR9YCk7XG4gICAgICAgIHRoaXMuY29ubmVjdGVkID0gdHJ1ZTtcblxuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuc29ja2V0Lm9uKCdlcnJvcicsIChleGNlcHRpb24pID0+IHtcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgICAgICAgbG9nLmVycm9yKGBTb2NrZXQgZXJyb3I6ICR7ZXhjZXB0aW9uLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRoZSBjb25uZWN0aW9uIHdhcyByZWZ1c2VkLCBzbyByZWplY3QgdGhlIGNvbm5lY3QgcHJvbWlzZVxuICAgICAgICByZWplY3QoZXhjZXB0aW9uKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgYXN5bmMgZGlzY29ubmVjdCAoKSB7XG4gICAgaWYgKHRoaXMuaXNDb25uZWN0ZWQoKSkge1xuICAgICAgbG9nLmRlYnVnKCdEaXNjb25uZWN0aW5nIGZyb20gcmVtb3RlIGRlYnVnZ2VyJyk7XG4gICAgICB0aGlzLnNvY2tldC5kZXN0cm95KCk7XG4gICAgfVxuICAgIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG4gIH1cblxuICBpc0Nvbm5lY3RlZCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29ubmVjdGVkO1xuICB9XG5cbiAgc2V0U3BlY2lhbE1lc3NhZ2VIYW5kbGVyIChrZXksIGVycm9ySGFuZGxlciwgaGFuZGxlcikge1xuICAgIHRoaXMubWVzc2FnZUhhbmRsZXIuc2V0U3BlY2lhbE1lc3NhZ2VIYW5kbGVyKGtleSwgZXJyb3JIYW5kbGVyLCBoYW5kbGVyKTtcbiAgfVxuXG4gIGdldFNwZWNpYWxNZXNzYWdlSGFuZGxlciAoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuZ2V0U3BlY2lhbE1lc3NhZ2VIYW5kbGVyKGtleSk7XG4gIH1cblxuICBzZXREYXRhTWVzc2FnZUhhbmRsZXIgKGtleSwgZXJyb3JIYW5kbGVyLCBoYW5kbGVyKSB7XG4gICAgdGhpcy5tZXNzYWdlSGFuZGxlci5zZXREYXRhTWVzc2FnZUhhbmRsZXIoa2V5LCBlcnJvckhhbmRsZXIsIGhhbmRsZXIpO1xuICB9XG5cbiAgYWxsb3dOYXZpZ2F0aW9uV2l0aG91dFJlbG9hZCAoYWxsb3cgPSB0cnVlKSB7XG4gICAgdGhpcy5tZXNzYWdlSGFuZGxlci5hbGxvd05hdmlnYXRpb25XaXRob3V0UmVsb2FkKGFsbG93KTtcbiAgfVxuXG4gIGFzeW5jIHNlbGVjdEFwcCAoYXBwSWRLZXksIGFwcGxpY2F0aW9uQ29ubmVjdGVkSGFuZGxlcikge1xuICAgIHJldHVybiBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAvLyBsb2NhbCBjYWxsYmFjaywgdGVtcG9yYXJpbHkgYWRkZWQgYXMgY2FsbGJhY2sgdG9cbiAgICAgIC8vIGBfcnBjX2FwcGxpY2F0aW9uQ29ubmVjdGVkOmAgcmVtb3RlIGRlYnVnZ2VyIHJlc3BvbnNlXG4gICAgICAvLyB0byBoYW5kbGUgdGhlIGluaXRpYWwgY29ubmVjdGlvblxuICAgICAgbGV0IG9uQXBwQ2hhbmdlID0gYXN5bmMgKGRpY3QpID0+IHtcbiAgICAgICAgLy8gZnJvbSB0aGUgZGljdGlvbmFyeSByZXR1cm5lZCwgZ2V0IHRoZSBpZHNcbiAgICAgICAgbGV0IG9sZEFwcElkS2V5ID0gZGljdC5XSVJIb3N0QXBwbGljYXRpb25JZGVudGlmaWVyS2V5O1xuICAgICAgICBsZXQgY29ycmVjdEFwcElkS2V5ID0gZGljdC5XSVJBcHBsaWNhdGlvbklkZW50aWZpZXJLZXk7XG5cbiAgICAgICAgLy8gaWYgdGhpcyBpcyBhIHJlcG9ydCBvZiBhIHByb3h5IHJlZGlyZWN0IGZyb20gdGhlIHJlbW90ZSBkZWJ1Z2dlclxuICAgICAgICAvLyB3ZSB3YW50IHRvIHVwZGF0ZSBvdXIgZGljdGlvbmFyeSBhbmQgZ2V0IGEgbmV3IGFwcCBpZFxuICAgICAgICBpZiAob2xkQXBwSWRLZXkgJiYgY29ycmVjdEFwcElkS2V5ICE9PSBvbGRBcHBJZEtleSkge1xuICAgICAgICAgIGxvZy5kZWJ1ZyhgV2Ugd2VyZSBub3RpZmllZCB3ZSBtaWdodCBoYXZlIGNvbm5lY3RlZCB0byB0aGUgd3JvbmcgYXBwLiBgICtcbiAgICAgICAgICAgICAgICAgICAgYFVzaW5nIGlkICR7Y29ycmVjdEFwcElkS2V5fSBpbnN0ZWFkIG9mICR7b2xkQXBwSWRLZXl9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBhcHBsaWNhdGlvbkNvbm5lY3RlZEhhbmRsZXIoZGljdCk7XG4gICAgICAgIHJlamVjdCgnTmV3IGFwcGxpY2F0aW9uIGhhcyBjb25uZWN0ZWQnKTtcbiAgICAgIH07XG4gICAgICB0aGlzLnNldFNwZWNpYWxNZXNzYWdlSGFuZGxlcignX3JwY19hcHBsaWNhdGlvbkNvbm5lY3RlZDonLCByZWplY3QsIG9uQXBwQ2hhbmdlKTtcblxuICAgICAgLy8gZG8gdGhlIGFjdHVhbCBjb25uZWN0aW5nIHRvIHRoZSBhcHBcbiAgICAgIHJldHVybiAoYXN5bmMgKCkgPT4ge1xuICAgICAgICBsZXQgW2Nvbm5lY3RlZEFwcElkS2V5LCBwYWdlRGljdF0gPSBhd2FpdCB0aGlzLnNlbmQoJ2Nvbm5lY3RUb0FwcCcsIHtcbiAgICAgICAgICBhcHBJZEtleVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBzb21ldGltZXMgdGhlIGNvbm5lY3QgbG9naWMgaGFwcGVucywgYnV0IHdpdGggYW4gZW1wdHkgZGljdGlvbmFyeVxuICAgICAgICAvLyB3aGljaCBsZWFkcyB0byB0aGUgcmVtb3RlIGRlYnVnZ2VyIGdldHRpbmcgZGlzY29ubmVjdGVkLCBhbmQgaW50byBhIGxvb3BcbiAgICAgICAgaWYgKF8uaXNFbXB0eShwYWdlRGljdCkpIHtcbiAgICAgICAgICBsZXQgbXNnID0gJ0VtcHR5IHBhZ2UgZGljdGlvbmFyeSByZWNlaXZlZCc7XG4gICAgICAgICAgbG9nLmRlYnVnKG1zZyk7XG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihtc2cpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNvbHZlKFtjb25uZWN0ZWRBcHBJZEtleSwgcGFnZURpY3RdKTtcbiAgICAgICAgfVxuICAgICAgfSkoKTtcbiAgICB9KS5maW5hbGx5KCgpID0+IHtcbiAgICAgIC8vIG5vIG1hdHRlciB3aGF0LCB3ZSB3YW50IHRvIHJlc3RvcmUgdGhlIGhhbmRsZXIgdGhhdCB3YXMgY2hhbmdlZC5cbiAgICAgIHRoaXMuc2V0U3BlY2lhbE1lc3NhZ2VIYW5kbGVyKCdfcnBjX2FwcGxpY2F0aW9uQ29ubmVjdGVkOicsIG51bGwsIGFwcGxpY2F0aW9uQ29ubmVjdGVkSGFuZGxlcik7XG4gICAgfSk7XG4gIH1cblxuICBhc3luYyBzZW5kIChjb21tYW5kLCBvcHRzID0ge30pIHtcbiAgICAvLyBlcnJvciBsaXN0ZW5lciwgd2hpY2ggbmVlZHMgdG8gYmUgcmVtb3ZlZCBhZnRlciB0aGUgcHJvbWlzZSBpcyByZXNvbHZlZFxuICAgIGxldCBvblNvY2tldEVycm9yO1xuXG4gICAgcmV0dXJuIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIC8vIHByb21pc2UgdG8gYmUgcmVzb2x2ZWQgd2hlbmV2ZXIgcmVtb3RlIGRlYnVnZ2VyXG4gICAgICAvLyByZXBsaWVzIHRvIG91ciByZXF1ZXN0XG5cbiAgICAgIC8vIHJldHJpZXZlIHRoZSBjb3JyZWN0IGNvbW1hbmQgdG8gc2VuZFxuICAgICAgb3B0cyA9IF8uZGVmYXVsdHMoe2Nvbm5JZDogdGhpcy5jb25uSWQsIHNlbmRlcklkOiB0aGlzLnNlbmRlcklkfSwgb3B0cyk7XG4gICAgICBsZXQgZGF0YSA9IGdldFJlbW90ZUNvbW1hbmQoY29tbWFuZCwgb3B0cyk7XG5cbiAgICAgIC8vIG1vc3Qgb2YgdGhlIHRpbWUgd2UgZG9uJ3QgY2FyZSB3aGVuIHNvY2tldC53cml0ZSBkb2VzXG4gICAgICAvLyBzbyBnaXZlIGl0IGFuIGVtcHR5IGZ1bmN0aW9uXG4gICAgICBsZXQgc29ja2V0Q2IgPSBfLm5vb3A7XG5cbiAgICAgIC8vIGhhbmRsZSBzb2NrZXQgcHJvYmxlbXNcbiAgICAgIG9uU29ja2V0RXJyb3IgPSAoZXhjZXB0aW9uKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3RlZCkge1xuICAgICAgICAgIGxvZy5lcnJvcihgU29ja2V0IGVycm9yOiAke2V4Y2VwdGlvbi5tZXNzYWdlfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdGhlIGNvbm5lY3Rpb24gd2FzIHJlZnVzZWQsIHNvIHJlamVjdCB0aGUgY29ubmVjdCBwcm9taXNlXG4gICAgICAgIHJlamVjdChleGNlcHRpb24pO1xuICAgICAgfTtcbiAgICAgIHRoaXMuc29ja2V0Lm9uKCdlcnJvcicsIG9uU29ja2V0RXJyb3IpO1xuICAgICAgaWYgKHRoaXMubWVzc2FnZUhhbmRsZXIuaGFzU3BlY2lhbE1lc3NhZ2VIYW5kbGVyKGRhdGEuX19zZWxlY3RvcikpIHtcbiAgICAgICAgLy8gc3BlY2lhbCByZXBsaWVzIHdpbGwgcmV0dXJuIGFueSBudW1iZXIgb2YgYXJndW1lbnRzXG4gICAgICAgIC8vIHRlbXBvcmFyaWx5IHdyYXAgd2l0aCBwcm9taXNlIGhhbmRsaW5nXG4gICAgICAgIGxldCBzcGVjaWFsTWVzc2FnZUhhbmRsZXIgPSB0aGlzLmdldFNwZWNpYWxNZXNzYWdlSGFuZGxlcihkYXRhLl9fc2VsZWN0b3IpO1xuICAgICAgICB0aGlzLnNldFNwZWNpYWxNZXNzYWdlSGFuZGxlcihkYXRhLl9fc2VsZWN0b3IsIHJlamVjdCwgZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgICBsb2cuZGVidWcoYFJlY2VpdmVkIHJlc3BvbnNlIGZyb20gc29ja2V0IHNlbmQ6ICcke18udHJ1bmNhdGUoSlNPTi5zdHJpbmdpZnkoYXJncyksIHtsZW5ndGg6IDUwfSl9J2ApO1xuXG4gICAgICAgICAgLy8gY2FsbCB0aGUgb3JpZ2luYWwgbGlzdGVuZXIsIGFuZCBwdXQgaXQgYmFjaywgaWYgbmVjZXNzYXJ5XG4gICAgICAgICAgc3BlY2lhbE1lc3NhZ2VIYW5kbGVyKC4uLmFyZ3MpO1xuICAgICAgICAgIGlmICh0aGlzLm1lc3NhZ2VIYW5kbGVyLmhhc1NwZWNpYWxNZXNzYWdlSGFuZGxlcihkYXRhLl9fc2VsZWN0b3IpKSB7XG4gICAgICAgICAgICAvLyB0aGlzIG1lYW5zIHRoYXQgdGhlIHN5c3RlbSBoYXMgbm90IHJlbW92ZWQgdGhpcyBsaXN0ZW5lclxuICAgICAgICAgICAgdGhpcy5zZXRTcGVjaWFsTWVzc2FnZUhhbmRsZXIoZGF0YS5fX3NlbGVjdG9yLCBudWxsLCBzcGVjaWFsTWVzc2FnZUhhbmRsZXIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlc29sdmUoYXJncyk7XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICB9IGVsc2UgaWYgKGRhdGEuX19hcmd1bWVudCAmJiBkYXRhLl9fYXJndW1lbnQuV0lSU29ja2V0RGF0YUtleSkge1xuICAgICAgICAvLyBrZWVwIHRyYWNrIG9mIHRoZSBtZXNzYWdlcyBjb21pbmcgYW5kIGdvaW5nIHVzaW5nXG4gICAgICAgIC8vIGEgc2ltcGxlIHNlcXVlbnRpYWwgaWRcbiAgICAgICAgdGhpcy5jdXJNc2dJZCsrO1xuICAgICAgICB0aGlzLnNldERhdGFNZXNzYWdlSGFuZGxlcih0aGlzLmN1ck1zZ0lkLnRvU3RyaW5nKCksIHJlamVjdCwgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgbGV0IG1zZyA9IF8udHJ1bmNhdGUoXy5pc1N0cmluZyh2YWx1ZSkgPyB2YWx1ZSA6IEpTT04uc3RyaW5naWZ5KHZhbHVlKSwge2xlbmd0aDogNTB9KTtcbiAgICAgICAgICBsb2cuZGVidWcoYFJlY2VpdmVkIGRhdGEgcmVzcG9uc2UgZnJvbSBzb2NrZXQgc2VuZDogJyR7bXNnfSdgKTtcbiAgICAgICAgICBsb2cuZGVidWcoYE9yaWdpbmFsIGNvbW1hbmQ6ICR7Y29tbWFuZH1gKTtcbiAgICAgICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRhdGEuX19hcmd1bWVudC5XSVJTb2NrZXREYXRhS2V5LmlkID0gdGhpcy5jdXJNc2dJZDtcbiAgICAgICAgZGF0YS5fX2FyZ3VtZW50LldJUlNvY2tldERhdGFLZXkgPVxuICAgICAgICAgICAgbmV3IEJ1ZmZlcihKU09OLnN0cmluZ2lmeShkYXRhLl9fYXJndW1lbnQuV0lSU29ja2V0RGF0YUtleSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gd2Ugd2FudCB0byBpbW1lZGlhdGVseSByZXNvbHZlIHRoaXMgc29ja2V0LndyaXRlXG4gICAgICAgIC8vIGFueSBsb25nIHRlcm0gY2FsbGJhY2tzIHdpbGwgZG8gdGhlaXIgYnVzaW5lc3MgaW4gdGhlIGJhY2tncm91bmRcbiAgICAgICAgc29ja2V0Q2IgPSByZXNvbHZlO1xuICAgICAgfVxuXG4gICAgICBsb2cuZGVidWcoYFNlbmRpbmcgJyR7ZGF0YS5fX3NlbGVjdG9yfScgbWVzc2FnZSB0byByZW1vdGUgZGVidWdnZXJgKTtcblxuICAgICAgLy8gcmVtb3RlIGRlYnVnZ2VyIGV4cGVjdHMgYSBiaW5hcnkgcGxpc3QgYXMgZGF0YVxuICAgICAgbGV0IHBsaXN0O1xuICAgICAgdHJ5IHtcbiAgICAgICAgcGxpc3QgPSBicGxpc3RDcmVhdGUoZGF0YSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGxldCBtc2cgPSBgQ291bGQgbm90IGNyZWF0ZSBiaW5hcnkgcGxpc3QgZnJvbSBkYXRhOiAke2UubWVzc2FnZX1gO1xuICAgICAgICBsb2cuZXJyb3IobXNnKTtcbiAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IobXNnKSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnNvY2tldCAmJiB0aGlzLmNvbm5lY3RlZCkge1xuICAgICAgICAvLyBjb3JrIGFuZCB1bmNvcmsgaW4gb3JkZXIgdG8gbm90IGJ1ZmZlciB0aGUgd3JpdGVcbiAgICAgICAgLy8gb24gc29tZSBzeXN0ZW1zIHRoaXMgaXMgbmVjZXNzYXJ5IG9yIHRoZSBzZXJ2ZXJcbiAgICAgICAgLy8gZ2V0cyBjb25mdXNlZC5cbiAgICAgICAgdGhpcy5zb2NrZXQuY29yaygpO1xuICAgICAgICB0aGlzLnNvY2tldC53cml0ZShidWZmZXJwYWNrLnBhY2soJ0wnLCBbcGxpc3QubGVuZ3RoXSkpO1xuICAgICAgICB0aGlzLnNvY2tldC53cml0ZShwbGlzdCwgc29ja2V0Q2IpO1xuICAgICAgICB0aGlzLnNvY2tldC51bmNvcmsoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBtc2cgPSAnQXR0ZW1wdGVkIHRvIHdyaXRlIGRhdGEgdG8gc29ja2V0IGFmdGVyIGl0IHdhcyBjbG9zZWQhJztcbiAgICAgICAgbG9nLmVycm9yKG1zZyk7XG4gICAgICAgIHJlamVjdChuZXcgRXJyb3IobXNnKSk7XG4gICAgICB9XG4gICAgfSkuZmluYWxseSgoKSA9PiB7XG4gICAgICAvLyByZW1vdmUgdGhpcyBsaXN0ZW5lciwgc28gd2UgZG9uJ3QgZXhoYXVzdCB0aGUgc3lzdGVtXG4gICAgICB0aGlzLnNvY2tldC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvblNvY2tldEVycm9yKTtcbiAgICB9KTtcbiAgfVxuXG4gIHJlY2VpdmUgKGRhdGEpIHtcbiAgICAvLyBBcHBlbmQgdGhpcyBuZXcgZGF0YSB0byB0aGUgZXhpc3RpbmcgQnVmZmVyXG4gICAgdGhpcy5yZWNlaXZlZCA9IEJ1ZmZlci5jb25jYXQoW3RoaXMucmVjZWl2ZWQsIGRhdGFdKTtcbiAgICBsZXQgZGF0YUxlZnRPdmVyID0gdHJ1ZTtcblxuICAgIC8vIFBhcnNlIG11bHRpcGxlIG1lc3NhZ2VzIGluIHRoZSBzYW1lIHBhY2tldFxuICAgIHdoaWxlIChkYXRhTGVmdE92ZXIpIHtcbiAgICAgIC8vIFN0b3JlIGEgcmVmZXJlbmNlIHRvIHdoZXJlIHdlIHdlcmVcbiAgICAgIGxldCBvbGRSZWFkUG9zID0gdGhpcy5yZWFkUG9zO1xuXG4gICAgICAvLyBSZWFkIHRoZSBwcmVmaXggKHBsaXN0IGxlbmd0aCkgdG8gc2VlIGhvdyBmYXIgdG8gcmVhZCBuZXh0XG4gICAgICAvLyBJdCdzIGFsd2F5cyA0IGJ5dGVzIGxvbmdcbiAgICAgIGxldCBwcmVmaXggPSB0aGlzLnJlY2VpdmVkLnNsaWNlKHRoaXMucmVhZFBvcywgdGhpcy5yZWFkUG9zICsgNCk7XG5cbiAgICAgIGxldCBtc2dMZW5ndGg7XG4gICAgICB0cnkge1xuICAgICAgICBtc2dMZW5ndGggPSBidWZmZXJwYWNrLnVucGFjaygnTCcsIHByZWZpeClbMF07XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGxvZy5lcnJvcihgQnVmZmVyIGNvdWxkIG5vdCB1bnBhY2s6ICR7ZX1gKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBKdW1wIGZvcndhcmQgNCBieXRlc1xuICAgICAgdGhpcy5yZWFkUG9zICs9IDQ7XG5cbiAgICAgIC8vIElzIHRoZXJlIGVub3VnaCBkYXRhIGhlcmU/XG4gICAgICAvLyBJZiBub3QsIGp1bXAgYmFjayB0byBvdXIgb3JpZ2luYWwgcG9zaXRpb24gYW5kIGd0Zm9cbiAgICAgIGlmICh0aGlzLnJlY2VpdmVkLmxlbmd0aCA8IG1zZ0xlbmd0aCArIHRoaXMucmVhZFBvcykge1xuICAgICAgICB0aGlzLnJlYWRQb3MgPSBvbGRSZWFkUG9zO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgLy8gRXh0cmFjdCB0aGUgbWFpbiBib2R5IG9mIHRoZSBtZXNzYWdlICh3aGVyZSB0aGUgcGxpc3Qgc2hvdWxkIGJlKVxuICAgICAgbGV0IGJvZHkgPSB0aGlzLnJlY2VpdmVkLnNsaWNlKHRoaXMucmVhZFBvcywgbXNnTGVuZ3RoICsgdGhpcy5yZWFkUG9zKTtcblxuICAgICAgLy8gRXh0cmFjdCB0aGUgcGxpc3RcbiAgICAgIGxldCBwbGlzdDtcbiAgICAgIHRyeSB7XG4gICAgICAgIHBsaXN0ID0gYnBsaXN0UGFyc2UucGFyc2VCdWZmZXIoYm9keSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGxvZy5lcnJvcihgRXJyb3IgcGFyc2luZyBiaW5hcnkgcGxpc3Q6ICR7ZX1gKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBicGxpc3RQYXJzZS5wYXJzZUJ1ZmZlciByZXR1cm5zIGFuIGFycmF5XG4gICAgICBpZiAocGxpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHBsaXN0ID0gcGxpc3RbMF07XG4gICAgICB9XG5cbiAgICAgIGZvciAobGV0IGtleSBvZiBbJ1dJUk1lc3NhZ2VEYXRhS2V5JywgJ1dJUkRlc3RpbmF0aW9uS2V5JywgJ1dJUlNvY2tldERhdGFLZXknXSkge1xuICAgICAgICBpZiAoIV8uaXNVbmRlZmluZWQocGxpc3Rba2V5XSkpIHtcbiAgICAgICAgICBwbGlzdFtrZXldID0gcGxpc3Rba2V5XS50b1N0cmluZyhcInV0ZjhcIik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHBsaXN0Ll9fc2VsZWN0b3IgPT09IFwiX3JwY19hcHBsaWNhdGlvblNlbnREYXRhOlwiKSB7XG4gICAgICAgIGxvZy5kZWJ1ZygnUmVjZWl2ZWQgYXBwbGljYXRpb25TZW50RGF0YSByZXNwb25zZScpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbG9nLmRlYnVnKGBSZWNlaXZpbmcgZGF0YSBmcm9tIHJlbW90ZSBkZWJ1Z2dlcjogJyR7c2ltcGxlU3RyaW5naWZ5KHBsaXN0KX0nYCk7XG4gICAgICB9XG5cbiAgICAgIC8vIEp1bXAgZm9yd2FyZCB0aGUgbGVuZ3RoIG9mIHRoZSBwbGlzdFxuICAgICAgdGhpcy5yZWFkUG9zICs9IG1zZ0xlbmd0aDtcblxuICAgICAgLy8gQ2FsY3VsYXRlIGhvdyBtdWNoIGJ1ZmZlciBpcyBsZWZ0XG4gICAgICBsZXQgbGVmdE92ZXIgPSB0aGlzLnJlY2VpdmVkLmxlbmd0aCAtIHRoaXMucmVhZFBvcztcblxuICAgICAgLy8gSXMgdGhlcmUgc29tZSBsZWZ0IG92ZXI/XG4gICAgICBpZiAobGVmdE92ZXIgIT09IDApIHtcbiAgICAgICAgLy8gQ29weSB3aGF0J3MgbGVmdCBvdmVyIGludG8gYSBuZXcgYnVmZmVyLCBhbmQgc2F2ZSBpdCBmb3IgbmV4dCB0aW1lXG4gICAgICAgIGxldCBjaHVuayA9IG5ldyBCdWZmZXIobGVmdE92ZXIpO1xuICAgICAgICB0aGlzLnJlY2VpdmVkLmNvcHkoY2h1bmssIDAsIHRoaXMucmVhZFBvcyk7XG4gICAgICAgIHRoaXMucmVjZWl2ZWQgPSBjaHVuaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE90aGVyd2lzZSwgZW1wdHkgdGhlIGJ1ZmZlciBhbmQgZ2V0IG91dCBvZiB0aGUgbG9vcFxuICAgICAgICB0aGlzLnJlY2VpdmVkID0gbmV3IEJ1ZmZlcigwKTtcbiAgICAgICAgZGF0YUxlZnRPdmVyID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIFJlc2V0IHRoZSByZWFkIHBvc2l0aW9uXG4gICAgICB0aGlzLnJlYWRQb3MgPSAwO1xuXG4gICAgICAvLyBOb3cgZG8gc29tZXRoaW5nIHdpdGggdGhlIHBsaXN0XG4gICAgICBpZiAocGxpc3QpIHtcbiAgICAgICAgdGhpcy5tZXNzYWdlSGFuZGxlci5oYW5kbGVNZXNzYWdlKHBsaXN0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzZXRUaW1lbGluZUV2ZW50SGFuZGxlciAodGltZWxpbmVFdmVudEhhbmRsZXIpIHtcbiAgICB0aGlzLnRpbWVsaW5lRXZlbnRIYW5kbGVyID0gdGltZWxpbmVFdmVudEhhbmRsZXI7XG4gICAgdGhpcy5tZXNzYWdlSGFuZGxlci5zZXRUaW1lbGluZUV2ZW50SGFuZGxlcih0aW1lbGluZUV2ZW50SGFuZGxlcik7XG4gIH1cbn1cbiJdLCJzb3VyY2VSb290IjoiLi4vLi4ifQ==
