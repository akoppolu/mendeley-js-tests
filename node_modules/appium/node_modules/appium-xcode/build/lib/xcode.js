'use strict';

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _appiumSupport = require('appium-support');

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _asyncbox = require('asyncbox');

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _plist = require('plist');

var _teen_process = require('teen_process');

var env = process.env;

var XCRUN_TIMEOUT = 15000;
var XCODE_SUBDIR = "/Contents/Developer";
var DEFAULT_NUMBER_OF_RETRIES = 3;

var log = _appiumSupport.logger.getLogger('Xcode');

function hasExpectedSubDir(path) {
  return path.substring(path.length - XCODE_SUBDIR.length) === XCODE_SUBDIR;
}

function runXcrunCommand(args) {
  var timeout = arguments.length <= 1 || arguments[1] === undefined ? XCRUN_TIMEOUT : arguments[1];
  return _regeneratorRuntime.async(function runXcrunCommand$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.prev = 0;
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)('xcrun', args, { timeout: timeout }));

      case 3:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 6:
        context$1$0.prev = 6;
        context$1$0.t0 = context$1$0['catch'](0);

        // the true error can be hidden within the stderr
        if (context$1$0.t0.stderr) {
          context$1$0.t0.message = context$1$0.t0.message + ': ' + context$1$0.t0.stderr;
        }

        throw context$1$0.t0;

      case 10:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[0, 6]]);
}

function getPathFromSymlink(failMessage) {
  var symlinkPath, legacySymlinkPath, xcodePath, customPath, mesg, msg;
  return _regeneratorRuntime.async(function getPathFromSymlink$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        // Node's invocation of xcode-select sometimes flakes and returns an empty string.
        // Not clear why. As a workaround, Appium can reliably deduce the version in use by checking
        // the locations xcode-select uses to store the selected version's path. This should be 100%
        // reliable so long as the link locations remain the same. However, since we're relying on
        // hardcoded paths, this approach will break the next time Apple changes the symlink location.
        log.warn('Finding XcodePath by symlink because ' + failMessage);

        symlinkPath = "/var/db/xcode_select_link";
        legacySymlinkPath = "/usr/share/xcode-select/xcode_dir_link";
        xcodePath = null;

        if (!_appiumSupport.util.hasContent(env.DEVELOPER_DIR)) {
          context$1$0.next = 17;
          break;
        }

        customPath = hasExpectedSubDir(env.DEVELOPER_DIR) ? env.DEVELOPER_DIR : env.DEVELOPER_DIR + XCODE_SUBDIR;
        context$1$0.next = 8;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.exists(customPath));

      case 8:
        if (!context$1$0.sent) {
          context$1$0.next = 12;
          break;
        }

        xcodePath = customPath;
        context$1$0.next = 15;
        break;

      case 12:
        mesg = 'Could not find path to Xcode, environment variable ' + ('DEVELOPER_DIR set to: ' + env.DEVELOPER_DIR + ' ') + 'but no Xcode found';

        log.warn(mesg);
        throw new Error(mesg);

      case 15:
        context$1$0.next = 31;
        break;

      case 17:
        context$1$0.next = 19;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.exists(symlinkPath));

      case 19:
        if (!context$1$0.sent) {
          context$1$0.next = 25;
          break;
        }

        context$1$0.next = 22;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.readlink(symlinkPath));

      case 22:
        xcodePath = context$1$0.sent;
        context$1$0.next = 31;
        break;

      case 25:
        context$1$0.next = 27;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.exists(legacySymlinkPath));

      case 27:
        if (!context$1$0.sent) {
          context$1$0.next = 31;
          break;
        }

        context$1$0.next = 30;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.readlink(legacySymlinkPath));

      case 30:
        xcodePath = context$1$0.sent;

      case 31:
        if (!xcodePath) {
          context$1$0.next = 33;
          break;
        }

        return context$1$0.abrupt('return', xcodePath.replace(new RegExp("/$"), "").trim());

      case 33:
        msg = 'Could not find path to Xcode by symlinks located in ' + symlinkPath + ', or ' + legacySymlinkPath;

        log.warn(msg);
        throw new Error(msg);

      case 36:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

function getPathFromXcodeSelect() {
  var timeout = arguments.length <= 0 || arguments[0] === undefined ? XCRUN_TIMEOUT : arguments[0];

  var _ref, stdout, xcodeFolderPath, msg;

  return _regeneratorRuntime.async(function getPathFromXcodeSelect$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)('xcode-select', ['--print-path'], { timeout: timeout }));

      case 2:
        _ref = context$1$0.sent;
        stdout = _ref.stdout;
        xcodeFolderPath = stdout.replace(/\/$/, '').trim();

        if (!_appiumSupport.util.hasContent(xcodeFolderPath)) {
          log.errorAndThrow('xcode-select returned an empty string');
        }

        context$1$0.next = 8;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.exists(xcodeFolderPath));

      case 8:
        if (!context$1$0.sent) {
          context$1$0.next = 12;
          break;
        }

        return context$1$0.abrupt('return', xcodeFolderPath);

      case 12:
        msg = 'xcode-select could not find xcode. Path \'' + xcodeFolderPath + '\' does not exist.';

        log.errorAndThrow(msg);

      case 14:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

var getPath = _lodash2['default'].memoize(function () {
  var timeout = arguments.length <= 0 || arguments[0] === undefined ? XCRUN_TIMEOUT : arguments[0];

  // first we try using xcode-select to find the path
  // then we try using the symlinks that Apple has by default
  return getPathFromXcodeSelect(timeout)['catch'](getPathFromSymlink);
});

function getVersionWithoutRetry() {
  var timeout = arguments.length <= 0 || arguments[0] === undefined ? XCRUN_TIMEOUT : arguments[0];
  var xcodePath, plistPath, version, versionPattern, match;
  return _regeneratorRuntime.async(function getVersionWithoutRetry$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(getPath(timeout));

      case 2:
        xcodePath = context$1$0.sent;
        plistPath = _path2['default'].resolve(xcodePath, "..", "Info.plist");
        context$1$0.next = 6;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.exists(plistPath));

      case 6:
        if (context$1$0.sent) {
          context$1$0.next = 8;
          break;
        }

        throw new Error('Could not get Xcode version. ' + plistPath + ' does not exist on disk.');

      case 8:
        context$1$0.next = 10;
        return _regeneratorRuntime.awrap(_appiumSupport.plist.parsePlistFile(plistPath));

      case 10:
        version = context$1$0.sent;

        version = version.CFBundleShortVersionString;

        versionPattern = /\d\.\d\.*\d*/;
        match = version.match(versionPattern);

        if (match === null || !_appiumSupport.util.hasContent(match[0])) {
          log.errorAndThrow('Could not parse Xcode version. xcodebuild output was: ' + version);
        }

        return context$1$0.abrupt('return', match[0]);

      case 16:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

var getVersionMemoized = _lodash2['default'].memoize(function () {
  var retries = arguments.length <= 0 || arguments[0] === undefined ? DEFAULT_NUMBER_OF_RETRIES : arguments[0];
  var timeout = arguments.length <= 1 || arguments[1] === undefined ? XCRUN_TIMEOUT : arguments[1];

  return (0, _asyncbox.retry)(retries, getVersionWithoutRetry, timeout);
});

function getVersion() {
  var parse = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];
  var retries = arguments.length <= 1 || arguments[1] === undefined ? DEFAULT_NUMBER_OF_RETRIES : arguments[1];
  var timeout = arguments.length <= 2 || arguments[2] === undefined ? XCRUN_TIMEOUT : arguments[2];
  var version, match;
  return _regeneratorRuntime.async(function getVersion$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(getVersionMemoized(retries, timeout));

      case 2:
        version = context$1$0.sent;

        if (parse) {
          context$1$0.next = 5;
          break;
        }

        return context$1$0.abrupt('return', version);

      case 5:
        match = /^(\d+)\.(\d+)(\.(\d+))?$/.exec(version);
        return context$1$0.abrupt('return', {
          versionString: version,
          versionFloat: parseFloat(match[1] + '.' + match[2]),
          major: parseInt(match[1], 10),
          minor: parseInt(match[2], 10),
          patch: match[4] ? parseInt(match[4], 10) : undefined
        });

      case 7:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

function getCommandLineToolsVersion() {
  var stdout, match;
  return _regeneratorRuntime.async(function getCommandLineToolsVersion$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        stdout = undefined;
        context$1$0.prev = 1;
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)('pkgutil', ['--pkg-info=com.apple.pkg.CLTools_Executables']));

      case 4:
        stdout = context$1$0.sent.stdout;
        context$1$0.next = 18;
        break;

      case 7:
        context$1$0.prev = 7;
        context$1$0.t0 = context$1$0['catch'](1);
        context$1$0.prev = 9;
        context$1$0.next = 12;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)('pkgutil', ['--pkg-info=com.apple.pkg.DeveloperToolsCLI']));

      case 12:
        stdout = context$1$0.sent.stdout;
        context$1$0.next = 18;
        break;

      case 15:
        context$1$0.prev = 15;
        context$1$0.t1 = context$1$0['catch'](9);

        stdout = '';

      case 18:
        match = /^version: (.+)$/m.exec(stdout);
        return context$1$0.abrupt('return', match ? match[1] : undefined);

      case 20:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[1, 7], [9, 15]]);
}

function getAutomationTraceTemplatePathWithoutRetry() {
  var timeout = arguments.length <= 0 || arguments[0] === undefined ? XCRUN_TIMEOUT : arguments[0];
  var xcodePath, extensions, pathPrefix, pathSuffix, automationTraceTemplatePaths, msg;
  return _regeneratorRuntime.async(function getAutomationTraceTemplatePathWithoutRetry$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(getPath(timeout));

      case 2:
        xcodePath = context$1$0.sent;
        extensions = ['xrplugin', 'bundle'];
        pathPrefix = _path2['default'].resolve(xcodePath, "../Applications/Instruments.app/Contents/PlugIns");
        pathSuffix = "Contents/Resources/Automation.tracetemplate";
        automationTraceTemplatePaths = [_path2['default'].resolve(pathPrefix, 'AutomationInstrument.' + extensions[0], pathSuffix), _path2['default'].resolve(pathPrefix, 'AutomationInstrument.' + extensions[1], pathSuffix)];
        context$1$0.next = 9;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.exists(automationTraceTemplatePaths[0]));

      case 9:
        if (!context$1$0.sent) {
          context$1$0.next = 11;
          break;
        }

        return context$1$0.abrupt('return', automationTraceTemplatePaths[0]);

      case 11:
        context$1$0.next = 13;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.exists(automationTraceTemplatePaths[1]));

      case 13:
        if (!context$1$0.sent) {
          context$1$0.next = 15;
          break;
        }

        return context$1$0.abrupt('return', automationTraceTemplatePaths[1]);

      case 15:
        msg = "Could not find Automation.tracetemplate in any of the following" + ('locations ' + automationTraceTemplatePaths.toString());

        log.error(msg);
        throw new Error(msg);

      case 18:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

var getAutomationTraceTemplatePath = _lodash2['default'].memoize(function () {
  var retries = arguments.length <= 0 || arguments[0] === undefined ? DEFAULT_NUMBER_OF_RETRIES : arguments[0];
  var timeout = arguments.length <= 1 || arguments[1] === undefined ? XCRUN_TIMEOUT : arguments[1];

  return (0, _asyncbox.retry)(retries, getAutomationTraceTemplatePathWithoutRetry, timeout);
});

function getMaxIOSSDKWithoutRetry() {
  var timeout = arguments.length <= 0 || arguments[0] === undefined ? XCRUN_TIMEOUT : arguments[0];

  var version, args, _ref2, stdout, sdkVersion, match;

  return _regeneratorRuntime.async(function getMaxIOSSDKWithoutRetry$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(getVersion(false, DEFAULT_NUMBER_OF_RETRIES, timeout));

      case 2:
        version = context$1$0.sent;

        if (!(version[0] === '4')) {
          context$1$0.next = 5;
          break;
        }

        return context$1$0.abrupt('return', '6.1');

      case 5:
        args = ['--sdk', 'iphonesimulator', '--show-sdk-version'];
        context$1$0.next = 8;
        return _regeneratorRuntime.awrap(runXcrunCommand(args, timeout));

      case 8:
        _ref2 = context$1$0.sent;
        stdout = _ref2.stdout;
        sdkVersion = stdout.trim();
        match = /\d.\d/.exec(stdout);

        if (match) {
          context$1$0.next = 14;
          break;
        }

        throw new Error('xcrun returned a non-numeric iOS SDK version: \'' + sdkVersion + '\'');

      case 14:
        return context$1$0.abrupt('return', sdkVersion);

      case 15:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

var getMaxIOSSDK = _lodash2['default'].memoize(function () {
  var retries = arguments.length <= 0 || arguments[0] === undefined ? DEFAULT_NUMBER_OF_RETRIES : arguments[0];
  var timeout = arguments.length <= 1 || arguments[1] === undefined ? XCRUN_TIMEOUT : arguments[1];

  return (0, _asyncbox.retry)(retries, getMaxIOSSDKWithoutRetry, timeout);
});

function getConnectedDevices() {
  var timeout = arguments.length <= 0 || arguments[0] === undefined ? XCRUN_TIMEOUT : arguments[0];

  var cmd, args, _ref3, stdout, plistContent, devicesFound, entriesToSearch, currentEntry, deviceInfo;

  return _regeneratorRuntime.async(function getConnectedDevices$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        cmd = '/usr/sbin/system_profiler';
        args = ['-xml', 'SPUSBDataType'];
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)(cmd, args, { timeout: timeout }));

      case 4:
        _ref3 = context$1$0.sent;
        stdout = _ref3.stdout;
        plistContent = (0, _plist.parse)(stdout);
        devicesFound = [];
        entriesToSearch = [plistContent[0]];

        while (entriesToSearch.length > 0) {
          currentEntry = entriesToSearch.pop();

          if (currentEntry instanceof Array) {
            entriesToSearch = entriesToSearch.concat(currentEntry);
          } else if (currentEntry._name && currentEntry._name.substring(0, 4) === "iPad" || currentEntry._name && currentEntry._name.substring(0, 6) === "iPhone") {
            deviceInfo = {
              name: currentEntry._name,
              udid: currentEntry.serial_num,
              productId: currentEntry.product_id,
              deviceVersion: currentEntry.bcd_device
            };

            devicesFound.push(deviceInfo);
          } else if (currentEntry._items) {
            entriesToSearch = entriesToSearch.concat(currentEntry._items);
          }
        }
        return context$1$0.abrupt('return', devicesFound);

      case 11:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

function getInstrumentsPathWithoutRetry() {
  var timeout = arguments.length <= 0 || arguments[0] === undefined ? XCRUN_TIMEOUT : arguments[0];

  var args, _ref4, stdout, instrumentsPath;

  return _regeneratorRuntime.async(function getInstrumentsPathWithoutRetry$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        args = ['-find', 'instruments'];
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(runXcrunCommand(args, timeout));

      case 3:
        _ref4 = context$1$0.sent;
        stdout = _ref4.stdout;

        if (!stdout) {
          stdout = "";
        }

        instrumentsPath = stdout.trim();

        if (instrumentsPath) {
          context$1$0.next = 9;
          break;
        }

        throw new Error('Could not find path to instruments binary using \'xcrun ' + args.join(' ') + '\'');

      case 9:
        return context$1$0.abrupt('return', instrumentsPath);

      case 10:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

var getInstrumentsPath = _lodash2['default'].memoize(function () {
  var retries = arguments.length <= 0 || arguments[0] === undefined ? DEFAULT_NUMBER_OF_RETRIES : arguments[0];
  var timeout = arguments.length <= 1 || arguments[1] === undefined ? XCRUN_TIMEOUT : arguments[1];

  return (0, _asyncbox.retry)(retries, getInstrumentsPathWithoutRetry, timeout);
});

function clearInternalCache() {

  // memoized functions
  var memoized = [getPath, getVersionMemoized, getAutomationTraceTemplatePath, getMaxIOSSDK, getInstrumentsPath];

  memoized.forEach(function (f) {
    if (f.cache) {
      f.cache = new _lodash2['default'].memoize.Cache();
    }
  });
}

exports['default'] = { getPath: getPath, getVersion: getVersion, getAutomationTraceTemplatePath: getAutomationTraceTemplatePath, getMaxIOSSDK: getMaxIOSSDK,
  getAutomationTraceTemplatePathWithoutRetry: getAutomationTraceTemplatePathWithoutRetry, getMaxIOSSDKWithoutRetry: getMaxIOSSDKWithoutRetry,
  getConnectedDevices: getConnectedDevices, clearInternalCache: clearInternalCache, getInstrumentsPath: getInstrumentsPath,
  getCommandLineToolsVersion: getCommandLineToolsVersion };
module.exports = exports['default'];
//  Xcode < 5.x

// xcode-select allows users to override its settings with the DEVELOPER_DIR env var,
// so check that first

// We should only get here is we failed to capture xcode-select's stdout and our
// other checks failed. Either Apple has moved the symlink to a new location or the user
// is not using the default install. 99.999% chance it's the latter, so issue a warning
// should we ever hit the edge case.

// trim and remove trailing slash

// we want to read the CFBundleShortVersionString from Xcode's plist.
// It should be in /[root]/XCode.app/Contents/

// need to use string#match here; previous code used regexp#exec, which does not return null

// match should be an array, either of
//     [ '7.0', '7', '0', undefined, undefined, index: 0, input: '7.0' ]
//     [ '7.0.1', '7', '0', '.1', '1', index: 0, input: '7.0.1' ]

// stdout should have a line like `version: 8.0.0.0.1.1472435881`
// https://regex101.com/r/HV3x4d/1

// for ios 8 and up, the file extension for AutiomationInstrument changed.
// rather than waste time getting the iOSSDKVersion, just get both paths and see which one exists
//# sourceMappingURL=data:application/json;charset=utf8;base64,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OztBQUVwRCxVQUFRLENBQUMsT0FBTyxDQUFDLFVBQUMsQ0FBQyxFQUFLO0FBQ3RCLFFBQUksQ0FBQyxDQUFDLEtBQUssRUFBRTtBQUNYLE9BQUMsQ0FBQyxLQUFLLEdBQUcsSUFBSSxvQkFBRSxPQUFPLENBQUMsS0FBSyxFQUFFLENBQUM7S0FDakM7R0FDRixDQUFDLENBQUM7Q0FDSjs7cUJBRWMsRUFBRSxPQUFPLEVBQVAsT0FBTyxFQUFFLFVBQVUsRUFBVixVQUFVLEVBQUUsOEJBQThCLEVBQTlCLDhCQUE4QixFQUFFLFlBQVksRUFBWixZQUFZO0FBQ3pFLDRDQUEwQyxFQUExQywwQ0FBMEMsRUFBRSx3QkFBd0IsRUFBeEIsd0JBQXdCO0FBQ3BFLHFCQUFtQixFQUFuQixtQkFBbUIsRUFBRSxrQkFBa0IsRUFBbEIsa0JBQWtCLEVBQUUsa0JBQWtCLEVBQWxCLGtCQUFrQjtBQUMzRCw0QkFBMEIsRUFBMUIsMEJBQTBCLEVBQUUiLCJmaWxlIjoibGliL3hjb2RlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXRpbCwgZnMsIHBsaXN0LCBsb2dnZXIgfSBmcm9tICdhcHBpdW0tc3VwcG9ydCc7XG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCB7IHJldHJ5IH0gZnJvbSAnYXN5bmNib3gnO1xuaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IHBhcnNlIGFzIHBhcnNlUGxpc3REYXRhIH0gZnJvbSAncGxpc3QnO1xuaW1wb3J0IHsgZXhlYyB9IGZyb20gJ3RlZW5fcHJvY2Vzcyc7XG5cblxuY29uc3QgZW52ID0gcHJvY2Vzcy5lbnY7XG5cbmNvbnN0IFhDUlVOX1RJTUVPVVQgPSAxNTAwMDtcbmNvbnN0IFhDT0RFX1NVQkRJUiA9IFwiL0NvbnRlbnRzL0RldmVsb3BlclwiO1xuY29uc3QgREVGQVVMVF9OVU1CRVJfT0ZfUkVUUklFUyA9IDM7XG5cbmNvbnN0IGxvZyA9IGxvZ2dlci5nZXRMb2dnZXIoJ1hjb2RlJyk7XG5cblxuZnVuY3Rpb24gaGFzRXhwZWN0ZWRTdWJEaXIgKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGguc3Vic3RyaW5nKHBhdGgubGVuZ3RoIC0gWENPREVfU1VCRElSLmxlbmd0aCkgPT09IFhDT0RFX1NVQkRJUjtcbn1cblxuYXN5bmMgZnVuY3Rpb24gcnVuWGNydW5Db21tYW5kIChhcmdzLCB0aW1lb3V0ID0gWENSVU5fVElNRU9VVCkge1xuICB0cnkge1xuICAgIHJldHVybiBhd2FpdCBleGVjKCd4Y3J1bicsIGFyZ3MsIHt0aW1lb3V0fSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIHRoZSB0cnVlIGVycm9yIGNhbiBiZSBoaWRkZW4gd2l0aGluIHRoZSBzdGRlcnJcbiAgICBpZiAoZXJyLnN0ZGVycikge1xuICAgICAgZXJyLm1lc3NhZ2UgPSBgJHtlcnIubWVzc2FnZX06ICR7ZXJyLnN0ZGVycn1gO1xuICAgIH1cblxuICAgIHRocm93IGVycjtcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBnZXRQYXRoRnJvbVN5bWxpbmsgKGZhaWxNZXNzYWdlKSB7XG4gIC8vIE5vZGUncyBpbnZvY2F0aW9uIG9mIHhjb2RlLXNlbGVjdCBzb21ldGltZXMgZmxha2VzIGFuZCByZXR1cm5zIGFuIGVtcHR5IHN0cmluZy5cbiAgLy8gTm90IGNsZWFyIHdoeS4gQXMgYSB3b3JrYXJvdW5kLCBBcHBpdW0gY2FuIHJlbGlhYmx5IGRlZHVjZSB0aGUgdmVyc2lvbiBpbiB1c2UgYnkgY2hlY2tpbmdcbiAgLy8gdGhlIGxvY2F0aW9ucyB4Y29kZS1zZWxlY3QgdXNlcyB0byBzdG9yZSB0aGUgc2VsZWN0ZWQgdmVyc2lvbidzIHBhdGguIFRoaXMgc2hvdWxkIGJlIDEwMCVcbiAgLy8gcmVsaWFibGUgc28gbG9uZyBhcyB0aGUgbGluayBsb2NhdGlvbnMgcmVtYWluIHRoZSBzYW1lLiBIb3dldmVyLCBzaW5jZSB3ZSdyZSByZWx5aW5nIG9uXG4gIC8vIGhhcmRjb2RlZCBwYXRocywgdGhpcyBhcHByb2FjaCB3aWxsIGJyZWFrIHRoZSBuZXh0IHRpbWUgQXBwbGUgY2hhbmdlcyB0aGUgc3ltbGluayBsb2NhdGlvbi5cbiAgbG9nLndhcm4oYEZpbmRpbmcgWGNvZGVQYXRoIGJ5IHN5bWxpbmsgYmVjYXVzZSAke2ZhaWxNZXNzYWdlfWApO1xuXG4gIGNvbnN0IHN5bWxpbmtQYXRoID0gXCIvdmFyL2RiL3hjb2RlX3NlbGVjdF9saW5rXCI7XG4gIGNvbnN0IGxlZ2FjeVN5bWxpbmtQYXRoID0gXCIvdXNyL3NoYXJlL3hjb2RlLXNlbGVjdC94Y29kZV9kaXJfbGlua1wiOyAvLyAgWGNvZGUgPCA1LnhcbiAgbGV0IHhjb2RlUGF0aCA9IG51bGw7XG5cbiAgLy8geGNvZGUtc2VsZWN0IGFsbG93cyB1c2VycyB0byBvdmVycmlkZSBpdHMgc2V0dGluZ3Mgd2l0aCB0aGUgREVWRUxPUEVSX0RJUiBlbnYgdmFyLFxuICAvLyBzbyBjaGVjayB0aGF0IGZpcnN0XG4gIGlmICh1dGlsLmhhc0NvbnRlbnQoZW52LkRFVkVMT1BFUl9ESVIpKSB7XG4gICAgY29uc3QgY3VzdG9tUGF0aCA9IGhhc0V4cGVjdGVkU3ViRGlyKGVudi5ERVZFTE9QRVJfRElSKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudi5ERVZFTE9QRVJfRElSICA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudi5ERVZFTE9QRVJfRElSICsgWENPREVfU1VCRElSO1xuXG4gICAgaWYgKGF3YWl0IGZzLmV4aXN0cyhjdXN0b21QYXRoKSkge1xuICAgICAgeGNvZGVQYXRoID0gY3VzdG9tUGF0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IG1lc2cgPSBgQ291bGQgbm90IGZpbmQgcGF0aCB0byBYY29kZSwgZW52aXJvbm1lbnQgdmFyaWFibGUgYCArXG4gICAgICAgICAgICAgICAgIGBERVZFTE9QRVJfRElSIHNldCB0bzogJHtlbnYuREVWRUxPUEVSX0RJUn0gYCArXG4gICAgICAgICAgICAgICAgIGBidXQgbm8gWGNvZGUgZm91bmRgO1xuICAgICAgbG9nLndhcm4obWVzZyk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzZyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGF3YWl0IGZzLmV4aXN0cyhzeW1saW5rUGF0aCkpIHtcbiAgICB4Y29kZVBhdGggPSBhd2FpdCBmcy5yZWFkbGluayhzeW1saW5rUGF0aCk7XG4gIH0gZWxzZSBpZiAoYXdhaXQgZnMuZXhpc3RzKGxlZ2FjeVN5bWxpbmtQYXRoKSkge1xuICAgIHhjb2RlUGF0aCA9IGF3YWl0IGZzLnJlYWRsaW5rKGxlZ2FjeVN5bWxpbmtQYXRoKTtcbiAgfVxuXG4gIGlmICh4Y29kZVBhdGgpIHtcbiAgICByZXR1cm4geGNvZGVQYXRoLnJlcGxhY2UobmV3IFJlZ0V4cChcIi8kXCIpLCBcIlwiKS50cmltKCk7XG4gIH1cblxuICAvLyBXZSBzaG91bGQgb25seSBnZXQgaGVyZSBpcyB3ZSBmYWlsZWQgdG8gY2FwdHVyZSB4Y29kZS1zZWxlY3QncyBzdGRvdXQgYW5kIG91clxuICAvLyBvdGhlciBjaGVja3MgZmFpbGVkLiBFaXRoZXIgQXBwbGUgaGFzIG1vdmVkIHRoZSBzeW1saW5rIHRvIGEgbmV3IGxvY2F0aW9uIG9yIHRoZSB1c2VyXG4gIC8vIGlzIG5vdCB1c2luZyB0aGUgZGVmYXVsdCBpbnN0YWxsLiA5OS45OTklIGNoYW5jZSBpdCdzIHRoZSBsYXR0ZXIsIHNvIGlzc3VlIGEgd2FybmluZ1xuICAvLyBzaG91bGQgd2UgZXZlciBoaXQgdGhlIGVkZ2UgY2FzZS5cbiAgbGV0IG1zZyA9IGBDb3VsZCBub3QgZmluZCBwYXRoIHRvIFhjb2RlIGJ5IHN5bWxpbmtzIGxvY2F0ZWQgaW4gJHtzeW1saW5rUGF0aH0sIG9yICR7bGVnYWN5U3ltbGlua1BhdGh9YDtcbiAgbG9nLndhcm4obXNnKTtcbiAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGdldFBhdGhGcm9tWGNvZGVTZWxlY3QgKHRpbWVvdXQgPSBYQ1JVTl9USU1FT1VUKSB7XG4gIGxldCB7c3Rkb3V0fSA9IGF3YWl0IGV4ZWMoJ3hjb2RlLXNlbGVjdCcsIFsnLS1wcmludC1wYXRoJ10sIHt0aW1lb3V0fSk7XG5cbiAgLy8gdHJpbSBhbmQgcmVtb3ZlIHRyYWlsaW5nIHNsYXNoXG4gIGNvbnN0IHhjb2RlRm9sZGVyUGF0aCA9IHN0ZG91dC5yZXBsYWNlKC9cXC8kLywgJycpLnRyaW0oKTtcblxuICBpZiAoIXV0aWwuaGFzQ29udGVudCh4Y29kZUZvbGRlclBhdGgpKSB7XG4gICAgbG9nLmVycm9yQW5kVGhyb3coJ3hjb2RlLXNlbGVjdCByZXR1cm5lZCBhbiBlbXB0eSBzdHJpbmcnKTtcbiAgfVxuXG4gIGlmIChhd2FpdCBmcy5leGlzdHMoeGNvZGVGb2xkZXJQYXRoKSkge1xuICAgIHJldHVybiB4Y29kZUZvbGRlclBhdGg7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgbXNnID0gYHhjb2RlLXNlbGVjdCBjb3VsZCBub3QgZmluZCB4Y29kZS4gUGF0aCAnJHt4Y29kZUZvbGRlclBhdGh9JyBkb2VzIG5vdCBleGlzdC5gO1xuICAgIGxvZy5lcnJvckFuZFRocm93KG1zZyk7XG4gIH1cbn1cblxuY29uc3QgZ2V0UGF0aCA9IF8ubWVtb2l6ZShmdW5jdGlvbiAodGltZW91dCA9IFhDUlVOX1RJTUVPVVQpIHtcbiAgLy8gZmlyc3Qgd2UgdHJ5IHVzaW5nIHhjb2RlLXNlbGVjdCB0byBmaW5kIHRoZSBwYXRoXG4gIC8vIHRoZW4gd2UgdHJ5IHVzaW5nIHRoZSBzeW1saW5rcyB0aGF0IEFwcGxlIGhhcyBieSBkZWZhdWx0XG4gIHJldHVybiBnZXRQYXRoRnJvbVhjb2RlU2VsZWN0KHRpbWVvdXQpLmNhdGNoKGdldFBhdGhGcm9tU3ltbGluayk7XG59KTtcblxuXG5cbmFzeW5jIGZ1bmN0aW9uIGdldFZlcnNpb25XaXRob3V0UmV0cnkgKHRpbWVvdXQgPSBYQ1JVTl9USU1FT1VUKSB7XG4gIGxldCB4Y29kZVBhdGggPSBhd2FpdCBnZXRQYXRoKHRpbWVvdXQpO1xuXG4gIC8vIHdlIHdhbnQgdG8gcmVhZCB0aGUgQ0ZCdW5kbGVTaG9ydFZlcnNpb25TdHJpbmcgZnJvbSBYY29kZSdzIHBsaXN0LlxuICAvLyBJdCBzaG91bGQgYmUgaW4gL1tyb290XS9YQ29kZS5hcHAvQ29udGVudHMvXG4gIGNvbnN0IHBsaXN0UGF0aCA9IHBhdGgucmVzb2x2ZSh4Y29kZVBhdGgsIFwiLi5cIiwgXCJJbmZvLnBsaXN0XCIpO1xuXG4gIGlmICghYXdhaXQgZnMuZXhpc3RzKHBsaXN0UGF0aCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBnZXQgWGNvZGUgdmVyc2lvbi4gJHtwbGlzdFBhdGh9IGRvZXMgbm90IGV4aXN0IG9uIGRpc2suYCk7XG4gIH1cblxuICBsZXQgdmVyc2lvbiA9IGF3YWl0IHBsaXN0LnBhcnNlUGxpc3RGaWxlKHBsaXN0UGF0aCk7XG4gIHZlcnNpb24gPSB2ZXJzaW9uLkNGQnVuZGxlU2hvcnRWZXJzaW9uU3RyaW5nO1xuXG4gIGxldCB2ZXJzaW9uUGF0dGVybiA9IC9cXGRcXC5cXGRcXC4qXFxkKi87XG4gIC8vIG5lZWQgdG8gdXNlIHN0cmluZyNtYXRjaCBoZXJlOyBwcmV2aW91cyBjb2RlIHVzZWQgcmVnZXhwI2V4ZWMsIHdoaWNoIGRvZXMgbm90IHJldHVybiBudWxsXG4gIGxldCBtYXRjaCA9IHZlcnNpb24ubWF0Y2godmVyc2lvblBhdHRlcm4pO1xuICBpZiAobWF0Y2ggPT09IG51bGwgfHwgIXV0aWwuaGFzQ29udGVudChtYXRjaFswXSkpIHtcbiAgICBsb2cuZXJyb3JBbmRUaHJvdyhgQ291bGQgbm90IHBhcnNlIFhjb2RlIHZlcnNpb24uIHhjb2RlYnVpbGQgb3V0cHV0IHdhczogJHt2ZXJzaW9ufWApO1xuICB9XG5cbiAgcmV0dXJuIG1hdGNoWzBdO1xufVxuXG5jb25zdCBnZXRWZXJzaW9uTWVtb2l6ZWQgPSBfLm1lbW9pemUoXG4gIGZ1bmN0aW9uIChyZXRyaWVzID0gREVGQVVMVF9OVU1CRVJfT0ZfUkVUUklFUywgdGltZW91dCA9IFhDUlVOX1RJTUVPVVQpIHtcbiAgICByZXR1cm4gcmV0cnkocmV0cmllcywgZ2V0VmVyc2lvbldpdGhvdXRSZXRyeSwgdGltZW91dCk7XG4gIH1cbik7XG5cbmFzeW5jIGZ1bmN0aW9uIGdldFZlcnNpb24gKHBhcnNlID0gZmFsc2UsIHJldHJpZXMgPSBERUZBVUxUX05VTUJFUl9PRl9SRVRSSUVTLCB0aW1lb3V0ID0gWENSVU5fVElNRU9VVCkge1xuICBsZXQgdmVyc2lvbiA9IGF3YWl0IGdldFZlcnNpb25NZW1vaXplZChyZXRyaWVzLCB0aW1lb3V0KTtcbiAgaWYgKCFwYXJzZSkge1xuICAgIHJldHVybiB2ZXJzaW9uO1xuICB9XG4gIGxldCBtYXRjaCA9IC9eKFxcZCspXFwuKFxcZCspKFxcLihcXGQrKSk/JC8uZXhlYyh2ZXJzaW9uKTtcbiAgLy8gbWF0Y2ggc2hvdWxkIGJlIGFuIGFycmF5LCBlaXRoZXIgb2ZcbiAgLy8gICAgIFsgJzcuMCcsICc3JywgJzAnLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgaW5kZXg6IDAsIGlucHV0OiAnNy4wJyBdXG4gIC8vICAgICBbICc3LjAuMScsICc3JywgJzAnLCAnLjEnLCAnMScsIGluZGV4OiAwLCBpbnB1dDogJzcuMC4xJyBdXG4gIHJldHVybiB7XG4gICAgdmVyc2lvblN0cmluZzogdmVyc2lvbixcbiAgICB2ZXJzaW9uRmxvYXQ6IHBhcnNlRmxvYXQoYCR7bWF0Y2hbMV19LiR7bWF0Y2hbMl19YCksXG4gICAgbWFqb3I6IHBhcnNlSW50KG1hdGNoWzFdLCAxMCksXG4gICAgbWlub3I6IHBhcnNlSW50KG1hdGNoWzJdLCAxMCksXG4gICAgcGF0Y2g6IG1hdGNoWzRdID8gcGFyc2VJbnQobWF0Y2hbNF0sIDEwKSA6IHVuZGVmaW5lZFxuICB9O1xufVxuXG5hc3luYyBmdW5jdGlvbiBnZXRDb21tYW5kTGluZVRvb2xzVmVyc2lvbiAoKSB7XG4gIGxldCBzdGRvdXQ7XG4gIHRyeSB7XG4gICAgc3Rkb3V0ID0gKGF3YWl0IGV4ZWMoJ3BrZ3V0aWwnLCBbYC0tcGtnLWluZm89Y29tLmFwcGxlLnBrZy5DTFRvb2xzX0V4ZWN1dGFibGVzYF0pKS5zdGRvdXQ7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRyeSB7XG4gICAgICBzdGRvdXQgPSAoYXdhaXQgZXhlYygncGtndXRpbCcsIFtgLS1wa2ctaW5mbz1jb20uYXBwbGUucGtnLkRldmVsb3BlclRvb2xzQ0xJYF0pKS5zdGRvdXQ7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBzdGRvdXQgPSAnJztcbiAgICB9XG4gIH1cblxuICAvLyBzdGRvdXQgc2hvdWxkIGhhdmUgYSBsaW5lIGxpa2UgYHZlcnNpb246IDguMC4wLjAuMS4xNDcyNDM1ODgxYFxuICBsZXQgbWF0Y2ggPSAvXnZlcnNpb246ICguKykkL20uZXhlYyhzdGRvdXQpOyAvLyBodHRwczovL3JlZ2V4MTAxLmNvbS9yL0hWM3g0ZC8xXG4gIHJldHVybiBtYXRjaCA/IG1hdGNoWzFdIDogdW5kZWZpbmVkO1xufVxuXG5hc3luYyBmdW5jdGlvbiBnZXRBdXRvbWF0aW9uVHJhY2VUZW1wbGF0ZVBhdGhXaXRob3V0UmV0cnkgKHRpbWVvdXQgPSBYQ1JVTl9USU1FT1VUKSB7XG4gIGNvbnN0IHhjb2RlUGF0aCA9IGF3YWl0IGdldFBhdGgodGltZW91dCk7XG5cbiAgLy8gZm9yIGlvcyA4IGFuZCB1cCwgdGhlIGZpbGUgZXh0ZW5zaW9uIGZvciBBdXRpb21hdGlvbkluc3RydW1lbnQgY2hhbmdlZC5cbiAgLy8gcmF0aGVyIHRoYW4gd2FzdGUgdGltZSBnZXR0aW5nIHRoZSBpT1NTREtWZXJzaW9uLCBqdXN0IGdldCBib3RoIHBhdGhzIGFuZCBzZWUgd2hpY2ggb25lIGV4aXN0c1xuICBjb25zdCBleHRlbnNpb25zID0gWyd4cnBsdWdpbicsICdidW5kbGUnXTtcbiAgY29uc3QgcGF0aFByZWZpeCA9IHBhdGgucmVzb2x2ZSh4Y29kZVBhdGgsIFwiLi4vQXBwbGljYXRpb25zL0luc3RydW1lbnRzLmFwcC9Db250ZW50cy9QbHVnSW5zXCIpO1xuICBjb25zdCBwYXRoU3VmZml4ID0gXCJDb250ZW50cy9SZXNvdXJjZXMvQXV0b21hdGlvbi50cmFjZXRlbXBsYXRlXCI7XG4gIGxldCBhdXRvbWF0aW9uVHJhY2VUZW1wbGF0ZVBhdGhzID0gW1xuICAgIHBhdGgucmVzb2x2ZShwYXRoUHJlZml4LCBgQXV0b21hdGlvbkluc3RydW1lbnQuJHtleHRlbnNpb25zWzBdfWAsIHBhdGhTdWZmaXgpLFxuICAgIHBhdGgucmVzb2x2ZShwYXRoUHJlZml4LCBgQXV0b21hdGlvbkluc3RydW1lbnQuJHtleHRlbnNpb25zWzFdfWAsIHBhdGhTdWZmaXgpXG4gIF07XG5cbiAgaWYgKGF3YWl0IGZzLmV4aXN0cyhhdXRvbWF0aW9uVHJhY2VUZW1wbGF0ZVBhdGhzWzBdKSkge1xuICAgIHJldHVybiBhdXRvbWF0aW9uVHJhY2VUZW1wbGF0ZVBhdGhzWzBdO1xuICB9XG5cbiAgaWYgKGF3YWl0IGZzLmV4aXN0cyhhdXRvbWF0aW9uVHJhY2VUZW1wbGF0ZVBhdGhzWzFdKSkge1xuICAgIHJldHVybiBhdXRvbWF0aW9uVHJhY2VUZW1wbGF0ZVBhdGhzWzFdO1xuICB9XG5cbiAgY29uc3QgbXNnID0gXCJDb3VsZCBub3QgZmluZCBBdXRvbWF0aW9uLnRyYWNldGVtcGxhdGUgaW4gYW55IG9mIHRoZSBmb2xsb3dpbmdcIiArXG4gICAgICAgICAgICAgIGBsb2NhdGlvbnMgJHthdXRvbWF0aW9uVHJhY2VUZW1wbGF0ZVBhdGhzLnRvU3RyaW5nKCl9YDtcbiAgbG9nLmVycm9yKG1zZyk7XG4gIHRocm93IG5ldyBFcnJvcihtc2cpO1xuXG59XG5cbmNvbnN0IGdldEF1dG9tYXRpb25UcmFjZVRlbXBsYXRlUGF0aCA9IF8ubWVtb2l6ZShcbiAgZnVuY3Rpb24gKHJldHJpZXMgPSBERUZBVUxUX05VTUJFUl9PRl9SRVRSSUVTLCB0aW1lb3V0ID0gWENSVU5fVElNRU9VVCkge1xuICAgIHJldHVybiByZXRyeShyZXRyaWVzLCBnZXRBdXRvbWF0aW9uVHJhY2VUZW1wbGF0ZVBhdGhXaXRob3V0UmV0cnksIHRpbWVvdXQpO1xuICB9XG4pO1xuXG5hc3luYyBmdW5jdGlvbiBnZXRNYXhJT1NTREtXaXRob3V0UmV0cnkgKHRpbWVvdXQgPSBYQ1JVTl9USU1FT1VUKSB7XG4gIGNvbnN0IHZlcnNpb24gPSBhd2FpdCBnZXRWZXJzaW9uKGZhbHNlLCBERUZBVUxUX05VTUJFUl9PRl9SRVRSSUVTLCB0aW1lb3V0KTtcbiAgaWYgKHZlcnNpb25bMF0gPT09ICc0Jykge1xuICAgIHJldHVybiAnNi4xJztcbiAgfVxuXG4gIGNvbnN0IGFyZ3MgPSBbJy0tc2RrJywgICdpcGhvbmVzaW11bGF0b3InLCAgJy0tc2hvdy1zZGstdmVyc2lvbiddO1xuICBjb25zdCB7c3Rkb3V0fSA9IGF3YWl0IHJ1blhjcnVuQ29tbWFuZChhcmdzLCB0aW1lb3V0KTtcblxuICBjb25zdCBzZGtWZXJzaW9uID0gc3Rkb3V0LnRyaW0oKTtcbiAgY29uc3QgbWF0Y2ggPSAvXFxkLlxcZC8uZXhlYyhzdGRvdXQpO1xuXG4gIGlmICghbWF0Y2gpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYHhjcnVuIHJldHVybmVkIGEgbm9uLW51bWVyaWMgaU9TIFNESyB2ZXJzaW9uOiAnJHtzZGtWZXJzaW9ufSdgKTtcbiAgfVxuXG4gIHJldHVybiBzZGtWZXJzaW9uO1xufVxuXG5jb25zdCBnZXRNYXhJT1NTREsgPSBfLm1lbW9pemUoXG4gIGZ1bmN0aW9uIChyZXRyaWVzID0gREVGQVVMVF9OVU1CRVJfT0ZfUkVUUklFUywgdGltZW91dCA9IFhDUlVOX1RJTUVPVVQpIHtcbiAgICByZXR1cm4gcmV0cnkocmV0cmllcywgZ2V0TWF4SU9TU0RLV2l0aG91dFJldHJ5LCB0aW1lb3V0KTtcbiAgfVxuKTtcblxuYXN5bmMgZnVuY3Rpb24gZ2V0Q29ubmVjdGVkRGV2aWNlcyAodGltZW91dCA9IFhDUlVOX1RJTUVPVVQpIHtcbiAgY29uc3QgY21kID0gJy91c3Ivc2Jpbi9zeXN0ZW1fcHJvZmlsZXInO1xuICBjb25zdCBhcmdzID0gWycteG1sJywgJ1NQVVNCRGF0YVR5cGUnXTtcbiAgbGV0IHtzdGRvdXR9ID0gYXdhaXQgZXhlYyhjbWQsIGFyZ3MsIHt0aW1lb3V0fSk7XG4gIGxldCBwbGlzdENvbnRlbnQgPSBwYXJzZVBsaXN0RGF0YShzdGRvdXQpO1xuXG4gIGxldCBkZXZpY2VzRm91bmQgPSBbXTtcbiAgbGV0IGVudHJpZXNUb1NlYXJjaCA9IFtwbGlzdENvbnRlbnRbMF1dO1xuICB3aGlsZSAoZW50cmllc1RvU2VhcmNoLmxlbmd0aCA+IDApIHtcbiAgICBsZXQgY3VycmVudEVudHJ5ID0gZW50cmllc1RvU2VhcmNoLnBvcCgpO1xuICAgIGlmIChjdXJyZW50RW50cnkgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgZW50cmllc1RvU2VhcmNoID0gZW50cmllc1RvU2VhcmNoLmNvbmNhdChjdXJyZW50RW50cnkpO1xuICAgIH0gZWxzZSBpZiAoKGN1cnJlbnRFbnRyeS5fbmFtZSAmJlxuICAgICAgICAgICAgICAgIGN1cnJlbnRFbnRyeS5fbmFtZS5zdWJzdHJpbmcoMCwgNCkgPT09IFwiaVBhZFwiKSB8fFxuICAgICAgICAgICAgICAgKGN1cnJlbnRFbnRyeS5fbmFtZSAmJlxuICAgICAgICAgICAgICAgIGN1cnJlbnRFbnRyeS5fbmFtZS5zdWJzdHJpbmcoMCwgNikgPT09IFwiaVBob25lXCIpKSB7XG4gICAgICBsZXQgZGV2aWNlSW5mbyA9IHtcbiAgICAgICAgbmFtZTogY3VycmVudEVudHJ5Ll9uYW1lLFxuICAgICAgICB1ZGlkOiBjdXJyZW50RW50cnkuc2VyaWFsX251bSxcbiAgICAgICAgcHJvZHVjdElkOiBjdXJyZW50RW50cnkucHJvZHVjdF9pZCxcbiAgICAgICAgZGV2aWNlVmVyc2lvbjogY3VycmVudEVudHJ5LmJjZF9kZXZpY2VcbiAgICAgIH07XG4gICAgICBkZXZpY2VzRm91bmQucHVzaChkZXZpY2VJbmZvKTtcbiAgICB9IGVsc2UgaWYgKGN1cnJlbnRFbnRyeS5faXRlbXMpIHtcbiAgICAgIGVudHJpZXNUb1NlYXJjaCA9IGVudHJpZXNUb1NlYXJjaC5jb25jYXQoY3VycmVudEVudHJ5Ll9pdGVtcyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBkZXZpY2VzRm91bmQ7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGdldEluc3RydW1lbnRzUGF0aFdpdGhvdXRSZXRyeSAodGltZW91dCA9IFhDUlVOX1RJTUVPVVQpIHtcbiAgY29uc3QgYXJncyA9IFsnLWZpbmQnLCAnaW5zdHJ1bWVudHMnXTtcbiAgbGV0IHtzdGRvdXR9ID0gYXdhaXQgcnVuWGNydW5Db21tYW5kKGFyZ3MsIHRpbWVvdXQpO1xuXG4gIGlmICghc3Rkb3V0KSB7XG4gICAgc3Rkb3V0ID0gXCJcIjtcbiAgfVxuXG4gIGxldCBpbnN0cnVtZW50c1BhdGggPSBzdGRvdXQudHJpbSgpO1xuXG4gIGlmICghaW5zdHJ1bWVudHNQYXRoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZmluZCBwYXRoIHRvIGluc3RydW1lbnRzIGJpbmFyeSB1c2luZyAneGNydW4gJHthcmdzLmpvaW4oJyAnKX0nYCk7XG4gIH1cblxuICByZXR1cm4gaW5zdHJ1bWVudHNQYXRoO1xufVxuXG5jb25zdCBnZXRJbnN0cnVtZW50c1BhdGggPSBfLm1lbW9pemUoXG4gIGZ1bmN0aW9uIChyZXRyaWVzID0gREVGQVVMVF9OVU1CRVJfT0ZfUkVUUklFUywgdGltZW91dCA9IFhDUlVOX1RJTUVPVVQpIHtcbiAgICByZXR1cm4gcmV0cnkocmV0cmllcywgZ2V0SW5zdHJ1bWVudHNQYXRoV2l0aG91dFJldHJ5LCB0aW1lb3V0KTtcbiAgfVxuKTtcblxuZnVuY3Rpb24gY2xlYXJJbnRlcm5hbENhY2hlICgpIHtcblxuICAvLyBtZW1vaXplZCBmdW5jdGlvbnNcbiAgY29uc3QgbWVtb2l6ZWQgPSBbZ2V0UGF0aCwgZ2V0VmVyc2lvbk1lbW9pemVkLCBnZXRBdXRvbWF0aW9uVHJhY2VUZW1wbGF0ZVBhdGgsXG4gICAgICAgICAgICAgICAgICAgIGdldE1heElPU1NESywgZ2V0SW5zdHJ1bWVudHNQYXRoXTtcblxuICBtZW1vaXplZC5mb3JFYWNoKChmKSA9PiB7XG4gICAgaWYgKGYuY2FjaGUpIHtcbiAgICAgIGYuY2FjaGUgPSBuZXcgXy5tZW1vaXplLkNhY2hlKCk7XG4gICAgfVxuICB9KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgeyBnZXRQYXRoLCBnZXRWZXJzaW9uLCBnZXRBdXRvbWF0aW9uVHJhY2VUZW1wbGF0ZVBhdGgsIGdldE1heElPU1NESyxcbiAgICAgICAgIGdldEF1dG9tYXRpb25UcmFjZVRlbXBsYXRlUGF0aFdpdGhvdXRSZXRyeSwgZ2V0TWF4SU9TU0RLV2l0aG91dFJldHJ5LFxuICAgICAgICAgZ2V0Q29ubmVjdGVkRGV2aWNlcywgY2xlYXJJbnRlcm5hbENhY2hlLCBnZXRJbnN0cnVtZW50c1BhdGgsXG4gICAgICAgICBnZXRDb21tYW5kTGluZVRvb2xzVmVyc2lvbiB9O1xuIl0sInNvdXJjZVJvb3QiOiIuLi8uLiJ9
