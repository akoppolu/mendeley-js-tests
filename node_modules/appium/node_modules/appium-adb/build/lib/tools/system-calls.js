'use strict';

var _toConsumableArray = require('babel-runtime/helpers/to-consumable-array')['default'];

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _getIterator = require('babel-runtime/core-js/get-iterator')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _loggerJs = require('../logger.js');

var _loggerJs2 = _interopRequireDefault(_loggerJs);

var _bluebird = require('bluebird');

var _bluebird2 = _interopRequireDefault(_bluebird);

var _appiumSupport = require('appium-support');

var _helpers = require('../helpers');

var _teen_process = require('teen_process');

var _asyncbox = require('asyncbox');

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var systemCallMethods = {};

var DEFAULT_ADB_EXEC_TIMEOUT = 20000; // in milliseconds
var DEFAULT_ADB_REBOOT_RETRIES = 90;

systemCallMethods.getSdkBinaryPath = function callee$0$0(binaryName) {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _loggerJs2['default'].info('Checking whether ' + binaryName + ' is present');

        if (!this.sdkRoot) {
          context$1$0.next = 5;
          break;
        }

        return context$1$0.abrupt('return', this.getBinaryFromSdkRoot(binaryName));

      case 5:
        _loggerJs2['default'].warn('The ANDROID_HOME environment variable is not set to the Android SDK ' + 'root directory path. ANDROID_HOME is required for compatibility ' + ('with SDK 23+. Checking along PATH for ' + binaryName + '.'));
        context$1$0.next = 8;
        return _regeneratorRuntime.awrap(this.getBinaryFromPath(binaryName));

      case 8:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 9:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

systemCallMethods.getCommandForOS = function () {
  var cmd = "which";
  if (_appiumSupport.system.isWindows()) {
    cmd = "where";
  }
  return cmd;
};

systemCallMethods.getBinaryNameForOS = function (binaryName) {
  if (_appiumSupport.system.isWindows()) {
    if (binaryName === "android") {
      binaryName += ".bat";
    } else {
      if (binaryName.indexOf(".exe", binaryName.length - 4) === -1) {
        binaryName += ".exe";
      }
    }
  }
  return binaryName;
};

systemCallMethods.getBinaryFromSdkRoot = function callee$0$0(binaryName) {
  var binaryLoc, binaryLocs, buildToolDirs, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, versionDir, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, loc;

  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        binaryLoc = null;

        binaryName = this.getBinaryNameForOS(binaryName);
        binaryLocs = [_path2['default'].resolve(this.sdkRoot, "platform-tools", binaryName), _path2['default'].resolve(this.sdkRoot, "emulator", binaryName), _path2['default'].resolve(this.sdkRoot, "tools", binaryName), _path2['default'].resolve(this.sdkRoot, "tools", "bin", binaryName)];
        buildToolDirs = [];
        context$1$0.next = 6;
        return _regeneratorRuntime.awrap((0, _helpers.getDirectories)(_path2['default'].resolve(this.sdkRoot, "build-tools")));

      case 6:
        buildToolDirs = context$1$0.sent;
        _iteratorNormalCompletion = true;
        _didIteratorError = false;
        _iteratorError = undefined;
        context$1$0.prev = 10;

        for (_iterator = _getIterator(buildToolDirs); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          versionDir = _step.value;

          binaryLocs.push(_path2['default'].resolve(this.sdkRoot, "build-tools", versionDir, binaryName));
        }
        context$1$0.next = 18;
        break;

      case 14:
        context$1$0.prev = 14;
        context$1$0.t0 = context$1$0['catch'](10);
        _didIteratorError = true;
        _iteratorError = context$1$0.t0;

      case 18:
        context$1$0.prev = 18;
        context$1$0.prev = 19;

        if (!_iteratorNormalCompletion && _iterator['return']) {
          _iterator['return']();
        }

      case 21:
        context$1$0.prev = 21;

        if (!_didIteratorError) {
          context$1$0.next = 24;
          break;
        }

        throw _iteratorError;

      case 24:
        return context$1$0.finish(21);

      case 25:
        return context$1$0.finish(18);

      case 26:
        _iteratorNormalCompletion2 = true;
        _didIteratorError2 = false;
        _iteratorError2 = undefined;
        context$1$0.prev = 29;
        _iterator2 = _getIterator(binaryLocs);

      case 31:
        if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
          context$1$0.next = 41;
          break;
        }

        loc = _step2.value;
        context$1$0.next = 35;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.exists(loc));

      case 35:
        if (!context$1$0.sent) {
          context$1$0.next = 38;
          break;
        }

        binaryLoc = loc;
        return context$1$0.abrupt('break', 41);

      case 38:
        _iteratorNormalCompletion2 = true;
        context$1$0.next = 31;
        break;

      case 41:
        context$1$0.next = 47;
        break;

      case 43:
        context$1$0.prev = 43;
        context$1$0.t1 = context$1$0['catch'](29);
        _didIteratorError2 = true;
        _iteratorError2 = context$1$0.t1;

      case 47:
        context$1$0.prev = 47;
        context$1$0.prev = 48;

        if (!_iteratorNormalCompletion2 && _iterator2['return']) {
          _iterator2['return']();
        }

      case 50:
        context$1$0.prev = 50;

        if (!_didIteratorError2) {
          context$1$0.next = 53;
          break;
        }

        throw _iteratorError2;

      case 53:
        return context$1$0.finish(50);

      case 54:
        return context$1$0.finish(47);

      case 55:
        if (!(binaryLoc === null)) {
          context$1$0.next = 57;
          break;
        }

        throw new Error('Could not find ' + binaryName + ' in ' + binaryLocs + ', ' + ('or supported build-tools under ' + this.sdkRoot + ' ') + 'do you have the Android SDK installed at this location?');

      case 57:
        binaryLoc = binaryLoc.trim();
        _loggerJs2['default'].info('Using ' + binaryName + ' from ' + binaryLoc);
        return context$1$0.abrupt('return', binaryLoc);

      case 60:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[10, 14, 18, 26], [19,, 21, 25], [29, 43, 47, 55], [48,, 50, 54]]);
};

systemCallMethods.getBinaryFromPath = function callee$0$0(binaryName) {
  var binaryLoc, cmd, _ref, stdout;

  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        binaryLoc = null;
        cmd = this.getCommandForOS();
        context$1$0.prev = 2;
        context$1$0.next = 5;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)(cmd, [binaryName]));

      case 5:
        _ref = context$1$0.sent;
        stdout = _ref.stdout;

        _loggerJs2['default'].info('Using ' + binaryName + ' from ' + stdout);
        // TODO write a test for binaries with spaces.
        binaryLoc = stdout.trim();
        return context$1$0.abrupt('return', binaryLoc);

      case 12:
        context$1$0.prev = 12;
        context$1$0.t0 = context$1$0['catch'](2);

        _loggerJs2['default'].errorAndThrow('Could not find ' + binaryName + ' Please set the ANDROID_HOME ' + 'environment variable with the Android SDK root directory path.');

      case 15:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[2, 12]]);
};

systemCallMethods.getConnectedDevices = function callee$0$0() {
  var _ref2, stdout, startingIndex, devices, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, line, lineInfo;

  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _loggerJs2['default'].debug("Getting connected devices...");
        context$1$0.prev = 1;
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)(this.executable.path, ['devices']));

      case 4:
        _ref2 = context$1$0.sent;
        stdout = _ref2.stdout;
        startingIndex = stdout.indexOf("List of devices");

        if (!(startingIndex === -1)) {
          context$1$0.next = 11;
          break;
        }

        throw new Error('Unexpected output while trying to get devices. output was: ' + stdout);

      case 11:
        // slicing ouput we care about.
        stdout = stdout.slice(startingIndex);
        devices = [];
        _iteratorNormalCompletion3 = true;
        _didIteratorError3 = false;
        _iteratorError3 = undefined;
        context$1$0.prev = 16;

        for (_iterator3 = _getIterator(stdout.split("\n")); !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          line = _step3.value;

          if (line.trim() !== "" && line.indexOf("List of devices") === -1 && line.indexOf("adb server") === -1 && line.indexOf("* daemon") === -1 && line.indexOf("offline") === -1) {
            lineInfo = line.split("\t");

            // state is either "device" or "offline", afaict
            devices.push({ udid: lineInfo[0], state: lineInfo[1] });
          }
        }
        context$1$0.next = 24;
        break;

      case 20:
        context$1$0.prev = 20;
        context$1$0.t0 = context$1$0['catch'](16);
        _didIteratorError3 = true;
        _iteratorError3 = context$1$0.t0;

      case 24:
        context$1$0.prev = 24;
        context$1$0.prev = 25;

        if (!_iteratorNormalCompletion3 && _iterator3['return']) {
          _iterator3['return']();
        }

      case 27:
        context$1$0.prev = 27;

        if (!_didIteratorError3) {
          context$1$0.next = 30;
          break;
        }

        throw _iteratorError3;

      case 30:
        return context$1$0.finish(27);

      case 31:
        return context$1$0.finish(24);

      case 32:
        _loggerJs2['default'].debug(devices.length + ' device(s) connected');
        return context$1$0.abrupt('return', devices);

      case 34:
        context$1$0.next = 39;
        break;

      case 36:
        context$1$0.prev = 36;
        context$1$0.t1 = context$1$0['catch'](1);

        _loggerJs2['default'].errorAndThrow('Error while getting connected devices. Original error: ' + context$1$0.t1.message);

      case 39:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[1, 36], [16, 20, 24, 32], [25,, 27, 31]]);
};

systemCallMethods.getDevicesWithRetry = function callee$0$0() {
  var timeoutMs = arguments.length <= 0 || arguments[0] === undefined ? 20000 : arguments[0];
  var start, getDevices;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    var _this = this;

    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        start = Date.now();

        _loggerJs2['default'].debug("Trying to find a connected android device");

        getDevices = function getDevices() {
          var devices;
          return _regeneratorRuntime.async(function getDevices$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                if (!(Date.now() - start > timeoutMs)) {
                  context$2$0.next = 2;
                  break;
                }

                throw new Error("Could not find a connected Android device.");

              case 2:
                context$2$0.prev = 2;
                context$2$0.next = 5;
                return _regeneratorRuntime.awrap(this.getConnectedDevices());

              case 5:
                devices = context$2$0.sent;

                if (!(devices.length < 1)) {
                  context$2$0.next = 15;
                  break;
                }

                _loggerJs2['default'].debug("Could not find devices, restarting adb server...");
                context$2$0.next = 10;
                return _regeneratorRuntime.awrap(this.restartAdb());

              case 10:
                context$2$0.next = 12;
                return _regeneratorRuntime.awrap((0, _asyncbox.sleep)(200));

              case 12:
                context$2$0.next = 14;
                return _regeneratorRuntime.awrap(getDevices());

              case 14:
                return context$2$0.abrupt('return', context$2$0.sent);

              case 15:
                return context$2$0.abrupt('return', devices);

              case 18:
                context$2$0.prev = 18;
                context$2$0.t0 = context$2$0['catch'](2);

                _loggerJs2['default'].debug("Could not find devices, restarting adb server...");
                context$2$0.next = 23;
                return _regeneratorRuntime.awrap(this.restartAdb());

              case 23:
                context$2$0.next = 25;
                return _regeneratorRuntime.awrap((0, _asyncbox.sleep)(200));

              case 25:
                context$2$0.next = 27;
                return _regeneratorRuntime.awrap(getDevices());

              case 27:
                return context$2$0.abrupt('return', context$2$0.sent);

              case 28:
              case 'end':
                return context$2$0.stop();
            }
          }, null, _this, [[2, 18]]);
        };

        context$1$0.next = 5;
        return _regeneratorRuntime.awrap(getDevices());

      case 5:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 6:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

systemCallMethods.restartAdb = function callee$0$0() {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        if (!this.suppressKillServer) {
          context$1$0.next = 3;
          break;
        }

        _loggerJs2['default'].debug('Not restarting abd since \'suppressKillServer\' is on');
        return context$1$0.abrupt('return');

      case 3:

        _loggerJs2['default'].debug('Restarting adb');
        context$1$0.prev = 4;
        context$1$0.next = 7;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)(this.executable.path, ['kill-server']));

      case 7:
        context$1$0.next = 12;
        break;

      case 9:
        context$1$0.prev = 9;
        context$1$0.t0 = context$1$0['catch'](4);

        _loggerJs2['default'].error("Error killing ADB server, going to see if it's online anyway");

      case 12:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[4, 9]]);
};

systemCallMethods.resetTelnetAuthToken = _lodash2['default'].memoize(function callee$0$0() {
  var homeFolderPath, dstPath;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        homeFolderPath = process.env[process.platform === 'win32' ? 'USERPROFILE' : 'HOME'];

        if (homeFolderPath) {
          context$1$0.next = 4;
          break;
        }

        _loggerJs2['default'].warn('Cannot find the path to user home folder. Ignoring resetting of emulator\'s telnet authentication token');
        return context$1$0.abrupt('return', false);

      case 4:
        dstPath = _path2['default'].resolve(homeFolderPath, '.emulator_console_auth_token');

        _loggerJs2['default'].debug('Overriding ' + dstPath + ' with an empty string to avoid telnet authentication for emulator commands');
        context$1$0.prev = 6;
        context$1$0.next = 9;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.writeFile(dstPath, ''));

      case 9:
        context$1$0.next = 15;
        break;

      case 11:
        context$1$0.prev = 11;
        context$1$0.t0 = context$1$0['catch'](6);

        _loggerJs2['default'].warn('Error ' + context$1$0.t0.message + ' while resetting the content of ' + dstPath + '. Ignoring resetting of emulator\'s telnet authentication token');
        return context$1$0.abrupt('return', false);

      case 15:
        return context$1$0.abrupt('return', true);

      case 16:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[6, 11]]);
});

systemCallMethods.adbExecEmu = function callee$0$0(cmd) {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.verifyEmulatorConnected());

      case 2:
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(this.resetTelnetAuthToken());

      case 4:
        context$1$0.next = 6;
        return _regeneratorRuntime.awrap(this.adbExec(['emu'].concat(_toConsumableArray(cmd))));

      case 6:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

systemCallMethods.adbExec = function callee$0$0(cmd) {
  var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
  var execFunc;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    var _this2 = this;

    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        if (cmd) {
          context$1$0.next = 2;
          break;
        }

        throw new Error("You need to pass in a command to adbExec()");

      case 2:
        // setting default timeout for each command to prevent infinite wait.
        opts.timeout = opts.timeout || DEFAULT_ADB_EXEC_TIMEOUT;

        execFunc = function execFunc() {
          var linkerWarningRe, args, _ref3, stdout, protocolFaultError, deviceNotFoundError;

          return _regeneratorRuntime.async(function execFunc$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                linkerWarningRe = /^WARNING: linker.+$/m;
                context$2$0.prev = 1;

                if (!(cmd instanceof Array)) {
                  cmd = [cmd];
                }
                args = this.executable.defaultArgs.concat(cmd);

                _loggerJs2['default'].debug('Running \'' + this.executable.path + '\' with args: ' + ('' + JSON.stringify(args)));
                context$2$0.next = 7;
                return _regeneratorRuntime.awrap((0, _teen_process.exec)(this.executable.path, args, opts));

              case 7:
                _ref3 = context$2$0.sent;
                stdout = _ref3.stdout;

                // sometimes ADB prints out weird stdout warnings that we don't want
                // to include in any of the response data, so let's strip it out
                stdout = stdout.replace(linkerWarningRe, '').trim();
                return context$2$0.abrupt('return', stdout);

              case 13:
                context$2$0.prev = 13;
                context$2$0.t0 = context$2$0['catch'](1);
                protocolFaultError = new RegExp("protocol fault \\(no status\\)", "i").test(context$2$0.t0);
                deviceNotFoundError = new RegExp("error: device ('.+' )?not found", "i").test(context$2$0.t0);

                if (!(protocolFaultError || deviceNotFoundError)) {
                  context$2$0.next = 23;
                  break;
                }

                _loggerJs2['default'].info('Error sending command, reconnecting device and retrying: ' + cmd);
                context$2$0.next = 21;
                return _regeneratorRuntime.awrap((0, _asyncbox.sleep)(1000));

              case 21:
                context$2$0.next = 23;
                return _regeneratorRuntime.awrap(this.getDevicesWithRetry());

              case 23:
                if (!context$2$0.t0.stdout) {
                  context$2$0.next = 27;
                  break;
                }

                stdout = context$2$0.t0.stdout;

                stdout = stdout.replace(linkerWarningRe, '').trim();
                return context$2$0.abrupt('return', stdout);

              case 27:
                throw new Error('Error executing adbExec. Original error: \'' + context$2$0.t0.message + '\'; ' + ('Stderr: \'' + (context$2$0.t0.stderr || '').trim() + '\'; Code: \'' + context$2$0.t0.code + '\''));

              case 28:
              case 'end':
                return context$2$0.stop();
            }
          }, null, _this2, [[1, 13]]);
        };

        context$1$0.next = 6;
        return _regeneratorRuntime.awrap((0, _asyncbox.retry)(2, execFunc));

      case 6:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 7:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

systemCallMethods.shell = function callee$0$0(cmd) {
  var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
  var execCmd;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.isDeviceConnected());

      case 2:
        if (context$1$0.sent) {
          context$1$0.next = 4;
          break;
        }

        throw new Error('No device connected, cannot run adb shell command \'' + cmd.join(' ') + '\'');

      case 4:
        execCmd = ['shell'];

        if (cmd instanceof Array) {
          execCmd = execCmd.concat(cmd);
        } else {
          execCmd.push(cmd);
        }
        context$1$0.next = 8;
        return _regeneratorRuntime.awrap(this.adbExec(execCmd, opts));

      case 8:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 9:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

systemCallMethods.createSubProcess = function () {
  var args = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];

  // add the default arguments
  args = this.executable.defaultArgs.concat(args);
  _loggerJs2['default'].debug('Creating ADB subprocess with args: ' + JSON.stringify(args));
  return new _teen_process.SubProcess(this.getAdbPath(), args);
};

// TODO can probably deprecate this now that the logic is just to read
// this.adbPort
systemCallMethods.getAdbServerPort = function () {
  return this.adbPort;
};

systemCallMethods.getEmulatorPort = function callee$0$0() {
  var devices, port;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _loggerJs2['default'].debug("Getting running emulator port");

        if (!(this.emulatorPort !== null)) {
          context$1$0.next = 3;
          break;
        }

        return context$1$0.abrupt('return', this.emulatorPort);

      case 3:
        context$1$0.prev = 3;
        context$1$0.next = 6;
        return _regeneratorRuntime.awrap(this.getConnectedDevices());

      case 6:
        devices = context$1$0.sent;
        port = this.getPortFromEmulatorString(devices[0].udid);

        if (!port) {
          context$1$0.next = 12;
          break;
        }

        return context$1$0.abrupt('return', port);

      case 12:
        throw new Error('Emulator port not found');

      case 13:
        context$1$0.next = 18;
        break;

      case 15:
        context$1$0.prev = 15;
        context$1$0.t0 = context$1$0['catch'](3);

        _loggerJs2['default'].errorAndThrow('No devices connected. Original error: ' + context$1$0.t0.message);

      case 18:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[3, 15]]);
};

systemCallMethods.getPortFromEmulatorString = function (emStr) {
  var portPattern = /emulator-(\d+)/;
  if (portPattern.test(emStr)) {
    return parseInt(portPattern.exec(emStr)[1], 10);
  }
  return false;
};

systemCallMethods.getConnectedEmulators = function callee$0$0() {
  var devices, emulators, _iteratorNormalCompletion4, _didIteratorError4, _iteratorError4, _iterator4, _step4, device, port;

  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.prev = 0;

        _loggerJs2['default'].debug("Getting connected emulators");
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(this.getConnectedDevices());

      case 4:
        devices = context$1$0.sent;
        emulators = [];
        _iteratorNormalCompletion4 = true;
        _didIteratorError4 = false;
        _iteratorError4 = undefined;
        context$1$0.prev = 9;

        for (_iterator4 = _getIterator(devices); !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          device = _step4.value;
          port = this.getPortFromEmulatorString(device.udid);

          if (port) {
            device.port = port;
            emulators.push(device);
          }
        }
        context$1$0.next = 17;
        break;

      case 13:
        context$1$0.prev = 13;
        context$1$0.t0 = context$1$0['catch'](9);
        _didIteratorError4 = true;
        _iteratorError4 = context$1$0.t0;

      case 17:
        context$1$0.prev = 17;
        context$1$0.prev = 18;

        if (!_iteratorNormalCompletion4 && _iterator4['return']) {
          _iterator4['return']();
        }

      case 20:
        context$1$0.prev = 20;

        if (!_didIteratorError4) {
          context$1$0.next = 23;
          break;
        }

        throw _iteratorError4;

      case 23:
        return context$1$0.finish(20);

      case 24:
        return context$1$0.finish(17);

      case 25:
        _loggerJs2['default'].debug(emulators.length + ' emulator(s) connected');
        return context$1$0.abrupt('return', emulators);

      case 29:
        context$1$0.prev = 29;
        context$1$0.t1 = context$1$0['catch'](0);

        _loggerJs2['default'].errorAndThrow('Error getting emulators. Original error: ' + context$1$0.t1.message);

      case 32:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[0, 29], [9, 13, 17, 25], [18,, 20, 24]]);
};

systemCallMethods.setEmulatorPort = function (emPort) {
  this.emulatorPort = emPort;
};

systemCallMethods.setDeviceId = function (deviceId) {
  _loggerJs2['default'].debug('Setting device id to ' + deviceId);
  this.curDeviceId = deviceId;
  var argsHasDevice = this.executable.defaultArgs.indexOf('-s');
  if (argsHasDevice !== -1) {
    // remove the old device id from the arguments
    this.executable.defaultArgs.splice(argsHasDevice, 2);
  }
  this.executable.defaultArgs.push('-s', deviceId);
};

systemCallMethods.setDevice = function (deviceObj) {
  var deviceId = deviceObj.udid;
  var emPort = this.getPortFromEmulatorString(deviceId);
  this.setEmulatorPort(emPort);
  this.setDeviceId(deviceId);
};

systemCallMethods.getRunningAVD = function callee$0$0(avdName) {
  var emulators, _iteratorNormalCompletion5, _didIteratorError5, _iteratorError5, _iterator5, _step5, emulator, runningAVDName;

  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.prev = 0;

        _loggerJs2['default'].debug('Trying to find ' + avdName + ' emulator');
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(this.getConnectedEmulators());

      case 4:
        emulators = context$1$0.sent;
        _iteratorNormalCompletion5 = true;
        _didIteratorError5 = false;
        _iteratorError5 = undefined;
        context$1$0.prev = 8;
        _iterator5 = _getIterator(emulators);

      case 10:
        if (_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done) {
          context$1$0.next = 23;
          break;
        }

        emulator = _step5.value;

        this.setEmulatorPort(emulator.port);
        context$1$0.next = 15;
        return _regeneratorRuntime.awrap(this.sendTelnetCommand("avd name"));

      case 15:
        runningAVDName = context$1$0.sent;

        if (!(avdName === runningAVDName)) {
          context$1$0.next = 20;
          break;
        }

        _loggerJs2['default'].debug('Found emulator ' + avdName + ' in port ' + emulator.port);
        this.setDeviceId(emulator.udid);
        return context$1$0.abrupt('return', emulator);

      case 20:
        _iteratorNormalCompletion5 = true;
        context$1$0.next = 10;
        break;

      case 23:
        context$1$0.next = 29;
        break;

      case 25:
        context$1$0.prev = 25;
        context$1$0.t0 = context$1$0['catch'](8);
        _didIteratorError5 = true;
        _iteratorError5 = context$1$0.t0;

      case 29:
        context$1$0.prev = 29;
        context$1$0.prev = 30;

        if (!_iteratorNormalCompletion5 && _iterator5['return']) {
          _iterator5['return']();
        }

      case 32:
        context$1$0.prev = 32;

        if (!_didIteratorError5) {
          context$1$0.next = 35;
          break;
        }

        throw _iteratorError5;

      case 35:
        return context$1$0.finish(32);

      case 36:
        return context$1$0.finish(29);

      case 37:
        _loggerJs2['default'].debug('Emulator ' + avdName + ' not running');
        return context$1$0.abrupt('return', null);

      case 41:
        context$1$0.prev = 41;
        context$1$0.t1 = context$1$0['catch'](0);

        _loggerJs2['default'].errorAndThrow('Error getting AVD. Original error: ' + context$1$0.t1.message);

      case 44:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[0, 41], [8, 25, 29, 37], [30,, 32, 36]]);
};

systemCallMethods.getRunningAVDWithRetry = function callee$0$0(avdName) {
  var timeoutMs = arguments.length <= 1 || arguments[1] === undefined ? 20000 : arguments[1];
  var start, runningAVD;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.prev = 0;
        start = Date.now();

      case 2:
        if (!(Date.now() - start < timeoutMs)) {
          context$1$0.next = 18;
          break;
        }

        context$1$0.prev = 3;
        context$1$0.next = 6;
        return _regeneratorRuntime.awrap(this.getRunningAVD(avdName.replace('@', '')));

      case 6:
        runningAVD = context$1$0.sent;

        if (!runningAVD) {
          context$1$0.next = 9;
          break;
        }

        return context$1$0.abrupt('return', runningAVD);

      case 9:
        context$1$0.next = 14;
        break;

      case 11:
        context$1$0.prev = 11;
        context$1$0.t0 = context$1$0['catch'](3);

        // Do nothing.
        _loggerJs2['default'].info('Couldn\'t get running AVD, will retry. Error was: ' + context$1$0.t0.message);

      case 14:
        context$1$0.next = 16;
        return _regeneratorRuntime.awrap((0, _asyncbox.sleep)(200));

      case 16:
        context$1$0.next = 2;
        break;

      case 18:
        _loggerJs2['default'].errorAndThrow('Could not find ' + avdName + ' emulator.');
        context$1$0.next = 24;
        break;

      case 21:
        context$1$0.prev = 21;
        context$1$0.t1 = context$1$0['catch'](0);

        _loggerJs2['default'].errorAndThrow('Error getting AVD with retry. Original error: ' + context$1$0.t1.message);

      case 24:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[0, 21], [3, 11]]);
};

systemCallMethods.killAllEmulators = function callee$0$0() {
  var cmd, args;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        cmd = undefined, args = undefined;

        if (_appiumSupport.system.isWindows()) {
          cmd = 'TASKKILL';
          args = ['TASKKILL', '/IM', 'emulator.exe'];
        } else {
          cmd = '/usr/bin/killall';
          args = ['-m', 'emulator*'];
        }
        context$1$0.prev = 2;
        context$1$0.next = 5;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)(cmd, args));

      case 5:
        context$1$0.next = 10;
        break;

      case 7:
        context$1$0.prev = 7;
        context$1$0.t0 = context$1$0['catch'](2);

        _loggerJs2['default'].errorAndThrow('Error killing emulators. Original error: ' + context$1$0.t0.message);

      case 10:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[2, 7]]);
};

systemCallMethods.killEmulator = function callee$0$0(avdName) {
  var device;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _loggerJs2['default'].debug('killing avd \'' + avdName + '\'');
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(this.getRunningAVD(avdName));

      case 3:
        device = context$1$0.sent;

        if (!device) {
          context$1$0.next = 10;
          break;
        }

        context$1$0.next = 7;
        return _regeneratorRuntime.awrap(this.adbExec(['emu', 'kill']));

      case 7:
        _loggerJs2['default'].info('successfully killed emulator \'' + avdName + '\'');
        context$1$0.next = 11;
        break;

      case 10:
        _loggerJs2['default'].info('no avd with name \'' + avdName + '\' running. skipping kill step.');

      case 11:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

systemCallMethods.launchAVD = function callee$0$0(avdName, avdArgs, language, country) {
  var avdLaunchTimeout = arguments.length <= 4 || arguments[4] === undefined ? 60000 : arguments[4];
  var avdReadyTimeout = arguments.length <= 5 || arguments[5] === undefined ? 60000 : arguments[5];
  var retryTimes = arguments.length <= 6 || arguments[6] === undefined ? 1 : arguments[6];
  var emulatorBinaryPath, launchArgs, locale, proc;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _loggerJs2['default'].debug('Launching Emulator with AVD ' + avdName + ', launchTimeout' + (avdLaunchTimeout + ' ms and readyTimeout ' + avdReadyTimeout + ' ms'));
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(this.getSdkBinaryPath("emulator"));

      case 3:
        emulatorBinaryPath = context$1$0.sent;

        if (avdName[0] === "@") {
          avdName = avdName.substr(1);
        }
        context$1$0.next = 7;
        return _regeneratorRuntime.awrap(this.checkAvdExist(avdName));

      case 7:
        launchArgs = ["-avd", avdName];

        if (typeof language === "string") {
          _loggerJs2['default'].debug('Setting Android Device Language to ' + language);
          launchArgs.push("-prop", 'persist.sys.language=' + language.toLowerCase());
        }
        if (typeof country === "string") {
          _loggerJs2['default'].debug('Setting Android Device Country to ' + country);
          launchArgs.push("-prop", 'persist.sys.country=' + country.toUpperCase());
        }
        locale = undefined;

        if (typeof language === "string" && typeof country === "string") {
          locale = language.toLowerCase() + "-" + country.toUpperCase();
        } else if (typeof language === "string") {
          locale = language.toLowerCase();
        } else if (typeof country === "string") {
          locale = country;
        }
        if (typeof locale === "string") {
          _loggerJs2['default'].debug('Setting Android Device Locale to ' + locale);
          launchArgs.push("-prop", 'persist.sys.locale=' + locale);
        }
        if (typeof avdArgs === "string") {
          avdArgs = avdArgs.split(" ");
          launchArgs = launchArgs.concat(avdArgs);
        }
        _loggerJs2['default'].debug('Running \'' + emulatorBinaryPath + '\' with args: ' + JSON.stringify(launchArgs));
        proc = new _teen_process.SubProcess(emulatorBinaryPath, launchArgs);
        context$1$0.next = 18;
        return _regeneratorRuntime.awrap(proc.start(0));

      case 18:
        proc.on('output', function (stdout, stderr) {
          _loggerJs2['default'].info('[AVD OUTPUT] ' + (stdout || stderr));
        });
        context$1$0.next = 21;
        return _regeneratorRuntime.awrap((0, _asyncbox.retry)(retryTimes, this.getRunningAVDWithRetry.bind(this), avdName, avdLaunchTimeout));

      case 21:
        context$1$0.next = 23;
        return _regeneratorRuntime.awrap(this.waitForEmulatorReady(avdReadyTimeout));

      case 23:
        return context$1$0.abrupt('return', proc);

      case 24:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

systemCallMethods.getAdbVersion = _lodash2['default'].memoize(function callee$0$0() {
  var adbVersion, parts;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.prev = 0;
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(this.adbExec('version'));

      case 3:
        adbVersion = context$1$0.sent.replace(/Android\sDebug\sBridge\sversion\s([\d\.]*)[\s\w\-]*/, "$1");
        parts = adbVersion.split('.');
        return context$1$0.abrupt('return', {
          versionString: adbVersion,
          versionFloat: parseFloat(adbVersion),
          major: parseInt(parts[0], 10),
          minor: parseInt(parts[1], 10),
          patch: parts[2] ? parseInt(parts[2], 10) : undefined
        });

      case 8:
        context$1$0.prev = 8;
        context$1$0.t0 = context$1$0['catch'](0);

        _loggerJs2['default'].errorAndThrow('Error getting adb version. Original error: \'' + context$1$0.t0.message + '\'; ' + ('Stderr: \'' + (context$1$0.t0.stderr || '').trim() + '\'; Code: \'' + context$1$0.t0.code + '\''));

      case 11:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[0, 8]]);
});

systemCallMethods.checkAvdExist = function callee$0$0(avdName) {
  var cmd, result, unknownOptionError, sdkVersion, binaryName, existings;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        cmd = undefined, result = undefined;
        context$1$0.prev = 1;
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(this.getSdkBinaryPath('emulator'));

      case 4:
        cmd = context$1$0.sent;
        context$1$0.next = 7;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)(cmd, ['-list-avds']));

      case 7:
        result = context$1$0.sent;
        context$1$0.next = 25;
        break;

      case 10:
        context$1$0.prev = 10;
        context$1$0.t0 = context$1$0['catch'](1);
        unknownOptionError = new RegExp("unknown option: -list-avds", "i").test(context$1$0.t0.stderr);

        if (!unknownOptionError) {
          _loggerJs2['default'].errorAndThrow('Error executing checkAvdExist. Original error: \'' + context$1$0.t0.message + '\'; ' + ('Stderr: \'' + (context$1$0.t0.stderr || '').trim() + '\'; Code: \'' + context$1$0.t0.code + '\''));
        }
        context$1$0.next = 16;
        return _regeneratorRuntime.awrap((0, _helpers.getSdkToolsVersion)());

      case 16:
        sdkVersion = context$1$0.sent;
        binaryName = 'android';

        if (sdkVersion) {
          if (sdkVersion.major >= 25) {
            binaryName = 'avdmanager';
          }
        } else {
          _loggerJs2['default'].warn('Defaulting binary name to \'' + binaryName + '\', because SDK version cannot be parsed');
        }
        // If -list-avds option is not available, use android command as an alternative
        context$1$0.next = 21;
        return _regeneratorRuntime.awrap(this.getSdkBinaryPath(binaryName));

      case 21:
        cmd = context$1$0.sent;
        context$1$0.next = 24;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)(cmd, ['list', 'avd', '-c']));

      case 24:
        result = context$1$0.sent;

      case 25:
        if (result.stdout.indexOf(avdName) === -1) {
          existings = '(' + result.stdout.trim().replace(/[\n]/g, '), (') + ')';

          _loggerJs2['default'].errorAndThrow('Avd \'' + avdName + '\' is not available. please select your avd name from one of these: \'' + existings + '\'');
        }

      case 26:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[1, 10]]);
};

systemCallMethods.waitForEmulatorReady = function callee$0$0() {
  var timeoutMs = arguments.length <= 0 || arguments[0] === undefined ? 20000 : arguments[0];
  var start, stdout;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        start = Date.now();

        _loggerJs2['default'].debug("Waiting until emulator is ready");

      case 2:
        if (!(Date.now() - start < timeoutMs)) {
          context$1$0.next = 17;
          break;
        }

        context$1$0.prev = 3;
        context$1$0.next = 6;
        return _regeneratorRuntime.awrap(this.shell(["getprop", "init.svc.bootanim"]));

      case 6:
        stdout = context$1$0.sent;

        if (!(stdout.indexOf('stopped') > -1)) {
          context$1$0.next = 9;
          break;
        }

        return context$1$0.abrupt('return');

      case 9:
        context$1$0.next = 13;
        break;

      case 11:
        context$1$0.prev = 11;
        context$1$0.t0 = context$1$0['catch'](3);

      case 13:
        context$1$0.next = 15;
        return _regeneratorRuntime.awrap((0, _asyncbox.sleep)(3000));

      case 15:
        context$1$0.next = 2;
        break;

      case 17:
        _loggerJs2['default'].errorAndThrow('Emulator not ready');

      case 18:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[3, 11]]);
};

systemCallMethods.waitForDevice = function callee$0$0() {
  var appDeviceReadyTimeout = arguments.length <= 0 || arguments[0] === undefined ? 30 : arguments[0];
  var retries, timeout;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    var _this3 = this;

    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        this.appDeviceReadyTimeout = appDeviceReadyTimeout;
        retries = 3;
        timeout = parseInt(this.appDeviceReadyTimeout, 10) / retries * 1000;
        context$1$0.next = 5;
        return _regeneratorRuntime.awrap((0, _asyncbox.retry)(retries, function callee$1$0() {
          return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                context$2$0.prev = 0;
                context$2$0.next = 3;
                return _regeneratorRuntime.awrap(this.adbExec('wait-for-device', { timeout: timeout }));

              case 3:
                context$2$0.next = 5;
                return _regeneratorRuntime.awrap(this.ping());

              case 5:
                context$2$0.next = 14;
                break;

              case 7:
                context$2$0.prev = 7;
                context$2$0.t0 = context$2$0['catch'](0);
                context$2$0.next = 11;
                return _regeneratorRuntime.awrap(this.restartAdb());

              case 11:
                context$2$0.next = 13;
                return _regeneratorRuntime.awrap(this.getConnectedDevices());

              case 13:
                _loggerJs2['default'].errorAndThrow('Error in waiting for device. Original error: \'' + context$2$0.t0.message + '\'. ' + 'Retrying by restarting ADB');

              case 14:
              case 'end':
                return context$2$0.stop();
            }
          }, null, _this3, [[0, 7]]);
        }));

      case 5:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

systemCallMethods.reboot = function callee$0$0() {
  var retries = arguments.length <= 0 || arguments[0] === undefined ? DEFAULT_ADB_REBOOT_RETRIES : arguments[0];
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    var _this4 = this;

    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.prev = 0;
        context$1$0.prev = 1;
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(this.shell(['stop']));

      case 4:
        context$1$0.next = 15;
        break;

      case 6:
        context$1$0.prev = 6;
        context$1$0.t0 = context$1$0['catch'](1);

        if (!(context$1$0.t0.message.indexOf('must be root') === -1)) {
          context$1$0.next = 10;
          break;
        }

        throw context$1$0.t0;

      case 10:
        // this device needs adb to be running as root to stop.
        // so try to restart the daemon
        _loggerJs2['default'].debug('Device requires adb to be running as root in order to reboot. Restarting daemon');
        context$1$0.next = 13;
        return _regeneratorRuntime.awrap(this.root());

      case 13:
        context$1$0.next = 15;
        return _regeneratorRuntime.awrap(this.shell(['stop']));

      case 15:
        context$1$0.next = 17;
        return _regeneratorRuntime.awrap(_bluebird2['default'].delay(2000));

      case 17:
        context$1$0.next = 19;
        return _regeneratorRuntime.awrap(this.setDeviceProperty('sys.boot_completed', 0));

      case 19:
        context$1$0.next = 21;
        return _regeneratorRuntime.awrap(this.shell(['start']));

      case 21:
        context$1$0.next = 23;
        return _regeneratorRuntime.awrap((0, _asyncbox.retryInterval)(retries, 1000, function callee$1$0() {
          var booted, msg;
          return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                context$2$0.next = 2;
                return _regeneratorRuntime.awrap(this.getDeviceProperty('sys.boot_completed'));

              case 2:
                booted = context$2$0.sent;

                if (!(booted === '1')) {
                  context$2$0.next = 7;
                  break;
                }

                return context$2$0.abrupt('return');

              case 7:
                msg = 'Waiting for reboot. This takes time';

                _loggerJs2['default'].debug(msg);
                throw new Error(msg);

              case 10:
              case 'end':
                return context$2$0.stop();
            }
          }, null, _this4);
        }));

      case 23:
        context$1$0.prev = 23;

        this.unroot();
        return context$1$0.finish(23);

      case 26:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[0,, 23, 26], [1, 6]]);
};

systemCallMethods.root = function callee$0$0() {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.prev = 0;
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)(this.executable.path, ['root']));

      case 3:
        return context$1$0.abrupt('return', true);

      case 6:
        context$1$0.prev = 6;
        context$1$0.t0 = context$1$0['catch'](0);

        _loggerJs2['default'].warn('Unable to root adb daemon: \'' + context$1$0.t0.message + '\'. Continuing');
        return context$1$0.abrupt('return', false);

      case 10:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[0, 6]]);
};

systemCallMethods.unroot = function callee$0$0() {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.prev = 0;
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)(this.executable.path, ['unroot']));

      case 3:
        return context$1$0.abrupt('return', true);

      case 6:
        context$1$0.prev = 6;
        context$1$0.t0 = context$1$0['catch'](0);

        _loggerJs2['default'].warn('Unable to unroot adb daemon: \'' + context$1$0.t0.message + '\'. Continuing');
        return context$1$0.abrupt('return', false);

      case 10:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[0, 6]]);
};

systemCallMethods.fileExists = function callee$0$0(remotePath) {
  var files;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.ls(remotePath));

      case 2:
        files = context$1$0.sent;
        return context$1$0.abrupt('return', files.length > 0);

      case 4:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

systemCallMethods.ls = function callee$0$0(remotePath) {
  var stdout, lines;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.prev = 0;
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(this.shell(['ls', remotePath]));

      case 3:
        stdout = context$1$0.sent;
        lines = stdout.split("\n");
        return context$1$0.abrupt('return', lines.map(function (l) {
          return l.trim();
        }).filter(Boolean).filter(function (l) {
          return l.indexOf("No such file") === -1;
        }));

      case 8:
        context$1$0.prev = 8;
        context$1$0.t0 = context$1$0['catch'](0);

        if (!(context$1$0.t0.message.indexOf('No such file or directory') === -1)) {
          context$1$0.next = 12;
          break;
        }

        throw context$1$0.t0;

      case 12:
        return context$1$0.abrupt('return', []);

      case 13:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[0, 8]]);
};

exports['default'] = systemCallMethods;
module.exports = exports['default'];

// get subpaths for currently installed build tool directories

// expecting adb devices to return output as
// List of devices attached
// emulator-5554	device

// cool down

// cool down

// The methods is used to remove telnet auth token
// See http://tools.android.com/recent/emulator2516releasenotes for more details

// cool down

// do nothing
// let the emu finish stopping;

// we don't want the stack trace, so no log.errorAndThrow
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi90b29scy9zeXN0ZW0tY2FsbHMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7b0JBQWlCLE1BQU07Ozs7d0JBQ1AsY0FBYzs7Ozt3QkFDaEIsVUFBVTs7Ozs2QkFDRyxnQkFBZ0I7O3VCQUNRLFlBQVk7OzRCQUM5QixjQUFjOzt3QkFDSCxVQUFVOztzQkFDeEMsUUFBUTs7OztBQUd0QixJQUFJLGlCQUFpQixHQUFHLEVBQUUsQ0FBQzs7QUFFM0IsSUFBTSx3QkFBd0IsR0FBRyxLQUFLLENBQUM7QUFDdkMsSUFBTSwwQkFBMEIsR0FBRyxFQUFFLENBQUM7O0FBRXRDLGlCQUFpQixDQUFDLGdCQUFnQixHQUFHLG9CQUFnQixVQUFVOzs7O0FBQzdELDhCQUFJLElBQUksdUJBQXFCLFVBQVUsaUJBQWMsQ0FBQzs7YUFDbEQsSUFBSSxDQUFDLE9BQU87Ozs7OzRDQUNQLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxVQUFVLENBQUM7OztBQUU1Qyw4QkFBSSxJQUFJLENBQUMsMklBQ2tFLCtDQUN6QixVQUFVLE9BQUcsQ0FBQyxDQUFDOzt5Q0FDcEQsSUFBSSxDQUFDLGlCQUFpQixDQUFDLFVBQVUsQ0FBQzs7Ozs7Ozs7OztDQUdsRCxDQUFDOztBQUVGLGlCQUFpQixDQUFDLGVBQWUsR0FBRyxZQUFZO0FBQzlDLE1BQUksR0FBRyxHQUFHLE9BQU8sQ0FBQztBQUNsQixNQUFJLHNCQUFPLFNBQVMsRUFBRSxFQUFFO0FBQ3RCLE9BQUcsR0FBRyxPQUFPLENBQUM7R0FDZjtBQUNELFNBQU8sR0FBRyxDQUFDO0NBQ1osQ0FBQzs7QUFFRixpQkFBaUIsQ0FBQyxrQkFBa0IsR0FBRyxVQUFVLFVBQVUsRUFBRTtBQUMzRCxNQUFJLHNCQUFPLFNBQVMsRUFBRSxFQUFFO0FBQ3RCLFFBQUksVUFBVSxLQUFLLFNBQVMsRUFBRTtBQUM1QixnQkFBVSxJQUFJLE1BQU0sQ0FBQztLQUN0QixNQUFNO0FBQ0wsVUFBSSxVQUFVLENBQUMsT0FBTyxDQUFD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MkIsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFBOzs7Ozs7Ozs0Q0FHcEQsRUFBRTs7Ozs7OztDQUVaLENBQUM7O3FCQUVhLGlCQUFpQiIsImZpbGUiOiJsaWIvdG9vbHMvc3lzdGVtLWNhbGxzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgbG9nIGZyb20gJy4uL2xvZ2dlci5qcyc7XG5pbXBvcnQgQiBmcm9tICdibHVlYmlyZCc7XG5pbXBvcnQgeyBzeXN0ZW0sIGZzIH0gZnJvbSAnYXBwaXVtLXN1cHBvcnQnO1xuaW1wb3J0IHsgZ2V0RGlyZWN0b3JpZXMsIGdldFNka1Rvb2xzVmVyc2lvbiB9IGZyb20gJy4uL2hlbHBlcnMnO1xuaW1wb3J0IHsgZXhlYywgU3ViUHJvY2VzcyB9IGZyb20gJ3RlZW5fcHJvY2Vzcyc7XG5pbXBvcnQgeyBzbGVlcCwgcmV0cnksIHJldHJ5SW50ZXJ2YWwgfSBmcm9tICdhc3luY2JveCc7XG5pbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xuXG5cbmxldCBzeXN0ZW1DYWxsTWV0aG9kcyA9IHt9O1xuXG5jb25zdCBERUZBVUxUX0FEQl9FWEVDX1RJTUVPVVQgPSAyMDAwMDsgLy8gaW4gbWlsbGlzZWNvbmRzXG5jb25zdCBERUZBVUxUX0FEQl9SRUJPT1RfUkVUUklFUyA9IDkwO1xuXG5zeXN0ZW1DYWxsTWV0aG9kcy5nZXRTZGtCaW5hcnlQYXRoID0gYXN5bmMgZnVuY3Rpb24gKGJpbmFyeU5hbWUpIHtcbiAgbG9nLmluZm8oYENoZWNraW5nIHdoZXRoZXIgJHtiaW5hcnlOYW1lfSBpcyBwcmVzZW50YCk7XG4gIGlmICh0aGlzLnNka1Jvb3QpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRCaW5hcnlGcm9tU2RrUm9vdChiaW5hcnlOYW1lKTtcbiAgfSBlbHNlIHtcbiAgICBsb2cud2FybihgVGhlIEFORFJPSURfSE9NRSBlbnZpcm9ubWVudCB2YXJpYWJsZSBpcyBub3Qgc2V0IHRvIHRoZSBBbmRyb2lkIFNESyBgICtcbiAgICAgICAgICAgICBgcm9vdCBkaXJlY3RvcnkgcGF0aC4gQU5EUk9JRF9IT01FIGlzIHJlcXVpcmVkIGZvciBjb21wYXRpYmlsaXR5IGAgK1xuICAgICAgICAgICAgIGB3aXRoIFNESyAyMysuIENoZWNraW5nIGFsb25nIFBBVEggZm9yICR7YmluYXJ5TmFtZX0uYCk7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0QmluYXJ5RnJvbVBhdGgoYmluYXJ5TmFtZSk7XG5cbiAgfVxufTtcblxuc3lzdGVtQ2FsbE1ldGhvZHMuZ2V0Q29tbWFuZEZvck9TID0gZnVuY3Rpb24gKCkge1xuICBsZXQgY21kID0gXCJ3aGljaFwiO1xuICBpZiAoc3lzdGVtLmlzV2luZG93cygpKSB7XG4gICAgY21kID0gXCJ3aGVyZVwiO1xuICB9XG4gIHJldHVybiBjbWQ7XG59O1xuXG5zeXN0ZW1DYWxsTWV0aG9kcy5nZXRCaW5hcnlOYW1lRm9yT1MgPSBmdW5jdGlvbiAoYmluYXJ5TmFtZSkge1xuICBpZiAoc3lzdGVtLmlzV2luZG93cygpKSB7XG4gICAgaWYgKGJpbmFyeU5hbWUgPT09IFwiYW5kcm9pZFwiKSB7XG4gICAgICBiaW5hcnlOYW1lICs9IFwiLmJhdFwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoYmluYXJ5TmFtZS5pbmRleE9mKFwiLmV4ZVwiLCBiaW5hcnlOYW1lLmxlbmd0aCAtIDQpID09PSAtMSkge1xuICAgICAgICBiaW5hcnlOYW1lICs9IFwiLmV4ZVwiO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gYmluYXJ5TmFtZTtcbn07XG5cbnN5c3RlbUNhbGxNZXRob2RzLmdldEJpbmFyeUZyb21TZGtSb290ID0gYXN5bmMgZnVuY3Rpb24gKGJpbmFyeU5hbWUpIHtcbiAgbGV0IGJpbmFyeUxvYyA9IG51bGw7XG4gIGJpbmFyeU5hbWUgPSB0aGlzLmdldEJpbmFyeU5hbWVGb3JPUyhiaW5hcnlOYW1lKTtcbiAgbGV0IGJpbmFyeUxvY3MgPSBbcGF0aC5yZXNvbHZlKHRoaXMuc2RrUm9vdCwgXCJwbGF0Zm9ybS10b29sc1wiLCBiaW5hcnlOYW1lKSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aC5yZXNvbHZlKHRoaXMuc2RrUm9vdCwgXCJlbXVsYXRvclwiLCBiaW5hcnlOYW1lKSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aC5yZXNvbHZlKHRoaXMuc2RrUm9vdCwgXCJ0b29sc1wiLCBiaW5hcnlOYW1lKSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aC5yZXNvbHZlKHRoaXMuc2RrUm9vdCwgXCJ0b29sc1wiLCBcImJpblwiLCBiaW5hcnlOYW1lKV07XG4gIC8vIGdldCBzdWJwYXRocyBmb3IgY3VycmVudGx5IGluc3RhbGxlZCBidWlsZCB0b29sIGRpcmVjdG9yaWVzXG4gIGxldCBidWlsZFRvb2xEaXJzID0gW107XG4gIGJ1aWxkVG9vbERpcnMgPSBhd2FpdCBnZXREaXJlY3RvcmllcyhwYXRoLnJlc29sdmUodGhpcy5zZGtSb290LCBcImJ1aWxkLXRvb2xzXCIpKTtcbiAgZm9yIChsZXQgdmVyc2lvbkRpciBvZiBidWlsZFRvb2xEaXJzKSB7XG4gICAgYmluYXJ5TG9jcy5wdXNoKHBhdGgucmVzb2x2ZSh0aGlzLnNka1Jvb3QsIFwiYnVpbGQtdG9vbHNcIiwgdmVyc2lvbkRpciwgYmluYXJ5TmFtZSkpO1xuICB9XG4gIGZvciAobGV0IGxvYyBvZiBiaW5hcnlMb2NzKSB7XG4gICAgaWYgKGF3YWl0IGZzLmV4aXN0cyhsb2MpKSB7XG4gICAgICBiaW5hcnlMb2MgPSBsb2M7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgaWYgKGJpbmFyeUxvYyA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGZpbmQgJHtiaW5hcnlOYW1lfSBpbiAke2JpbmFyeUxvY3N9LCBgICtcbiAgICAgICAgICAgICAgICAgICAgYG9yIHN1cHBvcnRlZCBidWlsZC10b29scyB1bmRlciAke3RoaXMuc2RrUm9vdH0gYCArXG4gICAgICAgICAgICAgICAgICAgIGBkbyB5b3UgaGF2ZSB0aGUgQW5kcm9pZCBTREsgaW5zdGFsbGVkIGF0IHRoaXMgbG9jYXRpb24/YCk7XG4gIH1cbiAgYmluYXJ5TG9jID0gYmluYXJ5TG9jLnRyaW0oKTtcbiAgbG9nLmluZm8oYFVzaW5nICR7YmluYXJ5TmFtZX0gZnJvbSAke2JpbmFyeUxvY31gKTtcbiAgcmV0dXJuIGJpbmFyeUxvYztcbn07XG5cbnN5c3RlbUNhbGxNZXRob2RzLmdldEJpbmFyeUZyb21QYXRoID0gYXN5bmMgZnVuY3Rpb24gKGJpbmFyeU5hbWUpIHtcbiAgbGV0IGJpbmFyeUxvYyA9IG51bGw7XG4gIGxldCBjbWQgPSB0aGlzLmdldENvbW1hbmRGb3JPUygpO1xuICB0cnkge1xuICAgIGxldCB7c3Rkb3V0fSA9IGF3YWl0IGV4ZWMoY21kLCBbYmluYXJ5TmFtZV0pO1xuICAgIGxvZy5pbmZvKGBVc2luZyAke2JpbmFyeU5hbWV9IGZyb20gJHtzdGRvdXR9YCk7XG4gICAgLy8gVE9ETyB3cml0ZSBhIHRlc3QgZm9yIGJpbmFyaWVzIHdpdGggc3BhY2VzLlxuICAgIGJpbmFyeUxvYyA9IHN0ZG91dC50cmltKCk7XG4gICAgcmV0dXJuIGJpbmFyeUxvYztcbiAgfSBjYXRjaCAoZSkge1xuICAgIGxvZy5lcnJvckFuZFRocm93KGBDb3VsZCBub3QgZmluZCAke2JpbmFyeU5hbWV9IFBsZWFzZSBzZXQgdGhlIEFORFJPSURfSE9NRSBgICtcbiAgICAgICAgICAgICAgYGVudmlyb25tZW50IHZhcmlhYmxlIHdpdGggdGhlIEFuZHJvaWQgU0RLIHJvb3QgZGlyZWN0b3J5IHBhdGguYCk7XG4gIH1cbn07XG5cbnN5c3RlbUNhbGxNZXRob2RzLmdldENvbm5lY3RlZERldmljZXMgPSBhc3luYyBmdW5jdGlvbiAoKSB7XG4gIGxvZy5kZWJ1ZyhcIkdldHRpbmcgY29ubmVjdGVkIGRldmljZXMuLi5cIik7XG4gIHRyeSB7XG4gICAgbGV0IHtzdGRvdXR9ID0gYXdhaXQgZXhlYyh0aGlzLmV4ZWN1dGFibGUucGF0aCwgWydkZXZpY2VzJ10pO1xuICAgIC8vIGV4cGVjdGluZyBhZGIgZGV2aWNlcyB0byByZXR1cm4gb3V0cHV0IGFzXG4gICAgLy8gTGlzdCBvZiBkZXZpY2VzIGF0dGFjaGVkXG4gICAgLy8gZW11bGF0b3ItNTU1NFx0ZGV2aWNlXG4gICAgbGV0IHN0YXJ0aW5nSW5kZXggPSBzdGRvdXQuaW5kZXhPZihcIkxpc3Qgb2YgZGV2aWNlc1wiKTtcbiAgICBpZiAoc3RhcnRpbmdJbmRleCA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBvdXRwdXQgd2hpbGUgdHJ5aW5nIHRvIGdldCBkZXZpY2VzLiBvdXRwdXQgd2FzOiAke3N0ZG91dH1gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gc2xpY2luZyBvdXB1dCB3ZSBjYXJlIGFib3V0LlxuICAgICAgc3Rkb3V0ID0gc3Rkb3V0LnNsaWNlKHN0YXJ0aW5nSW5kZXgpO1xuICAgICAgbGV0IGRldmljZXMgPSBbXTtcbiAgICAgIGZvciAobGV0IGxpbmUgb2Ygc3Rkb3V0LnNwbGl0KFwiXFxuXCIpKSB7XG4gICAgICAgIGlmIChsaW5lLnRyaW0oKSAhPT0gXCJcIiAmJlxuICAgICAgICAgICAgbGluZS5pbmRleE9mKFwiTGlzdCBvZiBkZXZpY2VzXCIpID09PSAtMSAmJlxuICAgICAgICAgICAgbGluZS5pbmRleE9mKFwiYWRiIHNlcnZlclwiKSA9PT0gLTEgJiZcbiAgICAgICAgICAgIGxpbmUuaW5kZXhPZihcIiogZGFlbW9uXCIpID09PSAtMSAmJlxuICAgICAgICAgICAgbGluZS5pbmRleE9mKFwib2ZmbGluZVwiKSA9PT0gLTEpIHtcbiAgICAgICAgICBsZXQgbGluZUluZm8gPSBsaW5lLnNwbGl0KFwiXFx0XCIpO1xuICAgICAgICAgIC8vIHN0YXRlIGlzIGVpdGhlciBcImRldmljZVwiIG9yIFwib2ZmbGluZVwiLCBhZmFpY3RcbiAgICAgICAgICBkZXZpY2VzLnB1c2goe3VkaWQ6IGxpbmVJbmZvWzBdLCBzdGF0ZTogbGluZUluZm9bMV19KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbG9nLmRlYnVnKGAke2RldmljZXMubGVuZ3RofSBkZXZpY2UocykgY29ubmVjdGVkYCk7XG4gICAgICByZXR1cm4gZGV2aWNlcztcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBsb2cuZXJyb3JBbmRUaHJvdyhgRXJyb3Igd2hpbGUgZ2V0dGluZyBjb25uZWN0ZWQgZGV2aWNlcy4gT3JpZ2luYWwgZXJyb3I6ICR7ZS5tZXNzYWdlfWApO1xuICB9XG59O1xuXG5zeXN0ZW1DYWxsTWV0aG9kcy5nZXREZXZpY2VzV2l0aFJldHJ5ID0gYXN5bmMgZnVuY3Rpb24gKHRpbWVvdXRNcyA9IDIwMDAwKSB7XG4gIGxldCBzdGFydCA9IERhdGUubm93KCk7XG4gIGxvZy5kZWJ1ZyhcIlRyeWluZyB0byBmaW5kIGEgY29ubmVjdGVkIGFuZHJvaWQgZGV2aWNlXCIpO1xuICBsZXQgZ2V0RGV2aWNlcyA9IGFzeW5jICgpID0+IHtcbiAgICBpZiAoKERhdGUubm93KCkgLSBzdGFydCkgPiB0aW1lb3V0TXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBmaW5kIGEgY29ubmVjdGVkIEFuZHJvaWQgZGV2aWNlLlwiKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGxldCBkZXZpY2VzID0gYXdhaXQgdGhpcy5nZXRDb25uZWN0ZWREZXZpY2VzKCk7XG4gICAgICBpZiAoZGV2aWNlcy5sZW5ndGggPCAxKSB7XG4gICAgICAgIGxvZy5kZWJ1ZyhcIkNvdWxkIG5vdCBmaW5kIGRldmljZXMsIHJlc3RhcnRpbmcgYWRiIHNlcnZlci4uLlwiKTtcbiAgICAgICAgYXdhaXQgdGhpcy5yZXN0YXJ0QWRiKCk7XG4gICAgICAgIC8vIGNvb2wgZG93blxuICAgICAgICBhd2FpdCBzbGVlcCgyMDApO1xuICAgICAgICByZXR1cm4gYXdhaXQgZ2V0RGV2aWNlcygpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRldmljZXM7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgbG9nLmRlYnVnKFwiQ291bGQgbm90IGZpbmQgZGV2aWNlcywgcmVzdGFydGluZyBhZGIgc2VydmVyLi4uXCIpO1xuICAgICAgYXdhaXQgdGhpcy5yZXN0YXJ0QWRiKCk7XG4gICAgICAvLyBjb29sIGRvd25cbiAgICAgIGF3YWl0IHNsZWVwKDIwMCk7XG4gICAgICByZXR1cm4gYXdhaXQgZ2V0RGV2aWNlcygpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGF3YWl0IGdldERldmljZXMoKTtcbn07XG5cbnN5c3RlbUNhbGxNZXRob2RzLnJlc3RhcnRBZGIgPSBhc3luYyBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLnN1cHByZXNzS2lsbFNlcnZlcikge1xuICAgIGxvZy5kZWJ1ZyhgTm90IHJlc3RhcnRpbmcgYWJkIHNpbmNlICdzdXBwcmVzc0tpbGxTZXJ2ZXInIGlzIG9uYCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgbG9nLmRlYnVnKCdSZXN0YXJ0aW5nIGFkYicpO1xuICB0cnkge1xuICAgIGF3YWl0IGV4ZWModGhpcy5leGVjdXRhYmxlLnBhdGgsIFsna2lsbC1zZXJ2ZXInXSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBsb2cuZXJyb3IoXCJFcnJvciBraWxsaW5nIEFEQiBzZXJ2ZXIsIGdvaW5nIHRvIHNlZSBpZiBpdCdzIG9ubGluZSBhbnl3YXlcIik7XG4gIH1cbn07XG5cbnN5c3RlbUNhbGxNZXRob2RzLnJlc2V0VGVsbmV0QXV0aFRva2VuID0gXy5tZW1vaXplKGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgLy8gVGhlIG1ldGhvZHMgaXMgdXNlZCB0byByZW1vdmUgdGVsbmV0IGF1dGggdG9rZW5cbiAgLy8gU2VlIGh0dHA6Ly90b29scy5hbmRyb2lkLmNvbS9yZWNlbnQvZW11bGF0b3IyNTE2cmVsZWFzZW5vdGVzIGZvciBtb3JlIGRldGFpbHNcbiAgY29uc3QgaG9tZUZvbGRlclBhdGggPSBwcm9jZXNzLmVudlsocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJykgPyAnVVNFUlBST0ZJTEUnIDogJ0hPTUUnXTtcbiAgaWYgKCFob21lRm9sZGVyUGF0aCkge1xuICAgIGxvZy53YXJuKCdDYW5ub3QgZmluZCB0aGUgcGF0aCB0byB1c2VyIGhvbWUgZm9sZGVyLiBJZ25vcmluZyByZXNldHRpbmcgb2YgZW11bGF0b3JcXCdzIHRlbG5ldCBhdXRoZW50aWNhdGlvbiB0b2tlbicpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBkc3RQYXRoID0gcGF0aC5yZXNvbHZlKGhvbWVGb2xkZXJQYXRoLCAnLmVtdWxhdG9yX2NvbnNvbGVfYXV0aF90b2tlbicpO1xuICBsb2cuZGVidWcoYE92ZXJyaWRpbmcgJHtkc3RQYXRofSB3aXRoIGFuIGVtcHR5IHN0cmluZyB0byBhdm9pZCB0ZWxuZXQgYXV0aGVudGljYXRpb24gZm9yIGVtdWxhdG9yIGNvbW1hbmRzYCk7XG4gIHRyeSB7XG4gICAgYXdhaXQgZnMud3JpdGVGaWxlKGRzdFBhdGgsICcnKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGxvZy53YXJuKGBFcnJvciAke2UubWVzc2FnZX0gd2hpbGUgcmVzZXR0aW5nIHRoZSBjb250ZW50IG9mICR7ZHN0UGF0aH0uIElnbm9yaW5nIHJlc2V0dGluZyBvZiBlbXVsYXRvclxcJ3MgdGVsbmV0IGF1dGhlbnRpY2F0aW9uIHRva2VuYCk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufSk7XG5cbnN5c3RlbUNhbGxNZXRob2RzLmFkYkV4ZWNFbXUgPSBhc3luYyBmdW5jdGlvbiAoY21kKSB7XG4gIGF3YWl0IHRoaXMudmVyaWZ5RW11bGF0b3JDb25uZWN0ZWQoKTtcbiAgYXdhaXQgdGhpcy5yZXNldFRlbG5ldEF1dGhUb2tlbigpO1xuICBhd2FpdCB0aGlzLmFkYkV4ZWMoWydlbXUnLCAuLi5jbWRdKTtcbn07XG5cbnN5c3RlbUNhbGxNZXRob2RzLmFkYkV4ZWMgPSBhc3luYyBmdW5jdGlvbiAoY21kLCBvcHRzID0ge30pIHtcbiAgaWYgKCFjbWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgbmVlZCB0byBwYXNzIGluIGEgY29tbWFuZCB0byBhZGJFeGVjKClcIik7XG4gIH1cbiAgLy8gc2V0dGluZyBkZWZhdWx0IHRpbWVvdXQgZm9yIGVhY2ggY29tbWFuZCB0byBwcmV2ZW50IGluZmluaXRlIHdhaXQuXG4gIG9wdHMudGltZW91dCA9IG9wdHMudGltZW91dCB8fCBERUZBVUxUX0FEQl9FWEVDX1RJTUVPVVQ7XG4gIGxldCBleGVjRnVuYyA9IGFzeW5jICgpID0+IHtcbiAgICBsZXQgbGlua2VyV2FybmluZ1JlID0gL15XQVJOSU5HOiBsaW5rZXIuKyQvbTtcbiAgICB0cnkge1xuICAgICAgaWYgKCEoY21kIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgICAgIGNtZCA9IFtjbWRdO1xuICAgICAgfVxuICAgICAgbGV0IGFyZ3MgPSB0aGlzLmV4ZWN1dGFibGUuZGVmYXVsdEFyZ3MuY29uY2F0KGNtZCk7XG4gICAgICBsb2cuZGVidWcoYFJ1bm5pbmcgJyR7dGhpcy5leGVjdXRhYmxlLnBhdGh9JyB3aXRoIGFyZ3M6IGAgK1xuICAgICAgICAgICAgICAgIGAke0pTT04uc3RyaW5naWZ5KGFyZ3MpfWApO1xuICAgICAgbGV0IHtzdGRvdXR9ID0gYXdhaXQgZXhlYyh0aGlzLmV4ZWN1dGFibGUucGF0aCwgYXJncywgb3B0cyk7XG4gICAgICAvLyBzb21ldGltZXMgQURCIHByaW50cyBvdXQgd2VpcmQgc3Rkb3V0IHdhcm5pbmdzIHRoYXQgd2UgZG9uJ3Qgd2FudFxuICAgICAgLy8gdG8gaW5jbHVkZSBpbiBhbnkgb2YgdGhlIHJlc3BvbnNlIGRhdGEsIHNvIGxldCdzIHN0cmlwIGl0IG91dFxuICAgICAgc3Rkb3V0ID0gc3Rkb3V0LnJlcGxhY2UobGlua2VyV2FybmluZ1JlLCAnJykudHJpbSgpO1xuICAgICAgcmV0dXJuIHN0ZG91dDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBsZXQgcHJvdG9jb2xGYXVsdEVycm9yID0gbmV3IFJlZ0V4cChcInByb3RvY29sIGZhdWx0IFxcXFwobm8gc3RhdHVzXFxcXClcIiwgXCJpXCIpLnRlc3QoZSk7XG4gICAgICBsZXQgZGV2aWNlTm90Rm91bmRFcnJvciA9IG5ldyBSZWdFeHAoXCJlcnJvcjogZGV2aWNlICgnLisnICk/bm90IGZvdW5kXCIsIFwiaVwiKS50ZXN0KGUpO1xuICAgICAgaWYgKHByb3RvY29sRmF1bHRFcnJvciB8fCBkZXZpY2VOb3RGb3VuZEVycm9yKSB7XG4gICAgICAgIGxvZy5pbmZvKGBFcnJvciBzZW5kaW5nIGNvbW1hbmQsIHJlY29ubmVjdGluZyBkZXZpY2UgYW5kIHJldHJ5aW5nOiAke2NtZH1gKTtcbiAgICAgICAgYXdhaXQgc2xlZXAoMTAwMCk7XG4gICAgICAgIGF3YWl0IHRoaXMuZ2V0RGV2aWNlc1dpdGhSZXRyeSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZS5zdGRvdXQpIHtcbiAgICAgICAgbGV0IHN0ZG91dCA9IGUuc3Rkb3V0O1xuICAgICAgICBzdGRvdXQgPSBzdGRvdXQucmVwbGFjZShsaW5rZXJXYXJuaW5nUmUsICcnKS50cmltKCk7XG4gICAgICAgIHJldHVybiBzdGRvdXQ7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIGV4ZWN1dGluZyBhZGJFeGVjLiBPcmlnaW5hbCBlcnJvcjogJyR7ZS5tZXNzYWdlfSc7IGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYFN0ZGVycjogJyR7KGUuc3RkZXJyIHx8ICcnKS50cmltKCl9JzsgQ29kZTogJyR7ZS5jb2RlfSdgKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBhd2FpdCByZXRyeSgyLCBleGVjRnVuYyk7XG59O1xuXG5zeXN0ZW1DYWxsTWV0aG9kcy5zaGVsbCA9IGFzeW5jIGZ1bmN0aW9uIChjbWQsIG9wdHMgPSB7fSkge1xuICBpZiAoIWF3YWl0IHRoaXMuaXNEZXZpY2VDb25uZWN0ZWQoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgTm8gZGV2aWNlIGNvbm5lY3RlZCwgY2Fubm90IHJ1biBhZGIgc2hlbGwgY29tbWFuZCAnJHtjbWQuam9pbignICcpfSdgKTtcbiAgfVxuICBsZXQgZXhlY0NtZCA9IFsnc2hlbGwnXTtcbiAgaWYgKGNtZCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgZXhlY0NtZCA9IGV4ZWNDbWQuY29uY2F0KGNtZCk7XG4gIH0gZWxzZSB7XG4gICAgZXhlY0NtZC5wdXNoKGNtZCk7XG4gIH1cbiAgcmV0dXJuIGF3YWl0IHRoaXMuYWRiRXhlYyhleGVjQ21kLCBvcHRzKTtcbn07XG5cbnN5c3RlbUNhbGxNZXRob2RzLmNyZWF0ZVN1YlByb2Nlc3MgPSBmdW5jdGlvbiAoYXJncyA9IFtdKSB7XG4gIC8vIGFkZCB0aGUgZGVmYXVsdCBhcmd1bWVudHNcbiAgYXJncyA9IHRoaXMuZXhlY3V0YWJsZS5kZWZhdWx0QXJncy5jb25jYXQoYXJncyk7XG4gIGxvZy5kZWJ1ZyhgQ3JlYXRpbmcgQURCIHN1YnByb2Nlc3Mgd2l0aCBhcmdzOiAke0pTT04uc3RyaW5naWZ5KGFyZ3MpfWApO1xuICByZXR1cm4gbmV3IFN1YlByb2Nlc3ModGhpcy5nZXRBZGJQYXRoKCksIGFyZ3MpO1xufTtcblxuLy8gVE9ETyBjYW4gcHJvYmFibHkgZGVwcmVjYXRlIHRoaXMgbm93IHRoYXQgdGhlIGxvZ2ljIGlzIGp1c3QgdG8gcmVhZFxuLy8gdGhpcy5hZGJQb3J0XG5zeXN0ZW1DYWxsTWV0aG9kcy5nZXRBZGJTZXJ2ZXJQb3J0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5hZGJQb3J0O1xufTtcblxuc3lzdGVtQ2FsbE1ldGhvZHMuZ2V0RW11bGF0b3JQb3J0ID0gYXN5bmMgZnVuY3Rpb24gKCkge1xuICBsb2cuZGVidWcoXCJHZXR0aW5nIHJ1bm5pbmcgZW11bGF0b3IgcG9ydFwiKTtcbiAgaWYgKHRoaXMuZW11bGF0b3JQb3J0ICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHRoaXMuZW11bGF0b3JQb3J0O1xuICB9XG4gIHRyeSB7XG4gICAgbGV0IGRldmljZXMgPSBhd2FpdCB0aGlzLmdldENvbm5lY3RlZERldmljZXMoKTtcbiAgICBsZXQgcG9ydCA9IHRoaXMuZ2V0UG9ydEZyb21FbXVsYXRvclN0cmluZyhkZXZpY2VzWzBdLnVkaWQpO1xuICAgIGlmIChwb3J0KSB7XG4gICAgICByZXR1cm4gcG9ydDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBFbXVsYXRvciBwb3J0IG5vdCBmb3VuZGApO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIGxvZy5lcnJvckFuZFRocm93KGBObyBkZXZpY2VzIGNvbm5lY3RlZC4gT3JpZ2luYWwgZXJyb3I6ICR7ZS5tZXNzYWdlfWApO1xuICB9XG59O1xuXG5zeXN0ZW1DYWxsTWV0aG9kcy5nZXRQb3J0RnJvbUVtdWxhdG9yU3RyaW5nID0gZnVuY3Rpb24gKGVtU3RyKSB7XG4gIGxldCBwb3J0UGF0dGVybiA9IC9lbXVsYXRvci0oXFxkKykvO1xuICBpZiAocG9ydFBhdHRlcm4udGVzdChlbVN0cikpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQocG9ydFBhdHRlcm4uZXhlYyhlbVN0cilbMV0sIDEwKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5zeXN0ZW1DYWxsTWV0aG9kcy5nZXRDb25uZWN0ZWRFbXVsYXRvcnMgPSBhc3luYyBmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgbG9nLmRlYnVnKFwiR2V0dGluZyBjb25uZWN0ZWQgZW11bGF0b3JzXCIpO1xuICAgIGxldCBkZXZpY2VzID0gYXdhaXQgdGhpcy5nZXRDb25uZWN0ZWREZXZpY2VzKCk7XG4gICAgbGV0IGVtdWxhdG9ycyA9IFtdO1xuICAgIGZvciAobGV0IGRldmljZSBvZiBkZXZpY2VzKSB7XG4gICAgICBsZXQgcG9ydCA9IHRoaXMuZ2V0UG9ydEZyb21FbXVsYXRvclN0cmluZyhkZXZpY2UudWRpZCk7XG4gICAgICBpZiAocG9ydCkge1xuICAgICAgICBkZXZpY2UucG9ydCA9IHBvcnQ7XG4gICAgICAgIGVtdWxhdG9ycy5wdXNoKGRldmljZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGxvZy5kZWJ1ZyhgJHtlbXVsYXRvcnMubGVuZ3RofSBlbXVsYXRvcihzKSBjb25uZWN0ZWRgKTtcbiAgICByZXR1cm4gZW11bGF0b3JzO1xuICB9IGNhdGNoIChlKSB7XG4gICAgbG9nLmVycm9yQW5kVGhyb3coYEVycm9yIGdldHRpbmcgZW11bGF0b3JzLiBPcmlnaW5hbCBlcnJvcjogJHtlLm1lc3NhZ2V9YCk7XG4gIH1cbn07XG5cbnN5c3RlbUNhbGxNZXRob2RzLnNldEVtdWxhdG9yUG9ydCA9IGZ1bmN0aW9uIChlbVBvcnQpIHtcbiAgdGhpcy5lbXVsYXRvclBvcnQgPSBlbVBvcnQ7XG59O1xuXG5zeXN0ZW1DYWxsTWV0aG9kcy5zZXREZXZpY2VJZCA9IGZ1bmN0aW9uIChkZXZpY2VJZCkge1xuICBsb2cuZGVidWcoYFNldHRpbmcgZGV2aWNlIGlkIHRvICR7ZGV2aWNlSWR9YCk7XG4gIHRoaXMuY3VyRGV2aWNlSWQgPSBkZXZpY2VJZDtcbiAgbGV0IGFyZ3NIYXNEZXZpY2UgPSB0aGlzLmV4ZWN1dGFibGUuZGVmYXVsdEFyZ3MuaW5kZXhPZignLXMnKTtcbiAgaWYgKGFyZ3NIYXNEZXZpY2UgIT09IC0xKSB7XG4gICAgLy8gcmVtb3ZlIHRoZSBvbGQgZGV2aWNlIGlkIGZyb20gdGhlIGFyZ3VtZW50c1xuICAgIHRoaXMuZXhlY3V0YWJsZS5kZWZhdWx0QXJncy5zcGxpY2UoYXJnc0hhc0RldmljZSwgMik7XG4gIH1cbiAgdGhpcy5leGVjdXRhYmxlLmRlZmF1bHRBcmdzLnB1c2goJy1zJywgZGV2aWNlSWQpO1xufTtcblxuc3lzdGVtQ2FsbE1ldGhvZHMuc2V0RGV2aWNlID0gZnVuY3Rpb24gKGRldmljZU9iaikge1xuICBsZXQgZGV2aWNlSWQgPSBkZXZpY2VPYmoudWRpZDtcbiAgbGV0IGVtUG9ydCA9IHRoaXMuZ2V0UG9ydEZyb21FbXVsYXRvclN0cmluZyhkZXZpY2VJZCk7XG4gIHRoaXMuc2V0RW11bGF0b3JQb3J0KGVtUG9ydCk7XG4gIHRoaXMuc2V0RGV2aWNlSWQoZGV2aWNlSWQpO1xufTtcblxuc3lzdGVtQ2FsbE1ldGhvZHMuZ2V0UnVubmluZ0FWRCA9IGFzeW5jIGZ1bmN0aW9uIChhdmROYW1lKSB7XG4gIHRyeSB7XG4gICAgbG9nLmRlYnVnKGBUcnlpbmcgdG8gZmluZCAke2F2ZE5hbWV9IGVtdWxhdG9yYCk7XG4gICAgbGV0IGVtdWxhdG9ycyA9IGF3YWl0IHRoaXMuZ2V0Q29ubmVjdGVkRW11bGF0b3JzKCk7XG4gICAgZm9yIChsZXQgZW11bGF0b3Igb2YgZW11bGF0b3JzKSB7XG4gICAgICB0aGlzLnNldEVtdWxhdG9yUG9ydChlbXVsYXRvci5wb3J0KTtcbiAgICAgIGxldCBydW5uaW5nQVZETmFtZSA9IGF3YWl0IHRoaXMuc2VuZFRlbG5ldENvbW1hbmQoXCJhdmQgbmFtZVwiKTtcbiAgICAgIGlmIChhdmROYW1lID09PSBydW5uaW5nQVZETmFtZSkge1xuICAgICAgICBsb2cuZGVidWcoYEZvdW5kIGVtdWxhdG9yICR7YXZkTmFtZX0gaW4gcG9ydCAke2VtdWxhdG9yLnBvcnR9YCk7XG4gICAgICAgIHRoaXMuc2V0RGV2aWNlSWQoZW11bGF0b3IudWRpZCk7XG4gICAgICAgIHJldHVybiBlbXVsYXRvcjtcbiAgICAgIH1cbiAgICB9XG4gICAgbG9nLmRlYnVnKGBFbXVsYXRvciAke2F2ZE5hbWV9IG5vdCBydW5uaW5nYCk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBsb2cuZXJyb3JBbmRUaHJvdyhgRXJyb3IgZ2V0dGluZyBBVkQuIE9yaWdpbmFsIGVycm9yOiAke2UubWVzc2FnZX1gKTtcbiAgfVxufTtcblxuc3lzdGVtQ2FsbE1ldGhvZHMuZ2V0UnVubmluZ0FWRFdpdGhSZXRyeSA9IGFzeW5jIGZ1bmN0aW9uIChhdmROYW1lLCB0aW1lb3V0TXMgPSAyMDAwMCkge1xuICB0cnkge1xuICAgIGxldCBzdGFydCA9IERhdGUubm93KCk7XG4gICAgd2hpbGUgKChEYXRlLm5vdygpIC0gc3RhcnQpIDwgdGltZW91dE1zKSB7XG4gICAgICB0cnkge1xuICAgICAgICBsZXQgcnVubmluZ0FWRCA9IGF3YWl0IHRoaXMuZ2V0UnVubmluZ0FWRChhdmROYW1lLnJlcGxhY2UoJ0AnLCAnJykpO1xuICAgICAgICBpZiAocnVubmluZ0FWRCkge1xuICAgICAgICAgIHJldHVybiBydW5uaW5nQVZEO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIERvIG5vdGhpbmcuXG4gICAgICAgIGxvZy5pbmZvKGBDb3VsZG4ndCBnZXQgcnVubmluZyBBVkQsIHdpbGwgcmV0cnkuIEVycm9yIHdhczogJHtlLm1lc3NhZ2V9YCk7XG4gICAgICB9XG4gICAgICAvLyBjb29sIGRvd25cbiAgICAgIGF3YWl0IHNsZWVwKDIwMCk7XG4gICAgfVxuICAgIGxvZy5lcnJvckFuZFRocm93KGBDb3VsZCBub3QgZmluZCAke2F2ZE5hbWV9IGVtdWxhdG9yLmApO1xuICB9IGNhdGNoIChlKSB7XG4gICAgbG9nLmVycm9yQW5kVGhyb3coYEVycm9yIGdldHRpbmcgQVZEIHdpdGggcmV0cnkuIE9yaWdpbmFsIGVycm9yOiAke2UubWVzc2FnZX1gKTtcbiAgfVxufTtcblxuc3lzdGVtQ2FsbE1ldGhvZHMua2lsbEFsbEVtdWxhdG9ycyA9IGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgbGV0IGNtZCwgYXJncztcbiAgaWYgKHN5c3RlbS5pc1dpbmRvd3MoKSkge1xuICAgIGNtZCA9ICdUQVNLS0lMTCc7XG4gICAgYXJncyA9IFsnVEFTS0tJTEwnLCAnL0lNJywgJ2VtdWxhdG9yLmV4ZSddO1xuICB9IGVsc2Uge1xuICAgIGNtZCA9ICcvdXNyL2Jpbi9raWxsYWxsJztcbiAgICBhcmdzID0gWyctbScsICdlbXVsYXRvcionXTtcbiAgfVxuICB0cnkge1xuICAgIGF3YWl0IGV4ZWMoY21kLCBhcmdzKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGxvZy5lcnJvckFuZFRocm93KGBFcnJvciBraWxsaW5nIGVtdWxhdG9ycy4gT3JpZ2luYWwgZXJyb3I6ICR7ZS5tZXNzYWdlfWApO1xuICB9XG59O1xuXG5zeXN0ZW1DYWxsTWV0aG9kcy5raWxsRW11bGF0b3IgPSBhc3luYyBmdW5jdGlvbiAoYXZkTmFtZSkge1xuICBsb2cuZGVidWcoYGtpbGxpbmcgYXZkICcke2F2ZE5hbWV9J2ApO1xuICBsZXQgZGV2aWNlID0gYXdhaXQgdGhpcy5nZXRSdW5uaW5nQVZEKGF2ZE5hbWUpO1xuICBpZiAoZGV2aWNlKSB7XG4gICAgYXdhaXQgdGhpcy5hZGJFeGVjKFsnZW11JywgJ2tpbGwnXSk7XG4gICAgbG9nLmluZm8oYHN1Y2Nlc3NmdWxseSBraWxsZWQgZW11bGF0b3IgJyR7YXZkTmFtZX0nYCk7XG4gIH0gZWxzZSB7XG4gICAgbG9nLmluZm8oYG5vIGF2ZCB3aXRoIG5hbWUgJyR7YXZkTmFtZX0nIHJ1bm5pbmcuIHNraXBwaW5nIGtpbGwgc3RlcC5gKTtcbiAgfVxufTtcblxuc3lzdGVtQ2FsbE1ldGhvZHMubGF1bmNoQVZEID0gYXN5bmMgZnVuY3Rpb24gKGF2ZE5hbWUsIGF2ZEFyZ3MsIGxhbmd1YWdlLCBjb3VudHJ5LFxuICBhdmRMYXVuY2hUaW1lb3V0ID0gNjAwMDAsIGF2ZFJlYWR5VGltZW91dCA9IDYwMDAwLCByZXRyeVRpbWVzID0gMSkge1xuICBsb2cuZGVidWcoYExhdW5jaGluZyBFbXVsYXRvciB3aXRoIEFWRCAke2F2ZE5hbWV9LCBsYXVuY2hUaW1lb3V0YCArXG4gICAgICAgICAgICBgJHthdmRMYXVuY2hUaW1lb3V0fSBtcyBhbmQgcmVhZHlUaW1lb3V0ICR7YXZkUmVhZHlUaW1lb3V0fSBtc2ApO1xuICBsZXQgZW11bGF0b3JCaW5hcnlQYXRoID0gYXdhaXQgdGhpcy5nZXRTZGtCaW5hcnlQYXRoKFwiZW11bGF0b3JcIik7XG4gIGlmIChhdmROYW1lWzBdID09PSBcIkBcIikge1xuICAgIGF2ZE5hbWUgPSBhdmROYW1lLnN1YnN0cigxKTtcbiAgfVxuICBhd2FpdCB0aGlzLmNoZWNrQXZkRXhpc3QoYXZkTmFtZSk7XG4gIGxldCBsYXVuY2hBcmdzID0gW1wiLWF2ZFwiLCBhdmROYW1lXTtcbiAgaWYgKHR5cGVvZiBsYW5ndWFnZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIGxvZy5kZWJ1ZyhgU2V0dGluZyBBbmRyb2lkIERldmljZSBMYW5ndWFnZSB0byAke2xhbmd1YWdlfWApO1xuICAgIGxhdW5jaEFyZ3MucHVzaChcIi1wcm9wXCIsIGBwZXJzaXN0LnN5cy5sYW5ndWFnZT0ke2xhbmd1YWdlLnRvTG93ZXJDYXNlKCl9YCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBjb3VudHJ5ID09PSBcInN0cmluZ1wiKSB7XG4gICAgbG9nLmRlYnVnKGBTZXR0aW5nIEFuZHJvaWQgRGV2aWNlIENvdW50cnkgdG8gJHtjb3VudHJ5fWApO1xuICAgIGxhdW5jaEFyZ3MucHVzaChcIi1wcm9wXCIsIGBwZXJzaXN0LnN5cy5jb3VudHJ5PSR7Y291bnRyeS50b1VwcGVyQ2FzZSgpfWApO1xuICB9XG4gIGxldCBsb2NhbGU7XG4gIGlmICh0eXBlb2YgbGFuZ3VhZ2UgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIGNvdW50cnkgPT09IFwic3RyaW5nXCIpIHtcbiAgICBsb2NhbGUgPSBsYW5ndWFnZS50b0xvd2VyQ2FzZSgpICsgXCItXCIgKyBjb3VudHJ5LnRvVXBwZXJDYXNlKCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGxhbmd1YWdlID09PSBcInN0cmluZ1wiKSB7XG4gICAgbG9jYWxlID0gbGFuZ3VhZ2UudG9Mb3dlckNhc2UoKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgY291bnRyeSA9PT0gXCJzdHJpbmdcIikge1xuICAgIGxvY2FsZSA9IGNvdW50cnk7XG4gIH1cbiAgaWYgKHR5cGVvZiBsb2NhbGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICBsb2cuZGVidWcoYFNldHRpbmcgQW5kcm9pZCBEZXZpY2UgTG9jYWxlIHRvICR7bG9jYWxlfWApO1xuICAgIGxhdW5jaEFyZ3MucHVzaChcIi1wcm9wXCIsIGBwZXJzaXN0LnN5cy5sb2NhbGU9JHtsb2NhbGV9YCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBhdmRBcmdzID09PSBcInN0cmluZ1wiKSB7XG4gICAgYXZkQXJncyA9IGF2ZEFyZ3Muc3BsaXQoXCIgXCIpO1xuICAgIGxhdW5jaEFyZ3MgPSBsYXVuY2hBcmdzLmNvbmNhdChhdmRBcmdzKTtcbiAgfVxuICBsb2cuZGVidWcoYFJ1bm5pbmcgJyR7ZW11bGF0b3JCaW5hcnlQYXRofScgd2l0aCBhcmdzOiAke0pTT04uc3RyaW5naWZ5KGxhdW5jaEFyZ3MpfWApO1xuICBsZXQgcHJvYyA9IG5ldyBTdWJQcm9jZXNzKGVtdWxhdG9yQmluYXJ5UGF0aCwgbGF1bmNoQXJncyk7XG4gIGF3YWl0IHByb2Muc3RhcnQoMCk7XG4gIHByb2Mub24oJ291dHB1dCcsIChzdGRvdXQsIHN0ZGVycikgPT4ge1xuICAgIGxvZy5pbmZvKGBbQVZEIE9VVFBVVF0gJHtzdGRvdXQgfHwgc3RkZXJyfWApO1xuICB9KTtcbiAgYXdhaXQgcmV0cnkocmV0cnlUaW1lcywgdGhpcy5nZXRSdW5uaW5nQVZEV2l0aFJldHJ5LmJpbmQodGhpcyksIGF2ZE5hbWUsIGF2ZExhdW5jaFRpbWVvdXQpO1xuICBhd2FpdCB0aGlzLndhaXRGb3JFbXVsYXRvclJlYWR5KGF2ZFJlYWR5VGltZW91dCk7XG4gIHJldHVybiBwcm9jO1xufTtcblxuc3lzdGVtQ2FsbE1ldGhvZHMuZ2V0QWRiVmVyc2lvbiA9IF8ubWVtb2l6ZShhc3luYyBmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgbGV0IGFkYlZlcnNpb24gPSAoYXdhaXQgdGhpcy5hZGJFeGVjKCd2ZXJzaW9uJykpXG4gICAgICAucmVwbGFjZSgvQW5kcm9pZFxcc0RlYnVnXFxzQnJpZGdlXFxzdmVyc2lvblxccyhbXFxkXFwuXSopW1xcc1xcd1xcLV0qLywgXCIkMVwiKTtcbiAgICBsZXQgcGFydHMgPSBhZGJWZXJzaW9uLnNwbGl0KCcuJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZlcnNpb25TdHJpbmc6IGFkYlZlcnNpb24sXG4gICAgICB2ZXJzaW9uRmxvYXQ6IHBhcnNlRmxvYXQoYWRiVmVyc2lvbiksXG4gICAgICBtYWpvcjogcGFyc2VJbnQocGFydHNbMF0sIDEwKSxcbiAgICAgIG1pbm9yOiBwYXJzZUludChwYXJ0c1sxXSwgMTApLFxuICAgICAgcGF0Y2g6IHBhcnRzWzJdID8gcGFyc2VJbnQocGFydHNbMl0sIDEwKSA6IHVuZGVmaW5lZCxcbiAgICB9O1xuICB9IGNhdGNoIChlKSB7XG4gICAgbG9nLmVycm9yQW5kVGhyb3coYEVycm9yIGdldHRpbmcgYWRiIHZlcnNpb24uIE9yaWdpbmFsIGVycm9yOiAnJHtlLm1lc3NhZ2V9JzsgYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgU3RkZXJyOiAnJHsoZS5zdGRlcnIgfHwgJycpLnRyaW0oKX0nOyBDb2RlOiAnJHtlLmNvZGV9J2ApO1xuICB9XG59KTtcblxuXG5zeXN0ZW1DYWxsTWV0aG9kcy5jaGVja0F2ZEV4aXN0ID0gYXN5bmMgZnVuY3Rpb24gKGF2ZE5hbWUpIHtcbiAgbGV0IGNtZCwgcmVzdWx0O1xuICB0cnkge1xuICAgIGNtZCA9IGF3YWl0IHRoaXMuZ2V0U2RrQmluYXJ5UGF0aCgnZW11bGF0b3InKTtcbiAgICByZXN1bHQgPSBhd2FpdCBleGVjKGNtZCwgWyctbGlzdC1hdmRzJ10pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgbGV0IHVua25vd25PcHRpb25FcnJvciA9IG5ldyBSZWdFeHAoXCJ1bmtub3duIG9wdGlvbjogLWxpc3QtYXZkc1wiLCBcImlcIikudGVzdChlLnN0ZGVycik7XG4gICAgaWYgKCF1bmtub3duT3B0aW9uRXJyb3IpIHtcbiAgICAgIGxvZy5lcnJvckFuZFRocm93KGBFcnJvciBleGVjdXRpbmcgY2hlY2tBdmRFeGlzdC4gT3JpZ2luYWwgZXJyb3I6ICcke2UubWVzc2FnZX0nOyBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBTdGRlcnI6ICckeyhlLnN0ZGVyciB8fCAnJykudHJpbSgpfSc7IENvZGU6ICcke2UuY29kZX0nYCk7XG5cbiAgICB9XG4gICAgY29uc3Qgc2RrVmVyc2lvbiA9IGF3YWl0IGdldFNka1Rvb2xzVmVyc2lvbigpO1xuICAgIGxldCBiaW5hcnlOYW1lID0gJ2FuZHJvaWQnO1xuICAgIGlmIChzZGtWZXJzaW9uKSB7XG4gICAgICBpZiAoc2RrVmVyc2lvbi5tYWpvciA+PSAyNSkge1xuICAgICAgICBiaW5hcnlOYW1lID0gJ2F2ZG1hbmFnZXInO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsb2cud2FybihgRGVmYXVsdGluZyBiaW5hcnkgbmFtZSB0byAnJHtiaW5hcnlOYW1lfScsIGJlY2F1c2UgU0RLIHZlcnNpb24gY2Fubm90IGJlIHBhcnNlZGApO1xuICAgIH1cbiAgICAvLyBJZiAtbGlzdC1hdmRzIG9wdGlvbiBpcyBub3QgYXZhaWxhYmxlLCB1c2UgYW5kcm9pZCBjb21tYW5kIGFzIGFuIGFsdGVybmF0aXZlXG4gICAgY21kID0gYXdhaXQgdGhpcy5nZXRTZGtCaW5hcnlQYXRoKGJpbmFyeU5hbWUpO1xuICAgIHJlc3VsdCA9IGF3YWl0IGV4ZWMoY21kLCBbJ2xpc3QnLCAnYXZkJywgJy1jJ10pO1xuICB9XG4gIGlmIChyZXN1bHQuc3Rkb3V0LmluZGV4T2YoYXZkTmFtZSkgPT09IC0xKSB7XG4gICAgbGV0IGV4aXN0aW5ncyA9IGAoJHtyZXN1bHQuc3Rkb3V0LnRyaW0oKS5yZXBsYWNlKC9bXFxuXS9nLCAnKSwgKCcpfSlgO1xuICAgIGxvZy5lcnJvckFuZFRocm93KGBBdmQgJyR7YXZkTmFtZX0nIGlzIG5vdCBhdmFpbGFibGUuIHBsZWFzZSBzZWxlY3QgeW91ciBhdmQgbmFtZSBmcm9tIG9uZSBvZiB0aGVzZTogJyR7ZXhpc3RpbmdzfSdgKTtcbiAgfVxufTtcblxuc3lzdGVtQ2FsbE1ldGhvZHMud2FpdEZvckVtdWxhdG9yUmVhZHkgPSBhc3luYyBmdW5jdGlvbiAodGltZW91dE1zID0gMjAwMDApIHtcbiAgbGV0IHN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgbG9nLmRlYnVnKFwiV2FpdGluZyB1bnRpbCBlbXVsYXRvciBpcyByZWFkeVwiKTtcbiAgd2hpbGUgKChEYXRlLm5vdygpIC0gc3RhcnQpIDwgdGltZW91dE1zKSB7XG4gICAgdHJ5IHtcbiAgICAgIGxldCBzdGRvdXQgPSBhd2FpdCB0aGlzLnNoZWxsKFtcImdldHByb3BcIiwgXCJpbml0LnN2Yy5ib290YW5pbVwiXSk7XG4gICAgICBpZiAoc3Rkb3V0LmluZGV4T2YoJ3N0b3BwZWQnKSA+IC0xKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBkbyBub3RoaW5nXG4gICAgfVxuICAgIGF3YWl0IHNsZWVwKDMwMDApO1xuICB9XG4gIGxvZy5lcnJvckFuZFRocm93KCdFbXVsYXRvciBub3QgcmVhZHknKTtcbn07XG5cbnN5c3RlbUNhbGxNZXRob2RzLndhaXRGb3JEZXZpY2UgPSBhc3luYyBmdW5jdGlvbiAoYXBwRGV2aWNlUmVhZHlUaW1lb3V0ID0gMzApIHtcbiAgdGhpcy5hcHBEZXZpY2VSZWFkeVRpbWVvdXQgPSBhcHBEZXZpY2VSZWFkeVRpbWVvdXQ7XG4gIGNvbnN0IHJldHJpZXMgPSAzO1xuICBjb25zdCB0aW1lb3V0ID0gcGFyc2VJbnQodGhpcy5hcHBEZXZpY2VSZWFkeVRpbWVvdXQsIDEwKSAvIHJldHJpZXMgKiAxMDAwO1xuICBhd2FpdCByZXRyeShyZXRyaWVzLCBhc3luYyAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuYWRiRXhlYygnd2FpdC1mb3ItZGV2aWNlJywge3RpbWVvdXR9KTtcbiAgICAgIGF3YWl0IHRoaXMucGluZygpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGF3YWl0IHRoaXMucmVzdGFydEFkYigpO1xuICAgICAgYXdhaXQgdGhpcy5nZXRDb25uZWN0ZWREZXZpY2VzKCk7XG4gICAgICBsb2cuZXJyb3JBbmRUaHJvdyhgRXJyb3IgaW4gd2FpdGluZyBmb3IgZGV2aWNlLiBPcmlnaW5hbCBlcnJvcjogJyR7ZS5tZXNzYWdlfScuIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgIGBSZXRyeWluZyBieSByZXN0YXJ0aW5nIEFEQmApO1xuICAgIH1cbiAgfSk7XG59O1xuXG5zeXN0ZW1DYWxsTWV0aG9kcy5yZWJvb3QgPSBhc3luYyBmdW5jdGlvbiAocmV0cmllcyA9IERFRkFVTFRfQURCX1JFQk9PVF9SRVRSSUVTKSB7XG4gIHRyeSB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuc2hlbGwoWydzdG9wJ10pO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKGVyci5tZXNzYWdlLmluZGV4T2YoJ211c3QgYmUgcm9vdCcpID09PSAtMSkge1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgICAvLyB0aGlzIGRldmljZSBuZWVkcyBhZGIgdG8gYmUgcnVubmluZyBhcyByb290IHRvIHN0b3AuXG4gICAgICAvLyBzbyB0cnkgdG8gcmVzdGFydCB0aGUgZGFlbW9uXG4gICAgICBsb2cuZGVidWcoJ0RldmljZSByZXF1aXJlcyBhZGIgdG8gYmUgcnVubmluZyBhcyByb290IGluIG9yZGVyIHRvIHJlYm9vdC4gUmVzdGFydGluZyBkYWVtb24nKTtcbiAgICAgIGF3YWl0IHRoaXMucm9vdCgpO1xuICAgICAgYXdhaXQgdGhpcy5zaGVsbChbJ3N0b3AnXSk7XG4gICAgfVxuICAgIGF3YWl0IEIuZGVsYXkoMjAwMCk7IC8vIGxldCB0aGUgZW11IGZpbmlzaCBzdG9wcGluZztcbiAgICBhd2FpdCB0aGlzLnNldERldmljZVByb3BlcnR5KCdzeXMuYm9vdF9jb21wbGV0ZWQnLCAwKTtcbiAgICBhd2FpdCB0aGlzLnNoZWxsKFsnc3RhcnQnXSk7XG4gICAgYXdhaXQgcmV0cnlJbnRlcnZhbChyZXRyaWVzLCAxMDAwLCBhc3luYyAoKSA9PiB7XG4gICAgICBsZXQgYm9vdGVkID0gYXdhaXQgdGhpcy5nZXREZXZpY2VQcm9wZXJ0eSgnc3lzLmJvb3RfY29tcGxldGVkJyk7XG4gICAgICBpZiAoYm9vdGVkID09PSAnMScpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gd2UgZG9uJ3Qgd2FudCB0aGUgc3RhY2sgdHJhY2UsIHNvIG5vIGxvZy5lcnJvckFuZFRocm93XG4gICAgICAgIGxldCBtc2cgPSAnV2FpdGluZyBmb3IgcmVib290LiBUaGlzIHRha2VzIHRpbWUnO1xuICAgICAgICBsb2cuZGVidWcobXNnKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0gZmluYWxseSB7XG4gICAgdGhpcy51bnJvb3QoKTtcbiAgfVxufTtcblxuc3lzdGVtQ2FsbE1ldGhvZHMucm9vdCA9IGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICBhd2FpdCBleGVjKHRoaXMuZXhlY3V0YWJsZS5wYXRoLCBbJ3Jvb3QnXSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGxvZy53YXJuKGBVbmFibGUgdG8gcm9vdCBhZGIgZGFlbW9uOiAnJHtlcnIubWVzc2FnZX0nLiBDb250aW51aW5nYCk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG5zeXN0ZW1DYWxsTWV0aG9kcy51bnJvb3QgPSBhc3luYyBmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgYXdhaXQgZXhlYyh0aGlzLmV4ZWN1dGFibGUucGF0aCwgWyd1bnJvb3QnXSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGxvZy53YXJuKGBVbmFibGUgdG8gdW5yb290IGFkYiBkYWVtb246ICcke2Vyci5tZXNzYWdlfScuIENvbnRpbnVpbmdgKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbnN5c3RlbUNhbGxNZXRob2RzLmZpbGVFeGlzdHMgPSBhc3luYyBmdW5jdGlvbiAocmVtb3RlUGF0aCkge1xuICBsZXQgZmlsZXMgPSBhd2FpdCB0aGlzLmxzKHJlbW90ZVBhdGgpO1xuICByZXR1cm4gZmlsZXMubGVuZ3RoID4gMDtcbn07XG5cbnN5c3RlbUNhbGxNZXRob2RzLmxzID0gYXN5bmMgZnVuY3Rpb24gKHJlbW90ZVBhdGgpIHtcbiAgdHJ5IHtcbiAgICBsZXQgc3Rkb3V0ID0gYXdhaXQgdGhpcy5zaGVsbChbJ2xzJywgcmVtb3RlUGF0aF0pO1xuICAgIGxldCBsaW5lcyA9IHN0ZG91dC5zcGxpdChcIlxcblwiKTtcbiAgICByZXR1cm4gbGluZXMubWFwKChsKSA9PiBsLnRyaW0oKSlcbiAgICAgICAgICAgICAgICAuZmlsdGVyKEJvb2xlYW4pXG4gICAgICAgICAgICAgICAgLmZpbHRlcigobCkgPT4gbC5pbmRleE9mKFwiTm8gc3VjaCBmaWxlXCIpID09PSAtMSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChlcnIubWVzc2FnZS5pbmRleE9mKCdObyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5JykgPT09IC0xKSB7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICAgIHJldHVybiBbXTtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgc3lzdGVtQ2FsbE1ldGhvZHM7XG4iXSwic291cmNlUm9vdCI6Ii4uLy4uLy4uIn0=
