'use strict';

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _Number$isNaN = require('babel-runtime/core-js/number/is-nan')['default'];

var _getIterator = require('babel-runtime/core-js/get-iterator')['default'];

var _Object$assign = require('babel-runtime/core-js/object/assign')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _asyncbox = require('asyncbox');

var commands = {},
    helpers = {},
    extensions = {};

var NETWORK_KEYS = [['bucketStart', 'activeTime', 'rxBytes', 'rxPackets', 'txBytes', 'txPackets', 'operations', 'bucketDuration'], ['st', 'activeTime', 'rb', 'rp', 'tb', 'tp', 'op', 'bucketDuration']];
var CPU_KEYS = ['user', 'kernel'];
var BATTERY_KEYS = ['power'];
var MEMORY_KEYS = ['totalPrivateDirty', 'nativePrivateDirty', 'dalvikPrivateDirty', 'eglPrivateDirty', 'glPrivateDirty', 'totalPss', 'nativePss', 'dalvikPss', 'eglPss', 'glPss', 'nativeHeapAllocatedSize', 'nativeHeapSize'];

var SUPPORTED_PERFORMANCE_DATA_TYPES = {
  cpuinfo: 'the amount of cpu by user and kernel process - cpu information for applications on real devices and simulators',
  memoryinfo: 'the amount of memory used by the process - memory information for applications on real devices and simulators',
  batteryinfo: 'the remaining battery power - battery power information for applications on real devices and simulators',
  networkinfo: 'the network statistics - network rx/tx information for applications on real devices and simulators'
};

var RETRY_PAUSE = 1000;

//
// returns the information type of the system state which is supported to read as like cpu, memory, network traffic, and battery.
// output - array like below
//[cpuinfo, batteryinfo, networkinfo, memoryinfo]
//
commands.getPerformanceDataTypes = function () {
  return _lodash2['default'].keys(SUPPORTED_PERFORMANCE_DATA_TYPES);
};

// returns the information type of the system state which is supported to read as like cpu, memory, network traffic, and battery.
//input - (packageName) the package name of the application
//        (dataType) the type of system state which wants to read. It should be one of the keys of the SUPPORTED_PERFORMANCE_DATA_TYPES
//        (dataReadTimeout) the number of attempts to read
// output - table of the performance data, The first line of the table represents the type of data. The remaining lines represent the values of the data.
//
// in case of battery info : [[power], [23]]
// in case of memory info :  [[totalPrivateDirty, nativePrivateDirty, dalvikPrivateDirty, eglPrivateDirty, glPrivateDirty, totalPss, nativePss, dalvikPss, eglPss, glPss, nativeHeapAllocatedSize, nativeHeapSize], [18360, 8296, 6132, null, null, 42588, 8406, 7024, null, null, 26519, 10344]]
// in case of network info : [[bucketStart, activeTime, rxBytes, rxPackets, txBytes, txPackets, operations, bucketDuration,], [1478091600000, null, 1099075, 610947, 928, 114362, 769, 0, 3600000], [1478095200000, null, 1306300, 405997, 509, 46359, 370, 0, 3600000]]
// in case of network info : [[st, activeTime, rb, rp, tb, tp, op, bucketDuration], [1478088000, null, null, 32115296, 34291, 2956805, 25705, 0, 3600], [1478091600, null, null, 2714683, 11821, 1420564, 12650, 0, 3600], [1478095200, null, null, 10079213, 19962, 2487705, 20015, 0, 3600], [1478098800, null, null, 4444433, 10227, 1430356, 10493, 0, 3600]]
// in case of cpu info : [[user, kernel], [0.9, 1.3]]
//
commands.getPerformanceData = function callee$0$0(packageName, dataType) {
  var dataReadTimeout = arguments.length <= 2 || arguments[2] === undefined ? 2 : arguments[2];
  var data;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        data = undefined;
        context$1$0.t0 = dataType;
        context$1$0.next = context$1$0.t0 === 'batteryinfo' ? 4 : context$1$0.t0 === 'cpuinfo' ? 8 : context$1$0.t0 === 'memoryinfo' ? 12 : context$1$0.t0 === 'networkinfo' ? 16 : 20;
        break;

      case 4:
        context$1$0.next = 6;
        return _regeneratorRuntime.awrap(this.getBatteryInfo(dataReadTimeout));

      case 6:
        data = context$1$0.sent;
        return context$1$0.abrupt('break', 21);

      case 8:
        context$1$0.next = 10;
        return _regeneratorRuntime.awrap(this.getCPUInfo(packageName, dataReadTimeout));

      case 10:
        data = context$1$0.sent;
        return context$1$0.abrupt('break', 21);

      case 12:
        context$1$0.next = 14;
        return _regeneratorRuntime.awrap(this.getMemoryInfo(packageName, dataReadTimeout));

      case 14:
        data = context$1$0.sent;
        return context$1$0.abrupt('break', 21);

      case 16:
        context$1$0.next = 18;
        return _regeneratorRuntime.awrap(this.getNetworkTrafficInfo(dataReadTimeout));

      case 18:
        data = context$1$0.sent;
        return context$1$0.abrupt('break', 21);

      case 20:
        throw new Error('No performance data of type \'' + dataType + '\' found.');

      case 21:
        return context$1$0.abrupt('return', data);

      case 22:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

helpers.getCPUInfo = function callee$0$0(packageName) {
  var dataReadTimeout = arguments.length <= 1 || arguments[1] === undefined ? 2 : arguments[1];
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    var _this = this;

    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap((0, _asyncbox.retryInterval)(dataReadTimeout, RETRY_PAUSE, function callee$1$0() {
          var cmd, data, match, user, kernel;
          return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                cmd = ['dumpsys', 'cpuinfo', '|', 'grep', '\'' + packageName + '\''];
                context$2$0.next = 3;
                return _regeneratorRuntime.awrap(this.adb.shell(cmd));

              case 3:
                data = context$2$0.sent;

                if (data) {
                  context$2$0.next = 6;
                  break;
                }

                throw new Error('No data from dumpsys');

              case 6:
                match = /(\d+)% user \+ (\d+)% kernel/.exec(data);

                if (match) {
                  context$2$0.next = 9;
                  break;
                }

                throw new Error('Unable to parse cpu data: \'' + data + '\'');

              case 9:
                user = match[1];
                kernel = match[2];
                return context$2$0.abrupt('return', [_lodash2['default'].clone(CPU_KEYS), [user, kernel]]);

              case 12:
              case 'end':
                return context$2$0.stop();
            }
          }, null, _this);
        }));

      case 2:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 3:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

helpers.getBatteryInfo = function callee$0$0() {
  var dataReadTimeout = arguments.length <= 0 || arguments[0] === undefined ? 2 : arguments[0];
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    var _this2 = this;

    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap((0, _asyncbox.retryInterval)(dataReadTimeout, RETRY_PAUSE, function callee$1$0() {
          var cmd, data, power;
          return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                cmd = ['dumpsys', 'battery', '|', 'grep', 'level'];
                context$2$0.next = 3;
                return _regeneratorRuntime.awrap(this.adb.shell(cmd));

              case 3:
                data = context$2$0.sent;

                if (data) {
                  context$2$0.next = 6;
                  break;
                }

                throw new Error('No data from dumpsys');

              case 6:
                power = parseInt((data.split(':')[1] || '').trim(), 10);

                if (_Number$isNaN(power)) {
                  context$2$0.next = 11;
                  break;
                }

                return context$2$0.abrupt('return', [_lodash2['default'].clone(BATTERY_KEYS), [power.toString()]]);

              case 11:
                throw new Error('Unable to parse battery data: \'' + data + '\'');

              case 12:
              case 'end':
                return context$2$0.stop();
            }
          }, null, _this2);
        }));

      case 2:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 3:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

helpers.getMemoryInfo = function callee$0$0(packageName) {
  var dataReadTimeout = arguments.length <= 1 || arguments[1] === undefined ? 2 : arguments[1];
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    var _this3 = this;

    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap((0, _asyncbox.retryInterval)(dataReadTimeout, RETRY_PAUSE, function callee$1$0() {
          var cmd, data, totalPrivateDirty, totalPss, nativePrivateDirty, nativePss, nativeHeapSize, nativeHeapAllocatedSize, dalvikPrivateDirty, dalvikPss, eglPrivateDirty, eglPss, glPrivateDirty, glPss, apilevel, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, line, entries, type, subType, headers, _data;

          return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                cmd = ['dumpsys', 'meminfo', '\'' + packageName + '\'', '|', 'grep', '-E', "'Native|Dalvik|EGL|GL|TOTAL'"];
                context$2$0.next = 3;
                return _regeneratorRuntime.awrap(this.adb.shell(cmd));

              case 3:
                data = context$2$0.sent;

                if (data) {
                  context$2$0.next = 6;
                  break;
                }

                throw new Error('No data from dumpsys');

              case 6:
                totalPrivateDirty = undefined, totalPss = undefined, nativePrivateDirty = undefined, nativePss = undefined, nativeHeapSize = undefined, nativeHeapAllocatedSize = undefined, dalvikPrivateDirty = undefined, dalvikPss = undefined, eglPrivateDirty = undefined, eglPss = undefined, glPrivateDirty = undefined, glPss = undefined;
                context$2$0.next = 9;
                return _regeneratorRuntime.awrap(this.adb.getApiLevel());

              case 9:
                context$2$0.t0 = context$2$0.sent;
                apilevel = parseInt(context$2$0.t0, 10);
                _iteratorNormalCompletion = true;
                _didIteratorError = false;
                _iteratorError = undefined;
                context$2$0.prev = 14;

                for (_iterator = _getIterator(data.split('\n')); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                  line = _step.value;
                  entries = line.trim().split(' ').filter(Boolean);

                  // entries will have the values
                  //   ['<System Type>', '<Memory Type>', <pss total>, <private dirty>, <private clean>, <swapPss dirty>, <heap size>, <heap alloc>, <heap free>]
                  // except 'TOTAL', which skips the second type name
                  //
                  // and on API level 18 and below
                  //   ['<System Type', '<pps>', '<shared dirty>', '<private dirty>', '<heap size>', '<heap alloc>', '<heap free>']

                  if (apilevel > 18) {
                    type = entries[0];
                    subType = entries[1];

                    if (type === 'Native' && subType === 'Heap') {
                      // native heap
                      nativePss = entries[2];
                      nativePrivateDirty = entries[3];
                      nativeHeapSize = entries[6];
                      nativeHeapAllocatedSize = entries[7];
                    } else if (type === 'Dalvik' && subType === 'Heap') {
                      // dalvik heap
                      dalvikPss = entries[2];
                      dalvikPrivateDirty = entries[3];
                    } else if (type === 'EGL' && subType === 'mtrack') {
                      // egl
                      eglPss = entries[2];
                      eglPrivateDirty = entries[3];
                    } else if (type === 'GL' && subType === 'mtrack') {
                      // gl
                      glPss = entries[2];
                      glPrivateDirty = entries[3];
                    } else if (type === 'TOTAL' && entries.length === 8) {
                      // there are two totals, and we only want the full listing, which has 8 entries
                      totalPss = entries[1];
                      totalPrivateDirty = entries[2];
                    }
                  } else {
                    type = entries[0];

                    if (type === 'Native') {
                      nativePss = entries[1];
                      nativePrivateDirty = entries[3];
                      nativeHeapSize = entries[4];
                      nativeHeapAllocatedSize = entries[5];
                    } else if (type === 'Dalvik') {
                      dalvikPss = entries[1];
                      dalvikPrivateDirty = entries[3];
                    } else if (type === 'EGL') {
                      eglPss = entries[1];
                      eglPrivateDirty = entries[3];
                    } else if (type === 'GL') {
                      glPss = entries[1];
                      glPrivateDirty = entries[3];
                    } else if (type === 'TOTAL') {
                      totalPss = entries[1];
                      totalPrivateDirty = entries[3];
                    }
                  }
                }

                context$2$0.next = 22;
                break;

              case 18:
                context$2$0.prev = 18;
                context$2$0.t1 = context$2$0['catch'](14);
                _didIteratorError = true;
                _iteratorError = context$2$0.t1;

              case 22:
                context$2$0.prev = 22;
                context$2$0.prev = 23;

                if (!_iteratorNormalCompletion && _iterator['return']) {
                  _iterator['return']();
                }

              case 25:
                context$2$0.prev = 25;

                if (!_didIteratorError) {
                  context$2$0.next = 28;
                  break;
                }

                throw _iteratorError;

              case 28:
                return context$2$0.finish(25);

              case 29:
                return context$2$0.finish(22);

              case 30:
                if (!(totalPrivateDirty && totalPrivateDirty !== 'nodex')) {
                  context$2$0.next = 36;
                  break;
                }

                headers = _lodash2['default'].clone(MEMORY_KEYS);
                _data = [totalPrivateDirty, nativePrivateDirty, dalvikPrivateDirty, eglPrivateDirty, glPrivateDirty, totalPss, nativePss, dalvikPss, eglPss, glPss, nativeHeapAllocatedSize, nativeHeapSize];
                return context$2$0.abrupt('return', [headers, _data]);

              case 36:
                throw new Error('Unable to parse memory data: \'' + data + '\'');

              case 37:
              case 'end':
                return context$2$0.stop();
            }
          }, null, _this3, [[14, 18, 22, 30], [23,, 25, 29]]);
        }));

      case 2:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 3:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

helpers.getNetworkTrafficInfo = function callee$0$0() {
  var dataReadTimeout = arguments.length <= 0 || arguments[0] === undefined ? 2 : arguments[0];
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    var _this4 = this;

    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap((0, _asyncbox.retryInterval)(dataReadTimeout, RETRY_PAUSE, function callee$1$0() {
          var returnValue, bucketDuration, bucketStart, activeTime, rxBytes, rxPackets, txBytes, txPackets, operations, cmd, data, index, fromXtstats, start, delimiter, end, pendingBytes, arrayList, j, k, returnIndex, i;
          return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                returnValue = [];
                bucketDuration = undefined, bucketStart = undefined, activeTime = undefined, rxBytes = undefined, rxPackets = undefined, txBytes = undefined, txPackets = undefined, operations = undefined;
                cmd = ['dumpsys', 'netstats'];
                context$2$0.next = 5;
                return _regeneratorRuntime.awrap(this.adb.shell(cmd));

              case 5:
                data = context$2$0.sent;

                if (data) {
                  context$2$0.next = 8;
                  break;
                }

                throw new Error('No data from dumpsys');

              case 8:
                index = 0;
                fromXtstats = data.indexOf("Xt stats:");
                start = data.indexOf("Pending bytes:", fromXtstats);
                delimiter = data.indexOf(":", start + 1);
                end = data.indexOf("\n", delimiter + 1);
                pendingBytes = data.substring(delimiter + 1, end).trim();

                if (end > delimiter) {
                  start = data.indexOf("bucketDuration", end + 1);
                  delimiter = data.indexOf("=", start + 1);
                  end = data.indexOf("\n", delimiter + 1);
                  bucketDuration = data.substring(delimiter + 1, end).trim();
                }

                if (!(start >= 0)) {
                  context$2$0.next = 33;
                  break;
                }

                data = data.substring(end + 1, data.length);
                arrayList = data.split("\n");

                if (!(arrayList.length > 0)) {
                  context$2$0.next = 33;
                  break;
                }

                start = -1;

                j = 0;

              case 21:
                if (!(j < NETWORK_KEYS.length)) {
                  context$2$0.next = 31;
                  break;
                }

                start = arrayList[0].indexOf(NETWORK_KEYS[j][0]);

                if (!(start >= 0)) {
                  context$2$0.next = 28;
                  break;
                }

                index = j;
                returnValue[0] = [];

                for (k = 0; k < NETWORK_KEYS[j].length; ++k) {
                  returnValue[0][k] = NETWORK_KEYS[j][k];
                }return context$2$0.abrupt('break', 31);

              case 28:
                ++j;
                context$2$0.next = 21;
                break;

              case 31:
                returnIndex = 1;

                for (i = 0; i < arrayList.length; i++) {
                  data = arrayList[i];
                  start = data.indexOf(NETWORK_KEYS[index][0]);

                  if (start >= 0) {
                    delimiter = data.indexOf("=", start + 1);
                    end = data.indexOf(" ", delimiter + 1);
                    bucketStart = data.substring(delimiter + 1, end).trim();

                    if (end > delimiter) {
                      start = data.indexOf(NETWORK_KEYS[index][1], end + 1);
                      if (start >= 0) {
                        delimiter = data.indexOf("=", start + 1);
                        end = data.indexOf(" ", delimiter + 1);
                        activeTime = data.substring(delimiter + 1, end).trim();
                      }
                    }

                    if (end > delimiter) {
                      start = data.indexOf(NETWORK_KEYS[index][2], end + 1);
                      if (start >= 0) {
                        delimiter = data.indexOf("=", start + 1);
                        end = data.indexOf(" ", delimiter + 1);
                        rxBytes = data.substring(delimiter + 1, end).trim();
                      }
                    }

                    if (end > delimiter) {
                      start = data.indexOf(NETWORK_KEYS[index][3], end + 1);
                      if (start >= 0) {
                        delimiter = data.indexOf("=", start + 1);
                        end = data.indexOf(" ", delimiter + 1);
                        rxPackets = data.substring(delimiter + 1, end).trim();
                      }
                    }

                    if (end > delimiter) {
                      start = data.indexOf(NETWORK_KEYS[index][4], end + 1);
                      if (start >= 0) {
                        delimiter = data.indexOf("=", start + 1);
                        end = data.indexOf(" ", delimiter + 1);
                        txBytes = data.substring(delimiter + 1, end).trim();
                      }
                    }

                    if (end > delimiter) {
                      start = data.indexOf(NETWORK_KEYS[index][5], end + 1);
                      if (start >= 0) {
                        delimiter = data.indexOf("=", start + 1);
                        end = data.indexOf(" ", delimiter + 1);
                        txPackets = data.substring(delimiter + 1, end).trim();
                      }
                    }

                    if (end > delimiter) {
                      start = data.indexOf(NETWORK_KEYS[index][6], end + 1);
                      if (start >= 0) {
                        delimiter = data.indexOf("=", start + 1);
                        end = data.length;
                        operations = data.substring(delimiter + 1, end).trim();
                      }
                    }
                    returnValue[returnIndex++] = [bucketStart, activeTime, rxBytes, rxPackets, txBytes, txPackets, operations, bucketDuration];
                  }
                }

              case 33:
                if (!(!_lodash2['default'].isEqual(pendingBytes, "") && !_lodash2['default'].isUndefined(pendingBytes) && !_lodash2['default'].isEqual(pendingBytes, "nodex"))) {
                  context$2$0.next = 37;
                  break;
                }

                return context$2$0.abrupt('return', returnValue);

              case 37:
                throw new Error('Unable to parse network traffic data: \'' + data + '\'');

              case 38:
              case 'end':
                return context$2$0.stop();
            }
          }, null, _this4);
        }));

      case 2:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 3:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

_Object$assign(extensions, commands, helpers);
exports.commands = commands;
exports.helpers = helpers;
exports.SUPPORTED_PERFORMANCE_DATA_TYPES = SUPPORTED_PERFORMANCE_DATA_TYPES;
exports.CPU_KEYS = CPU_KEYS;
exports.MEMORY_KEYS = MEMORY_KEYS;
exports.BATTERY_KEYS = BATTERY_KEYS;
exports.NETWORK_KEYS = NETWORK_KEYS;
exports['default'] = extensions;

// TODO: figure out why this is
// sometimes, the function of 'adb.shell' fails. when I tested this function on the target of 'Galaxy Note5',
// adb.shell(dumpsys cpuinfo) returns cpu datas for other application packages, but I can't find the data for packageName.
// It usually fails 30 times and success for the next time,
// Since then, he has continued to succeed.

// `data` will be something like
//    +0% 2209/io.appium.android.apis: 0% user + 0% kernel

// In case of network traffic information, it is different for the return data between emulator and real device.
// the return data of emulator
//   Xt stats:
//   Pending bytes: 39250
//   History since boot:
//   ident=[[type=WIFI, subType=COMBINED, networkId="WiredSSID"]] uid=-1 set=ALL tag=0x0
//   NetworkStatsHistory: bucketDuration=3600000
//   bucketStart=1478098800000 activeTime=31824 rxBytes=21502 rxPackets=78 txBytes=17748 txPackets=90 operations=0
//
// 7.1
//   Xt stats:
//   Pending bytes: 481487
//   History since boot:
//   ident=[{type=MOBILE, subType=COMBINED, subscriberId=310260..., metered=true}] uid=-1 set=ALL tag=0x0
//     NetworkStatsHistory: bucketDuration=3600
//       st=1483984800 rb=0 rp=0 tb=12031 tp=184 op=0
//       st=1483988400 rb=0 rp=0 tb=38476 tp=587 op=0
//       st=1483999200 rb=315616 rp=400 tb=94800 tp=362 op=0
//       st=1484002800 rb=15826 rp=20 tb=4738 tp=16 op=0
//
// the return data of real device
//   Xt stats:
//   Pending bytes: 0
//   History since boot:
//   ident=[{type=MOBILE, subType=COMBINED, subscriberId=450050...}] uid=-1 set=ALL tag=0x0
//   NetworkStatsHistory: bucketDuration=3600
//   st=1478088000 rb=32115296 rp=34291 tb=2956805 tp=25705 op=0
//   st=1478091600 rb=2714683 rp=11821 tb=1420564 tp=12650 op=0
//   st=1478095200 rb=10079213 rp=19962 tb=2487705 tp=20015 op=0
//   st=1478098800 rb=4444433 rp=10227 tb=1430356 tp=10493 op=0
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9jb21tYW5kcy9wZXJmb3JtYW5jZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O3NCQUFjLFFBQVE7Ozs7d0JBQ1EsVUFBVTs7QUFHeEMsSUFBSSxRQUFRLEdBQUcsRUFBRTtJQUFFLE9BQU8sR0FBRyxFQUFFO0lBQUUsVUFBVSxHQUFHLEVBQUUsQ0FBQzs7QUFFakQsSUFBTSxZQUFZLEdBQUcsQ0FBQyxDQUFDLGFBQWEsRUFBRSxZQUFZLEVBQUUsU0FBUyxFQUFFLFdBQVcsRUFBRSxTQUFTLEVBQUUsV0FBVyxFQUFFLFlBQVksRUFBRSxnQkFBZ0IsQ0FBQyxFQUFFLENBQUMsSUFBSSxFQUFFLFlBQVksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLGdCQUFnQixDQUFDLENBQUMsQ0FBQztBQUMzTSxJQUFNLFFBQVEsR0FBRyxDQUFDLE1BQU0sRUFBRSxRQUFRLENBQUMsQ0FBQztBQUNwQyxJQUFNLFlBQVksR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0FBQy9CLElBQU0sV0FBVyxHQUFHLENBQUMsbUJBQW1CLEVBQUUsb0JBQW9CLEVBQUUsb0JBQW9CLEVBQUUsaUJBQWlCLEVBQUUsZ0JBQWdCLEVBQUUsVUFBVSxFQUFFLFdBQVcsRUFBRSxXQUFXLEVBQUUsUUFBUSxFQUFFLE9BQU8sRUFBRSx5QkFBeUIsRUFBRSxnQkFBZ0IsQ0FBQyxDQUFDOztBQUVqTyxJQUFNLGdDQUFnQyxHQUFHO0FBQ3ZDLFNBQU8sRUFBRSxnSEFBZ0g7QUFDekgsWUFBVSxFQUFFLCtHQUErRztBQUMzSCxhQUFXLEVBQUUseUdBQXlHO0FBQ3RILGFBQVcsRUFBRSxvR0FBb0c7Q0FDbEgsQ0FBQzs7QUFFRixJQUFNLFdBQVcsR0FBRyxJQUFJLENBQUM7Ozs7Ozs7QUFPekIsUUFBUSxDQUFDLHVCQUF1QixHQUFHLFlBQVk7QUFDN0MsU0FBTyxvQkFBRSxJQUFJLENBQUMsZ0NBQWdDLENBQUMs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QVEsRUFBRSxPQUFPLENBQUMsQ0FBQztRQUNwQyxRQUFRLEdBQVIsUUFBUTtRQUFFLE9BQU8sR0FBUCxPQUFPO1FBQUUsZ0NBQWdDLEdBQWhDLGdDQUFnQztRQUFFLFFBQVEsR0FBUixRQUFRO1FBQzdELFdBQVcsR0FBWCxXQUFXO1FBQUUsWUFBWSxHQUFaLFlBQVk7UUFBRSxZQUFZLEdBQVosWUFBWTtxQkFDakMsVUFBVSIsImZpbGUiOiJsaWIvY29tbWFuZHMvcGVyZm9ybWFuY2UuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgcmV0cnlJbnRlcnZhbCB9IGZyb20gJ2FzeW5jYm94JztcblxuXG5sZXQgY29tbWFuZHMgPSB7fSwgaGVscGVycyA9IHt9LCBleHRlbnNpb25zID0ge307XG5cbmNvbnN0IE5FVFdPUktfS0VZUyA9IFtbJ2J1Y2tldFN0YXJ0JywgJ2FjdGl2ZVRpbWUnLCAncnhCeXRlcycsICdyeFBhY2tldHMnLCAndHhCeXRlcycsICd0eFBhY2tldHMnLCAnb3BlcmF0aW9ucycsICdidWNrZXREdXJhdGlvbiddLCBbJ3N0JywgJ2FjdGl2ZVRpbWUnLCAncmInLCAncnAnLCAndGInLCAndHAnLCAnb3AnLCAnYnVja2V0RHVyYXRpb24nXV07XG5jb25zdCBDUFVfS0VZUyA9IFsndXNlcicsICdrZXJuZWwnXTtcbmNvbnN0IEJBVFRFUllfS0VZUyA9IFsncG93ZXInXTtcbmNvbnN0IE1FTU9SWV9LRVlTID0gWyd0b3RhbFByaXZhdGVEaXJ0eScsICduYXRpdmVQcml2YXRlRGlydHknLCAnZGFsdmlrUHJpdmF0ZURpcnR5JywgJ2VnbFByaXZhdGVEaXJ0eScsICdnbFByaXZhdGVEaXJ0eScsICd0b3RhbFBzcycsICduYXRpdmVQc3MnLCAnZGFsdmlrUHNzJywgJ2VnbFBzcycsICdnbFBzcycsICduYXRpdmVIZWFwQWxsb2NhdGVkU2l6ZScsICduYXRpdmVIZWFwU2l6ZSddO1xuXG5jb25zdCBTVVBQT1JURURfUEVSRk9STUFOQ0VfREFUQV9UWVBFUyA9IHtcbiAgY3B1aW5mbzogJ3RoZSBhbW91bnQgb2YgY3B1IGJ5IHVzZXIgYW5kIGtlcm5lbCBwcm9jZXNzIC0gY3B1IGluZm9ybWF0aW9uIGZvciBhcHBsaWNhdGlvbnMgb24gcmVhbCBkZXZpY2VzIGFuZCBzaW11bGF0b3JzJyxcbiAgbWVtb3J5aW5mbzogJ3RoZSBhbW91bnQgb2YgbWVtb3J5IHVzZWQgYnkgdGhlIHByb2Nlc3MgLSBtZW1vcnkgaW5mb3JtYXRpb24gZm9yIGFwcGxpY2F0aW9ucyBvbiByZWFsIGRldmljZXMgYW5kIHNpbXVsYXRvcnMnLFxuICBiYXR0ZXJ5aW5mbzogJ3RoZSByZW1haW5pbmcgYmF0dGVyeSBwb3dlciAtIGJhdHRlcnkgcG93ZXIgaW5mb3JtYXRpb24gZm9yIGFwcGxpY2F0aW9ucyBvbiByZWFsIGRldmljZXMgYW5kIHNpbXVsYXRvcnMnLFxuICBuZXR3b3JraW5mbzogJ3RoZSBuZXR3b3JrIHN0YXRpc3RpY3MgLSBuZXR3b3JrIHJ4L3R4IGluZm9ybWF0aW9uIGZvciBhcHBsaWNhdGlvbnMgb24gcmVhbCBkZXZpY2VzIGFuZCBzaW11bGF0b3JzJ1xufTtcblxuY29uc3QgUkVUUllfUEFVU0UgPSAxMDAwO1xuXG4vL1xuLy8gcmV0dXJucyB0aGUgaW5mb3JtYXRpb24gdHlwZSBvZiB0aGUgc3lzdGVtIHN0YXRlIHdoaWNoIGlzIHN1cHBvcnRlZCB0byByZWFkIGFzIGxpa2UgY3B1LCBtZW1vcnksIG5ldHdvcmsgdHJhZmZpYywgYW5kIGJhdHRlcnkuXG4vLyBvdXRwdXQgLSBhcnJheSBsaWtlIGJlbG93XG4vL1tjcHVpbmZvLCBiYXR0ZXJ5aW5mbywgbmV0d29ya2luZm8sIG1lbW9yeWluZm9dXG4vL1xuY29tbWFuZHMuZ2V0UGVyZm9ybWFuY2VEYXRhVHlwZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBfLmtleXMoU1VQUE9SVEVEX1BFUkZPUk1BTkNFX0RBVEFfVFlQRVMpO1xufTtcblxuLy8gcmV0dXJucyB0aGUgaW5mb3JtYXRpb24gdHlwZSBvZiB0aGUgc3lzdGVtIHN0YXRlIHdoaWNoIGlzIHN1cHBvcnRlZCB0byByZWFkIGFzIGxpa2UgY3B1LCBtZW1vcnksIG5ldHdvcmsgdHJhZmZpYywgYW5kIGJhdHRlcnkuXG4vL2lucHV0IC0gKHBhY2thZ2VOYW1lKSB0aGUgcGFja2FnZSBuYW1lIG9mIHRoZSBhcHBsaWNhdGlvblxuLy8gICAgICAgIChkYXRhVHlwZSkgdGhlIHR5cGUgb2Ygc3lzdGVtIHN0YXRlIHdoaWNoIHdhbnRzIHRvIHJlYWQuIEl0IHNob3VsZCBiZSBvbmUgb2YgdGhlIGtleXMgb2YgdGhlIFNVUFBPUlRFRF9QRVJGT1JNQU5DRV9EQVRBX1RZUEVTXG4vLyAgICAgICAgKGRhdGFSZWFkVGltZW91dCkgdGhlIG51bWJlciBvZiBhdHRlbXB0cyB0byByZWFkXG4vLyBvdXRwdXQgLSB0YWJsZSBvZiB0aGUgcGVyZm9ybWFuY2UgZGF0YSwgVGhlIGZpcnN0IGxpbmUgb2YgdGhlIHRhYmxlIHJlcHJlc2VudHMgdGhlIHR5cGUgb2YgZGF0YS4gVGhlIHJlbWFpbmluZyBsaW5lcyByZXByZXNlbnQgdGhlIHZhbHVlcyBvZiB0aGUgZGF0YS5cbi8vXG4vLyBpbiBjYXNlIG9mIGJhdHRlcnkgaW5mbyA6IFtbcG93ZXJdLCBbMjNdXVxuLy8gaW4gY2FzZSBvZiBtZW1vcnkgaW5mbyA6ICBbW3RvdGFsUHJpdmF0ZURpcnR5LCBuYXRpdmVQcml2YXRlRGlydHksIGRhbHZpa1ByaXZhdGVEaXJ0eSwgZWdsUHJpdmF0ZURpcnR5LCBnbFByaXZhdGVEaXJ0eSwgdG90YWxQc3MsIG5hdGl2ZVBzcywgZGFsdmlrUHNzLCBlZ2xQc3MsIGdsUHNzLCBuYXRpdmVIZWFwQWxsb2NhdGVkU2l6ZSwgbmF0aXZlSGVhcFNpemVdLCBbMTgzNjAsIDgyOTYsIDYxMzIsIG51bGwsIG51bGwsIDQyNTg4LCA4NDA2LCA3MDI0LCBudWxsLCBudWxsLCAyNjUxOSwgMTAzNDRdXVxuLy8gaW4gY2FzZSBvZiBuZXR3b3JrIGluZm8gOiBbW2J1Y2tldFN0YXJ0LCBhY3RpdmVUaW1lLCByeEJ5dGVzLCByeFBhY2tldHMsIHR4Qnl0ZXMsIHR4UGFja2V0cywgb3BlcmF0aW9ucywgYnVja2V0RHVyYXRpb24sXSwgWzE0NzgwOTE2MDAwMDAsIG51bGwsIDEwOTkwNzUsIDYxMDk0NywgOTI4LCAxMTQzNjIsIDc2OSwgMCwgMzYwMDAwMF0sIFsxNDc4MDk1MjAwMDAwLCBudWxsLCAxMzA2MzAwLCA0MDU5OTcsIDUwOSwgNDYzNTksIDM3MCwgMCwgMzYwMDAwMF1dXG4vLyBpbiBjYXNlIG9mIG5ldHdvcmsgaW5mbyA6IFtbc3QsIGFjdGl2ZVRpbWUsIHJiLCBycCwgdGIsIHRwLCBvcCwgYnVja2V0RHVyYXRpb25dLCBbMTQ3ODA4ODAwMCwgbnVsbCwgbnVsbCwgMzIxMTUyOTYsIDM0MjkxLCAyOTU2ODA1LCAyNTcwNSwgMCwgMzYwMF0sIFsxNDc4MDkxNjAwLCBudWxsLCBudWxsLCAyNzE0NjgzLCAxMTgyMSwgMTQyMDU2NCwgMTI2NTAsIDAsIDM2MDBdLCBbMTQ3ODA5NTIwMCwgbnVsbCwgbnVsbCwgMTAwNzkyMTMsIDE5OTYyLCAyNDg3NzA1LCAyMDAxNSwgMCwgMzYwMF0sIFsxNDc4MDk4ODAwLCBudWxsLCBudWxsLCA0NDQ0NDMzLCAxMDIyNywgMTQzMDM1NiwgMTA0OTMsIDAsIDM2MDBdXVxuLy8gaW4gY2FzZSBvZiBjcHUgaW5mbyA6IFtbdXNlciwga2VybmVsXSwgWzAuOSwgMS4zXV1cbi8vXG5jb21tYW5kcy5nZXRQZXJmb3JtYW5jZURhdGEgPSBhc3luYyBmdW5jdGlvbiAocGFja2FnZU5hbWUsIGRhdGFUeXBlLCBkYXRhUmVhZFRpbWVvdXQgPSAyKSB7XG4gIGxldCBkYXRhO1xuICBzd2l0Y2ggKGRhdGFUeXBlKSB7XG4gICAgY2FzZSAnYmF0dGVyeWluZm8nOlxuICAgICAgZGF0YSA9IGF3YWl0IHRoaXMuZ2V0QmF0dGVyeUluZm8oZGF0YVJlYWRUaW1lb3V0KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2NwdWluZm8nOlxuICAgICAgZGF0YSA9IGF3YWl0IHRoaXMuZ2V0Q1BVSW5mbyhwYWNrYWdlTmFtZSwgZGF0YVJlYWRUaW1lb3V0KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ21lbW9yeWluZm8nOlxuICAgICAgZGF0YSA9IGF3YWl0IHRoaXMuZ2V0TWVtb3J5SW5mbyhwYWNrYWdlTmFtZSwgZGF0YVJlYWRUaW1lb3V0KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ25ldHdvcmtpbmZvJzpcbiAgICAgIGRhdGEgPSBhd2FpdCB0aGlzLmdldE5ldHdvcmtUcmFmZmljSW5mbyhkYXRhUmVhZFRpbWVvdXQpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gcGVyZm9ybWFuY2UgZGF0YSBvZiB0eXBlICcke2RhdGFUeXBlfScgZm91bmQuYCk7XG4gIH1cbiAgcmV0dXJuIGRhdGE7XG59O1xuXG5oZWxwZXJzLmdldENQVUluZm8gPSBhc3luYyBmdW5jdGlvbiAocGFja2FnZU5hbWUsIGRhdGFSZWFkVGltZW91dCA9IDIpIHtcbiAgLy8gVE9ETzogZmlndXJlIG91dCB3aHkgdGhpcyBpc1xuICAvLyBzb21ldGltZXMsIHRoZSBmdW5jdGlvbiBvZiAnYWRiLnNoZWxsJyBmYWlscy4gd2hlbiBJIHRlc3RlZCB0aGlzIGZ1bmN0aW9uIG9uIHRoZSB0YXJnZXQgb2YgJ0dhbGF4eSBOb3RlNScsXG4gIC8vIGFkYi5zaGVsbChkdW1wc3lzIGNwdWluZm8pIHJldHVybnMgY3B1IGRhdGFzIGZvciBvdGhlciBhcHBsaWNhdGlvbiBwYWNrYWdlcywgYnV0IEkgY2FuJ3QgZmluZCB0aGUgZGF0YSBmb3IgcGFja2FnZU5hbWUuXG4gIC8vIEl0IHVzdWFsbHkgZmFpbHMgMzAgdGltZXMgYW5kIHN1Y2Nlc3MgZm9yIHRoZSBuZXh0IHRpbWUsXG4gIC8vIFNpbmNlIHRoZW4sIGhlIGhhcyBjb250aW51ZWQgdG8gc3VjY2VlZC5cbiAgcmV0dXJuIGF3YWl0IHJldHJ5SW50ZXJ2YWwoZGF0YVJlYWRUaW1lb3V0LCBSRVRSWV9QQVVTRSwgYXN5bmMgKCkgPT4ge1xuICAgIGxldCBjbWQgPSBbJ2R1bXBzeXMnLCAnY3B1aW5mbycsICd8JywgJ2dyZXAnLCBgJyR7cGFja2FnZU5hbWV9J2BdO1xuICAgIGxldCBkYXRhID0gYXdhaXQgdGhpcy5hZGIuc2hlbGwoY21kKTtcbiAgICBpZiAoIWRhdGEpIHRocm93IG5ldyBFcnJvcignTm8gZGF0YSBmcm9tIGR1bXBzeXMnKTtcbiAgICAvLyBgZGF0YWAgd2lsbCBiZSBzb21ldGhpbmcgbGlrZVxuICAgIC8vICAgICswJSAyMjA5L2lvLmFwcGl1bS5hbmRyb2lkLmFwaXM6IDAlIHVzZXIgKyAwJSBrZXJuZWxcblxuICAgIGxldCBtYXRjaCA9IC8oXFxkKyklIHVzZXIgXFwrIChcXGQrKSUga2VybmVsLy5leGVjKGRhdGEpO1xuICAgIGlmICghbWF0Y2gpIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIHBhcnNlIGNwdSBkYXRhOiAnJHtkYXRhfSdgKTtcblxuICAgIGxldCB1c2VyID0gbWF0Y2hbMV07XG4gICAgbGV0IGtlcm5lbCA9IG1hdGNoWzJdO1xuICAgIHJldHVybiBbXy5jbG9uZShDUFVfS0VZUyksIFt1c2VyLCBrZXJuZWxdXTtcbiAgfSk7XG59O1xuXG5oZWxwZXJzLmdldEJhdHRlcnlJbmZvID0gYXN5bmMgZnVuY3Rpb24gKGRhdGFSZWFkVGltZW91dCA9IDIpIHtcbiAgcmV0dXJuIGF3YWl0IHJldHJ5SW50ZXJ2YWwoZGF0YVJlYWRUaW1lb3V0LCBSRVRSWV9QQVVTRSwgYXN5bmMgKCkgPT4ge1xuICAgIGxldCBjbWQgPSBbJ2R1bXBzeXMnLCAnYmF0dGVyeScsICd8JywgJ2dyZXAnLCAnbGV2ZWwnXTtcbiAgICBsZXQgZGF0YSA9IGF3YWl0IHRoaXMuYWRiLnNoZWxsKGNtZCk7XG4gICAgaWYgKCFkYXRhKSB0aHJvdyBuZXcgRXJyb3IoJ05vIGRhdGEgZnJvbSBkdW1wc3lzJyk7XG5cbiAgICBsZXQgcG93ZXIgPSBwYXJzZUludCgoZGF0YS5zcGxpdCgnOicpWzFdIHx8ICcnKS50cmltKCksIDEwKTtcblxuICAgIGlmICghTnVtYmVyLmlzTmFOKHBvd2VyKSkge1xuICAgICAgcmV0dXJuIFtfLmNsb25lKEJBVFRFUllfS0VZUyksIFtwb3dlci50b1N0cmluZygpXV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIHBhcnNlIGJhdHRlcnkgZGF0YTogJyR7ZGF0YX0nYCk7XG4gICAgfVxuICB9KTtcblxufTtcblxuaGVscGVycy5nZXRNZW1vcnlJbmZvID0gYXN5bmMgZnVuY3Rpb24gKHBhY2thZ2VOYW1lLCBkYXRhUmVhZFRpbWVvdXQgPSAyKSB7XG4gIHJldHVybiBhd2FpdCByZXRyeUludGVydmFsKGRhdGFSZWFkVGltZW91dCwgUkVUUllfUEFVU0UsIGFzeW5jICgpID0+IHtcbiAgICBsZXQgY21kID0gWydkdW1wc3lzJywgJ21lbWluZm8nLCBgJyR7cGFja2FnZU5hbWV9J2AsICd8JywgJ2dyZXAnLCAnLUUnLCBcIidOYXRpdmV8RGFsdmlrfEVHTHxHTHxUT1RBTCdcIl07XG4gICAgbGV0IGRhdGEgPSBhd2FpdCB0aGlzLmFkYi5zaGVsbChjbWQpO1xuICAgIGlmICghZGF0YSkgdGhyb3cgbmV3IEVycm9yKCdObyBkYXRhIGZyb20gZHVtcHN5cycpO1xuXG4gICAgbGV0IHRvdGFsUHJpdmF0ZURpcnR5LCB0b3RhbFBzcyxcbiAgICAgICAgbmF0aXZlUHJpdmF0ZURpcnR5LCBuYXRpdmVQc3MsIG5hdGl2ZUhlYXBTaXplLCBuYXRpdmVIZWFwQWxsb2NhdGVkU2l6ZSxcbiAgICAgICAgZGFsdmlrUHJpdmF0ZURpcnR5LCBkYWx2aWtQc3MsXG4gICAgICAgIGVnbFByaXZhdGVEaXJ0eSwgZWdsUHNzLFxuICAgICAgICBnbFByaXZhdGVEaXJ0eSwgZ2xQc3M7XG4gICAgbGV0IGFwaWxldmVsID0gcGFyc2VJbnQoYXdhaXQgdGhpcy5hZGIuZ2V0QXBpTGV2ZWwoKSwgMTApO1xuICAgIGZvciAobGV0IGxpbmUgb2YgZGF0YS5zcGxpdCgnXFxuJykpIHtcbiAgICAgIGxldCBlbnRyaWVzID0gbGluZS50cmltKCkuc3BsaXQoJyAnKS5maWx0ZXIoQm9vbGVhbik7XG4gICAgICAvLyBlbnRyaWVzIHdpbGwgaGF2ZSB0aGUgdmFsdWVzXG4gICAgICAvLyAgIFsnPFN5c3RlbSBUeXBlPicsICc8TWVtb3J5IFR5cGU+JywgPHBzcyB0b3RhbD4sIDxwcml2YXRlIGRpcnR5PiwgPHByaXZhdGUgY2xlYW4+LCA8c3dhcFBzcyBkaXJ0eT4sIDxoZWFwIHNpemU+LCA8aGVhcCBhbGxvYz4sIDxoZWFwIGZyZWU+XVxuICAgICAgLy8gZXhjZXB0ICdUT1RBTCcsIHdoaWNoIHNraXBzIHRoZSBzZWNvbmQgdHlwZSBuYW1lXG4gICAgICAvL1xuICAgICAgLy8gYW5kIG9uIEFQSSBsZXZlbCAxOCBhbmQgYmVsb3dcbiAgICAgIC8vICAgWyc8U3lzdGVtIFR5cGUnLCAnPHBwcz4nLCAnPHNoYXJlZCBkaXJ0eT4nLCAnPHByaXZhdGUgZGlydHk+JywgJzxoZWFwIHNpemU+JywgJzxoZWFwIGFsbG9jPicsICc8aGVhcCBmcmVlPiddXG5cbiAgICAgIGlmIChhcGlsZXZlbCA+IDE4KSB7XG4gICAgICAgIGxldCB0eXBlID0gZW50cmllc1swXTtcbiAgICAgICAgbGV0IHN1YlR5cGUgPSBlbnRyaWVzWzFdO1xuICAgICAgICBpZiAodHlwZSA9PT0gJ05hdGl2ZScgJiYgc3ViVHlwZSA9PT0gJ0hlYXAnKSB7XG4gICAgICAgICAgLy8gbmF0aXZlIGhlYXBcbiAgICAgICAgICBuYXRpdmVQc3MgPSBlbnRyaWVzWzJdO1xuICAgICAgICAgIG5hdGl2ZVByaXZhdGVEaXJ0eSA9IGVudHJpZXNbM107XG4gICAgICAgICAgbmF0aXZlSGVhcFNpemUgPSBlbnRyaWVzWzZdO1xuICAgICAgICAgIG5hdGl2ZUhlYXBBbGxvY2F0ZWRTaXplID0gZW50cmllc1s3XTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnRGFsdmlrJyAmJiBzdWJUeXBlID09PSAnSGVhcCcpIHtcbiAgICAgICAgICAvLyBkYWx2aWsgaGVhcFxuICAgICAgICAgIGRhbHZpa1BzcyA9IGVudHJpZXNbMl07XG4gICAgICAgICAgZGFsdmlrUHJpdmF0ZURpcnR5ID0gZW50cmllc1szXTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnRUdMJyAmJiBzdWJUeXBlID09PSAnbXRyYWNrJykge1xuICAgICAgICAgIC8vIGVnbFxuICAgICAgICAgIGVnbFBzcyA9IGVudHJpZXNbMl07XG4gICAgICAgICAgZWdsUHJpdmF0ZURpcnR5ID0gZW50cmllc1szXTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnR0wnICYmIHN1YlR5cGUgPT09ICdtdHJhY2snKSB7XG4gICAgICAgICAgLy8gZ2xcbiAgICAgICAgICBnbFBzcyA9IGVudHJpZXNbMl07XG4gICAgICAgICAgZ2xQcml2YXRlRGlydHkgPSBlbnRyaWVzWzNdO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdUT1RBTCcgJiYgZW50cmllcy5sZW5ndGggPT09IDggKSB7XG4gICAgICAgICAgLy8gdGhlcmUgYXJlIHR3byB0b3RhbHMsIGFuZCB3ZSBvbmx5IHdhbnQgdGhlIGZ1bGwgbGlzdGluZywgd2hpY2ggaGFzIDggZW50cmllc1xuICAgICAgICAgIHRvdGFsUHNzID0gZW50cmllc1sxXTtcbiAgICAgICAgICB0b3RhbFByaXZhdGVEaXJ0eSA9IGVudHJpZXNbMl07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCB0eXBlID0gZW50cmllc1swXTtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdOYXRpdmUnKSB7XG4gICAgICAgICAgbmF0aXZlUHNzID0gZW50cmllc1sxXTtcbiAgICAgICAgICBuYXRpdmVQcml2YXRlRGlydHkgPSBlbnRyaWVzWzNdO1xuICAgICAgICAgIG5hdGl2ZUhlYXBTaXplID0gZW50cmllc1s0XTtcbiAgICAgICAgICBuYXRpdmVIZWFwQWxsb2NhdGVkU2l6ZSA9IGVudHJpZXNbNV07XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ0RhbHZpaycpIHtcbiAgICAgICAgICBkYWx2aWtQc3MgPSBlbnRyaWVzWzFdO1xuICAgICAgICAgIGRhbHZpa1ByaXZhdGVEaXJ0eSA9IGVudHJpZXNbM107XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ0VHTCcpIHtcbiAgICAgICAgICBlZ2xQc3MgPSBlbnRyaWVzWzFdO1xuICAgICAgICAgIGVnbFByaXZhdGVEaXJ0eSA9IGVudHJpZXNbM107XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ0dMJykge1xuICAgICAgICAgIGdsUHNzID0gZW50cmllc1sxXTtcbiAgICAgICAgICBnbFByaXZhdGVEaXJ0eSA9IGVudHJpZXNbM107XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ1RPVEFMJykge1xuICAgICAgICAgIHRvdGFsUHNzID0gZW50cmllc1sxXTtcbiAgICAgICAgICB0b3RhbFByaXZhdGVEaXJ0eSA9IGVudHJpZXNbM107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodG90YWxQcml2YXRlRGlydHkgJiYgdG90YWxQcml2YXRlRGlydHkgIT09ICdub2RleCcpIHtcbiAgICAgIGxldCBoZWFkZXJzID0gXy5jbG9uZShNRU1PUllfS0VZUyk7XG4gICAgICBsZXQgZGF0YSA9IFt0b3RhbFByaXZhdGVEaXJ0eSwgbmF0aXZlUHJpdmF0ZURpcnR5LCBkYWx2aWtQcml2YXRlRGlydHksIGVnbFByaXZhdGVEaXJ0eSwgZ2xQcml2YXRlRGlydHksIHRvdGFsUHNzLCBuYXRpdmVQc3MsIGRhbHZpa1BzcywgZWdsUHNzLCBnbFBzcywgbmF0aXZlSGVhcEFsbG9jYXRlZFNpemUsIG5hdGl2ZUhlYXBTaXplXTtcbiAgICAgIHJldHVybiBbaGVhZGVycywgZGF0YV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIHBhcnNlIG1lbW9yeSBkYXRhOiAnJHtkYXRhfSdgKTtcbiAgICB9XG4gIH0pO1xufTtcblxuaGVscGVycy5nZXROZXR3b3JrVHJhZmZpY0luZm8gPSBhc3luYyBmdW5jdGlvbiAoZGF0YVJlYWRUaW1lb3V0ID0gMikge1xuICByZXR1cm4gYXdhaXQgcmV0cnlJbnRlcnZhbChkYXRhUmVhZFRpbWVvdXQsIFJFVFJZX1BBVVNFLCBhc3luYyAoKSA9PiB7XG4gICAgbGV0IHJldHVyblZhbHVlID0gW107XG4gICAgbGV0IGJ1Y2tldER1cmF0aW9uLCBidWNrZXRTdGFydCwgYWN0aXZlVGltZSwgcnhCeXRlcywgcnhQYWNrZXRzLCB0eEJ5dGVzLCB0eFBhY2tldHMsIG9wZXJhdGlvbnM7XG5cbiAgICBsZXQgY21kID0gWydkdW1wc3lzJywgJ25ldHN0YXRzJ107XG4gICAgbGV0IGRhdGEgPSBhd2FpdCB0aGlzLmFkYi5zaGVsbChjbWQpO1xuICAgIGlmICghZGF0YSkgdGhyb3cgbmV3IEVycm9yKCdObyBkYXRhIGZyb20gZHVtcHN5cycpO1xuXG4gICAgLy8gSW4gY2FzZSBvZiBuZXR3b3JrIHRyYWZmaWMgaW5mb3JtYXRpb24sIGl0IGlzIGRpZmZlcmVudCBmb3IgdGhlIHJldHVybiBkYXRhIGJldHdlZW4gZW11bGF0b3IgYW5kIHJlYWwgZGV2aWNlLlxuICAgIC8vIHRoZSByZXR1cm4gZGF0YSBvZiBlbXVsYXRvclxuICAgIC8vICAgWHQgc3RhdHM6XG4gICAgLy8gICBQZW5kaW5nIGJ5dGVzOiAzOTI1MFxuICAgIC8vICAgSGlzdG9yeSBzaW5jZSBib290OlxuICAgIC8vICAgaWRlbnQ9W1t0eXBlPVdJRkksIHN1YlR5cGU9Q09NQklORUQsIG5ldHdvcmtJZD1cIldpcmVkU1NJRFwiXV0gdWlkPS0xIHNldD1BTEwgdGFnPTB4MFxuICAgIC8vICAgTmV0d29ya1N0YXRzSGlzdG9yeTogYnVja2V0RHVyYXRpb249MzYwMDAwMFxuICAgIC8vICAgYnVja2V0U3RhcnQ9MTQ3ODA5ODgwMDAwMCBhY3RpdmVUaW1lPTMxODI0IHJ4Qnl0ZXM9MjE1MDIgcnhQYWNrZXRzPTc4IHR4Qnl0ZXM9MTc3NDggdHhQYWNrZXRzPTkwIG9wZXJhdGlvbnM9MFxuICAgIC8vXG4gICAgLy8gNy4xXG4gICAgLy8gICBYdCBzdGF0czpcbiAgICAvLyAgIFBlbmRpbmcgYnl0ZXM6IDQ4MTQ4N1xuICAgIC8vICAgSGlzdG9yeSBzaW5jZSBib290OlxuICAgIC8vICAgaWRlbnQ9W3t0eXBlPU1PQklMRSwgc3ViVHlwZT1DT01CSU5FRCwgc3Vic2NyaWJlcklkPTMxMDI2MC4uLiwgbWV0ZXJlZD10cnVlfV0gdWlkPS0xIHNldD1BTEwgdGFnPTB4MFxuICAgIC8vICAgICBOZXR3b3JrU3RhdHNIaXN0b3J5OiBidWNrZXREdXJhdGlvbj0zNjAwXG4gICAgLy8gICAgICAgc3Q9MTQ4Mzk4NDgwMCByYj0wIHJwPTAgdGI9MTIwMzEgdHA9MTg0IG9wPTBcbiAgICAvLyAgICAgICBzdD0xNDgzOTg4NDAwIHJiPTAgcnA9MCB0Yj0zODQ3NiB0cD01ODcgb3A9MFxuICAgIC8vICAgICAgIHN0PTE0ODM5OTkyMDAgcmI9MzE1NjE2IHJwPTQwMCB0Yj05NDgwMCB0cD0zNjIgb3A9MFxuICAgIC8vICAgICAgIHN0PTE0ODQwMDI4MDAgcmI9MTU4MjYgcnA9MjAgdGI9NDczOCB0cD0xNiBvcD0wXG4gICAgLy9cbiAgICAvLyB0aGUgcmV0dXJuIGRhdGEgb2YgcmVhbCBkZXZpY2VcbiAgICAvLyAgIFh0IHN0YXRzOlxuICAgIC8vICAgUGVuZGluZyBieXRlczogMFxuICAgIC8vICAgSGlzdG9yeSBzaW5jZSBib290OlxuICAgIC8vICAgaWRlbnQ9W3t0eXBlPU1PQklMRSwgc3ViVHlwZT1DT01CSU5FRCwgc3Vic2NyaWJlcklkPTQ1MDA1MC4uLn1dIHVpZD0tMSBzZXQ9QUxMIHRhZz0weDBcbiAgICAvLyAgIE5ldHdvcmtTdGF0c0hpc3Rvcnk6IGJ1Y2tldER1cmF0aW9uPTM2MDBcbiAgICAvLyAgIHN0PTE0NzgwODgwMDAgcmI9MzIxMTUyOTYgcnA9MzQyOTEgdGI9Mjk1NjgwNSB0cD0yNTcwNSBvcD0wXG4gICAgLy8gICBzdD0xNDc4MDkxNjAwIHJiPTI3MTQ2ODMgcnA9MTE4MjEgdGI9MTQyMDU2NCB0cD0xMjY1MCBvcD0wXG4gICAgLy8gICBzdD0xNDc4MDk1MjAwIHJiPTEwMDc5MjEzIHJwPTE5OTYyIHRiPTI0ODc3MDUgdHA9MjAwMTUgb3A9MFxuICAgIC8vICAgc3Q9MTQ3ODA5ODgwMCByYj00NDQ0NDMzIHJwPTEwMjI3IHRiPTE0MzAzNTYgdHA9MTA0OTMgb3A9MFxuICAgIGxldCBpbmRleCA9IDA7XG4gICAgbGV0IGZyb21YdHN0YXRzID0gZGF0YS5pbmRleE9mKFwiWHQgc3RhdHM6XCIpO1xuXG4gICAgbGV0IHN0YXJ0ID0gZGF0YS5pbmRleE9mKFwiUGVuZGluZyBieXRlczpcIiwgZnJvbVh0c3RhdHMpO1xuICAgIGxldCBkZWxpbWl0ZXIgPSBkYXRhLmluZGV4T2YoXCI6XCIsIHN0YXJ0ICsgMSk7XG4gICAgbGV0IGVuZCA9IGRhdGEuaW5kZXhPZihcIlxcblwiLCBkZWxpbWl0ZXIgKyAxKTtcbiAgICBsZXQgcGVuZGluZ0J5dGVzID0gZGF0YS5zdWJzdHJpbmcoZGVsaW1pdGVyICsgMSwgZW5kKS50cmltKCk7XG5cbiAgICBpZiAoZW5kID4gZGVsaW1pdGVyKXtcbiAgICAgIHN0YXJ0ID0gZGF0YS5pbmRleE9mKFwiYnVja2V0RHVyYXRpb25cIiwgZW5kICsgMSk7XG4gICAgICBkZWxpbWl0ZXIgPSBkYXRhLmluZGV4T2YoXCI9XCIsIHN0YXJ0ICsgMSk7XG4gICAgICBlbmQgPSBkYXRhLmluZGV4T2YoXCJcXG5cIiwgZGVsaW1pdGVyICsgMSk7XG4gICAgICBidWNrZXREdXJhdGlvbiA9IGRhdGEuc3Vic3RyaW5nKGRlbGltaXRlciArIDEsIGVuZCkudHJpbSgpO1xuICAgIH1cblxuICAgIGlmIChzdGFydCA+PSAwKSB7XG4gICAgICBkYXRhID0gZGF0YS5zdWJzdHJpbmcoZW5kICsgMSwgZGF0YS5sZW5ndGgpO1xuICAgICAgbGV0IGFycmF5TGlzdCA9IGRhdGEuc3BsaXQoXCJcXG5cIik7XG5cbiAgICAgIGlmIChhcnJheUxpc3QubGVuZ3RoID4gMCkge1xuICAgICAgICBzdGFydCA9IC0xO1xuXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgTkVUV09SS19LRVlTLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgc3RhcnQgPSBhcnJheUxpc3RbMF0uaW5kZXhPZihORVRXT1JLX0tFWVNbal1bMF0pO1xuXG4gICAgICAgICAgaWYgKHN0YXJ0ID49IDAgKSB7XG4gICAgICAgICAgICBpbmRleCA9IGo7XG4gICAgICAgICAgICByZXR1cm5WYWx1ZVswXSA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBrID0gMCA7IGsgPCBORVRXT1JLX0tFWVNbal0ubGVuZ3RoIDsgKysgaylcbiAgICAgICAgICAgICAgcmV0dXJuVmFsdWVbMF1ba10gPSBORVRXT1JLX0tFWVNbal1ba107XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcmV0dXJuSW5kZXggPSAxO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5TGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGRhdGEgPSBhcnJheUxpc3RbaV07XG4gICAgICAgICAgc3RhcnQgPSBkYXRhLmluZGV4T2YoTkVUV09SS19LRVlTW2luZGV4XVswXSk7XG5cbiAgICAgICAgICBpZiAoc3RhcnQgPj0gMCApIHtcbiAgICAgICAgICAgIGRlbGltaXRlciA9IGRhdGEuaW5kZXhPZihcIj1cIiwgc3RhcnQgKyAxKTtcbiAgICAgICAgICAgIGVuZCA9IGRhdGEuaW5kZXhPZihcIiBcIiwgZGVsaW1pdGVyICsgMSk7XG4gICAgICAgICAgICBidWNrZXRTdGFydCA9IGRhdGEuc3Vic3RyaW5nKGRlbGltaXRlciArIDEsIGVuZCkudHJpbSgpO1xuXG4gICAgICAgICAgICBpZiAoZW5kID4gZGVsaW1pdGVyKSB7XG4gICAgICAgICAgICAgIHN0YXJ0ID0gZGF0YS5pbmRleE9mKE5FVFdPUktfS0VZU1tpbmRleF1bMV0sIGVuZCsxKTtcbiAgICAgICAgICAgICAgaWYgKHN0YXJ0ID49IDApIHtcbiAgICAgICAgICAgICAgICBkZWxpbWl0ZXIgPSBkYXRhLmluZGV4T2YoXCI9XCIsIHN0YXJ0ICsgMSk7XG4gICAgICAgICAgICAgICAgZW5kID0gZGF0YS5pbmRleE9mKFwiIFwiLCBkZWxpbWl0ZXIgKyAxKTtcbiAgICAgICAgICAgICAgICBhY3RpdmVUaW1lID0gZGF0YS5zdWJzdHJpbmcoZGVsaW1pdGVyICsgMSwgZW5kKS50cmltKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGVuZCA+IGRlbGltaXRlcikge1xuICAgICAgICAgICAgICBzdGFydCA9IGRhdGEuaW5kZXhPZihORVRXT1JLX0tFWVNbaW5kZXhdWzJdLCBlbmQrMSk7XG4gICAgICAgICAgICAgIGlmIChzdGFydCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgZGVsaW1pdGVyID0gZGF0YS5pbmRleE9mKFwiPVwiLCBzdGFydCArIDEpO1xuICAgICAgICAgICAgICAgIGVuZCA9IGRhdGEuaW5kZXhPZihcIiBcIiwgZGVsaW1pdGVyICsgMSk7XG4gICAgICAgICAgICAgICAgcnhCeXRlcyA9IGRhdGEuc3Vic3RyaW5nKGRlbGltaXRlciArIDEsIGVuZCkudHJpbSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChlbmQgPiBkZWxpbWl0ZXIpIHtcbiAgICAgICAgICAgICAgc3RhcnQgPSBkYXRhLmluZGV4T2YoTkVUV09SS19LRVlTW2luZGV4XVszXSwgZW5kKzEpO1xuICAgICAgICAgICAgICBpZiAoc3RhcnQgPj0gMCkge1xuICAgICAgICAgICAgICAgIGRlbGltaXRlciA9IGRhdGEuaW5kZXhPZihcIj1cIiwgc3RhcnQgKyAxKTtcbiAgICAgICAgICAgICAgICBlbmQgPSBkYXRhLmluZGV4T2YoXCIgXCIsIGRlbGltaXRlciArIDEpO1xuICAgICAgICAgICAgICAgIHJ4UGFja2V0cyA9IGRhdGEuc3Vic3RyaW5nKGRlbGltaXRlciArIDEsIGVuZCkudHJpbSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChlbmQgPiBkZWxpbWl0ZXIpIHtcbiAgICAgICAgICAgICAgc3RhcnQgPSBkYXRhLmluZGV4T2YoTkVUV09SS19LRVlTW2luZGV4XVs0XSwgZW5kKzEpO1xuICAgICAgICAgICAgICBpZiAoc3RhcnQgPj0gMCkge1xuICAgICAgICAgICAgICAgIGRlbGltaXRlciA9IGRhdGEuaW5kZXhPZihcIj1cIiwgc3RhcnQgKyAxKTtcbiAgICAgICAgICAgICAgICBlbmQgPSBkYXRhLmluZGV4T2YoXCIgXCIsIGRlbGltaXRlciArIDEpO1xuICAgICAgICAgICAgICAgIHR4Qnl0ZXMgPSBkYXRhLnN1YnN0cmluZyhkZWxpbWl0ZXIgKyAxLCBlbmQpLnRyaW0oKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZW5kID4gZGVsaW1pdGVyKSB7XG4gICAgICAgICAgICAgIHN0YXJ0ID0gZGF0YS5pbmRleE9mKE5FVFdPUktfS0VZU1tpbmRleF1bNV0sIGVuZCsxKTtcbiAgICAgICAgICAgICAgaWYgKHN0YXJ0ID49IDApIHtcbiAgICAgICAgICAgICAgICBkZWxpbWl0ZXIgPSBkYXRhLmluZGV4T2YoXCI9XCIsIHN0YXJ0ICsgMSk7XG4gICAgICAgICAgICAgICAgZW5kID0gZGF0YS5pbmRleE9mKFwiIFwiLCBkZWxpbWl0ZXIgKyAxKTtcbiAgICAgICAgICAgICAgICB0eFBhY2tldHMgPSBkYXRhLnN1YnN0cmluZyhkZWxpbWl0ZXIgKyAxLCBlbmQpLnRyaW0oKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZW5kID4gZGVsaW1pdGVyKSB7XG4gICAgICAgICAgICAgIHN0YXJ0ID0gZGF0YS5pbmRleE9mKE5FVFdPUktfS0VZU1tpbmRleF1bNl0sIGVuZCsxKTtcbiAgICAgICAgICAgICAgaWYgKHN0YXJ0ID49IDApIHtcbiAgICAgICAgICAgICAgICBkZWxpbWl0ZXIgPSBkYXRhLmluZGV4T2YoXCI9XCIsIHN0YXJ0ICsgMSk7XG4gICAgICAgICAgICAgICAgZW5kID0gZGF0YS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9ucyA9IGRhdGEuc3Vic3RyaW5nKGRlbGltaXRlciArIDEsIGVuZCkudHJpbSgpO1xuXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVyblZhbHVlW3JldHVybkluZGV4ICsrXSA9IFtidWNrZXRTdGFydCwgYWN0aXZlVGltZSwgcnhCeXRlcywgcnhQYWNrZXRzLCB0eEJ5dGVzLCB0eFBhY2tldHMsIG9wZXJhdGlvbnMsIGJ1Y2tldER1cmF0aW9uXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoICFfLmlzRXF1YWwocGVuZGluZ0J5dGVzLCBcIlwiKSAmJiAhXy5pc1VuZGVmaW5lZChwZW5kaW5nQnl0ZXMpICYmICFfLmlzRXF1YWwocGVuZGluZ0J5dGVzLCBcIm5vZGV4XCIpICkge1xuICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBwYXJzZSBuZXR3b3JrIHRyYWZmaWMgZGF0YTogJyR7ZGF0YX0nYCk7XG4gICAgfVxuICB9KTtcbn07XG5cbk9iamVjdC5hc3NpZ24oZXh0ZW5zaW9ucywgY29tbWFuZHMsIGhlbHBlcnMpO1xuZXhwb3J0IHsgY29tbWFuZHMsIGhlbHBlcnMsIFNVUFBPUlRFRF9QRVJGT1JNQU5DRV9EQVRBX1RZUEVTLCBDUFVfS0VZUyxcbiAgICAgICAgIE1FTU9SWV9LRVlTLCBCQVRURVJZX0tFWVMsIE5FVFdPUktfS0VZUyB9O1xuZXhwb3J0IGRlZmF1bHQgZXh0ZW5zaW9ucztcbiJdLCJzb3VyY2VSb290IjoiLi4vLi4vLi4ifQ==
