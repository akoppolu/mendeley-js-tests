'use strict';

var _slicedToArray = require('babel-runtime/helpers/sliced-to-array')['default'];

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _getIterator = require('babel-runtime/core-js/get-iterator')['default'];

var _Object$assign = require('babel-runtime/core-js/object/assign')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _appiumBaseDriver = require('appium-base-driver');

var _appiumSupport = require('appium-support');

var _appiumIosDriver = require('appium-ios-driver');

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _logger = require('../logger');

var _logger2 = _interopRequireDefault(_logger);

var helpers = {},
    extensions = {},
    commands = {};

commands.moveTo = _appiumIosDriver.iosCommands.gesture.moveTo;

commands.click = function callee$0$0(el) {
  var atomsElement;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        if (this.isWebContext()) {
          context$1$0.next = 4;
          break;
        }

        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(this.nativeClick(el));

      case 3:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 4:
        el = _appiumSupport.util.unwrapElement(el);

        if (!(this.opts.nativeWebTap && !this.isRealDevice())) {
          context$1$0.next = 10;
          break;
        }

        context$1$0.next = 8;
        return _regeneratorRuntime.awrap(this.nativeWebTap(el));

      case 8:
        context$1$0.next = 14;
        break;

      case 10:
        atomsElement = this.useAtomsElement(el);
        context$1$0.next = 13;
        return _regeneratorRuntime.awrap(this.executeAtom('click', [atomsElement]));

      case 13:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 14:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

function isSameGestures(gestures, candidates) {
  try {
    if (gestures.length !== candidates.length) {
      return false;
    }
    for (var i = 0; i < gestures.length; i++) {
      var gestureObj = gestures[i];
      var candidateObj = candidates[i];
      if (!_lodash2['default'].isPlainObject(gestureObj) || !_lodash2['default'].isPlainObject(candidateObj)) {
        return false;
      }
      if (_lodash2['default'].difference(_lodash2['default'].keys(candidateObj), _lodash2['default'].keys(gestureObj)).length) {
        return false;
      }
      if (gestureObj.action.toLowerCase() !== candidateObj.action.toLowerCase()) {
        return false;
      }
      if (candidateObj.options && gestureObj.options.count !== candidateObj.options.count) {
        return false;
      }
    }
  } catch (err) {
    _logger2['default'].debug('Error "' + err.message + '" while comparing gestures. Considering them as not equal');
    return false;
  }
  return true;
}

function gesturesChainToString(gestures) {
  var keysToInclude = arguments.length <= 1 || arguments[1] === undefined ? ['options'] : arguments[1];

  return gestures.map(function (item) {
    var otherKeys = _lodash2['default'].difference(_lodash2['default'].keys(item), ['action']);
    otherKeys = _lodash2['default'].isArray(keysToInclude) ? _lodash2['default'].intersection(otherKeys, keysToInclude) : otherKeys;
    if (otherKeys.length) {
      return '' + item.action + ('(' + _lodash2['default'].map(otherKeys, function (x) {
        return x + '=' + (_lodash2['default'].isPlainObject(item[x]) ? JSON.stringify(item[x]) : item[x]);
      }).join(', ') + ')');
    }
    return item.action;
  }).join('-');
}

commands.performTouch = function callee$0$0(gestures) {
  var supportedGesturesMapping, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _step$value, cmd, info, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, candidateMatch, availableGestures, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, _step2$value, _iteratorNormalCompletion4, _didIteratorError4, _iteratorError4, _iterator4, _step4;

  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    var _this = this;

    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _logger2['default'].debug('Received the following touch action: ' + gesturesChainToString(gestures));

        supportedGesturesMapping = {
          doubleTap: {
            handler: function handler(x) {
              return _regeneratorRuntime.async(function handler$(context$2$0) {
                while (1) switch (context$2$0.prev = context$2$0.next) {
                  case 0:
                    context$2$0.next = 2;
                    return _regeneratorRuntime.awrap(this.handleDoubleTap(x));

                  case 2:
                  case 'end':
                    return context$2$0.stop();
                }
              }, null, _this);
            },
            matches: [[{ action: 'doubletap' }], [{ action: 'tap', options: { count: 2 } }]]
          },
          tap: {
            handler: function handler(x) {
              return _regeneratorRuntime.async(function handler$(context$2$0) {
                while (1) switch (context$2$0.prev = context$2$0.next) {
                  case 0:
                    context$2$0.next = 2;
                    return _regeneratorRuntime.awrap(this.handleTap(x[0]));

                  case 2:
                  case 'end':
                    return context$2$0.stop();
                }
              }, null, _this);
            },
            matches: [[{ action: 'tap' }], [{ action: 'tap' }, { action: 'release' }], [{ action: 'press' }, { action: 'release' }]]
          },
          longPress: {
            handler: function handler(x) {
              return _regeneratorRuntime.async(function handler$(context$2$0) {
                while (1) switch (context$2$0.prev = context$2$0.next) {
                  case 0:
                    context$2$0.next = 2;
                    return _regeneratorRuntime.awrap(this.handleLongPress(x));

                  case 2:
                  case 'end':
                    return context$2$0.stop();
                }
              }, null, _this);
            },
            matches: [[{ action: 'longpress' }], [{ action: 'longpress' }, { action: 'release' }], [{ action: 'press' }, { action: 'wait' }, { action: 'release' }]]
          },
          drag: {
            handler: function handler(x) {
              return _regeneratorRuntime.async(function handler$(context$2$0) {
                while (1) switch (context$2$0.prev = context$2$0.next) {
                  case 0:
                    context$2$0.next = 2;
                    return _regeneratorRuntime.awrap(this.handleDrag(x));

                  case 2:
                  case 'end':
                    return context$2$0.stop();
                }
              }, null, _this);
            },
            matches: [[{ action: 'press' }, { action: 'wait' }, { action: 'moveTo' }, { action: 'release' }], [{ action: 'longpress' }, { action: 'moveTo' }, { action: 'release' }]]
          },
          scroll: {
            handler: function handler(x) {
              return _regeneratorRuntime.async(function handler$(context$2$0) {
                while (1) switch (context$2$0.prev = context$2$0.next) {
                  case 0:
                    context$2$0.next = 2;
                    return _regeneratorRuntime.awrap(this.handleScroll(x));

                  case 2:
                  case 'end':
                    return context$2$0.stop();
                }
              }, null, _this);
            },
            matches: [[{ action: 'press' }, { action: 'moveTo' }, { action: 'release' }]]
          }
        };
        _iteratorNormalCompletion = true;
        _didIteratorError = false;
        _iteratorError = undefined;
        context$1$0.prev = 5;
        _iterator = _getIterator(_lodash2['default'].toPairs(supportedGesturesMapping));

      case 7:
        if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
          context$1$0.next = 43;
          break;
        }

        _step$value = _slicedToArray(_step.value, 2);
        cmd = _step$value[0];
        info = _step$value[1];
        _iteratorNormalCompletion3 = true;
        _didIteratorError3 = false;
        _iteratorError3 = undefined;
        context$1$0.prev = 14;
        _iterator3 = _getIterator(info.matches);

      case 16:
        if (_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done) {
          context$1$0.next = 26;
          break;
        }

        candidateMatch = _step3.value;

        if (!isSameGestures(gestures, candidateMatch)) {
          context$1$0.next = 23;
          break;
        }

        _logger2['default'].debug('Found matching gesture: ' + cmd);
        context$1$0.next = 22;
        return _regeneratorRuntime.awrap(info.handler(gestures));

      case 22:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 23:
        _iteratorNormalCompletion3 = true;
        context$1$0.next = 16;
        break;

      case 26:
        context$1$0.next = 32;
        break;

      case 28:
        context$1$0.prev = 28;
        context$1$0.t0 = context$1$0['catch'](14);
        _didIteratorError3 = true;
        _iteratorError3 = context$1$0.t0;

      case 32:
        context$1$0.prev = 32;
        context$1$0.prev = 33;

        if (!_iteratorNormalCompletion3 && _iterator3['return']) {
          _iterator3['return']();
        }

      case 35:
        context$1$0.prev = 35;

        if (!_didIteratorError3) {
          context$1$0.next = 38;
          break;
        }

        throw _iteratorError3;

      case 38:
        return context$1$0.finish(35);

      case 39:
        return context$1$0.finish(32);

      case 40:
        _iteratorNormalCompletion = true;
        context$1$0.next = 7;
        break;

      case 43:
        context$1$0.next = 49;
        break;

      case 45:
        context$1$0.prev = 45;
        context$1$0.t1 = context$1$0['catch'](5);
        _didIteratorError = true;
        _iteratorError = context$1$0.t1;

      case 49:
        context$1$0.prev = 49;
        context$1$0.prev = 50;

        if (!_iteratorNormalCompletion && _iterator['return']) {
          _iterator['return']();
        }

      case 52:
        context$1$0.prev = 52;

        if (!_didIteratorError) {
          context$1$0.next = 55;
          break;
        }

        throw _iteratorError;

      case 55:
        return context$1$0.finish(52);

      case 56:
        return context$1$0.finish(49);

      case 57:
        availableGestures = '';
        _iteratorNormalCompletion2 = true;
        _didIteratorError2 = false;
        _iteratorError2 = undefined;
        context$1$0.prev = 61;
        _iterator2 = _getIterator(_lodash2['default'].toPairs(supportedGesturesMapping));

      case 63:
        if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
          context$1$0.next = 90;
          break;
        }

        _step2$value = _slicedToArray(_step2.value, 2);
        cmd = _step2$value[0];
        info = _step2$value[1];

        availableGestures += '\t' + cmd + ': ';
        _iteratorNormalCompletion4 = true;
        _didIteratorError4 = false;
        _iteratorError4 = undefined;
        context$1$0.prev = 71;
        for (_iterator4 = _getIterator(info.matches); !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          candidateMatch = _step4.value;

          availableGestures += '\t\t' + gesturesChainToString(candidateMatch) + '\n';
        }
        context$1$0.next = 79;
        break;

      case 75:
        context$1$0.prev = 75;
        context$1$0.t2 = context$1$0['catch'](71);
        _didIteratorError4 = true;
        _iteratorError4 = context$1$0.t2;

      case 79:
        context$1$0.prev = 79;
        context$1$0.prev = 80;

        if (!_iteratorNormalCompletion4 && _iterator4['return']) {
          _iterator4['return']();
        }

      case 82:
        context$1$0.prev = 82;

        if (!_didIteratorError4) {
          context$1$0.next = 85;
          break;
        }

        throw _iteratorError4;

      case 85:
        return context$1$0.finish(82);

      case 86:
        return context$1$0.finish(79);

      case 87:
        _iteratorNormalCompletion2 = true;
        context$1$0.next = 63;
        break;

      case 90:
        context$1$0.next = 96;
        break;

      case 92:
        context$1$0.prev = 92;
        context$1$0.t3 = context$1$0['catch'](61);
        _didIteratorError2 = true;
        _iteratorError2 = context$1$0.t3;

      case 96:
        context$1$0.prev = 96;
        context$1$0.prev = 97;

        if (!_iteratorNormalCompletion2 && _iterator2['return']) {
          _iterator2['return']();
        }

      case 99:
        context$1$0.prev = 99;

        if (!_didIteratorError2) {
          context$1$0.next = 102;
          break;
        }

        throw _iteratorError2;

      case 102:
        return context$1$0.finish(99);

      case 103:
        return context$1$0.finish(96);

      case 104:
        throw new _appiumBaseDriver.errors.NotYetImplementedError('Support for ' + gesturesChainToString(gestures) + ' gesture is not implemented. ' + 'Try to use "mobile: *" interface to workaround the issue. ' + ('Only these gestures are supported:\n' + availableGestures));

      case 105:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[5, 45, 49, 57], [14, 28, 32, 40], [33,, 35, 39], [50,, 52, 56], [61, 92, 96, 104], [71, 75, 79, 87], [80,, 82, 86], [97,, 99, 103]]);
};

commands.performMultiAction = function callee$0$0(actions) {
  var i;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _logger2['default'].debug('Received the following multi touch action:');
        for (i in actions) {
          _logger2['default'].debug('    ' + (i + 1) + ': ' + _lodash2['default'].map(actions[i], 'action').join('-'));
        }

        if (!isPinchOrZoom(actions)) {
          context$1$0.next = 6;
          break;
        }

        context$1$0.next = 5;
        return _regeneratorRuntime.awrap(this.handlePinchOrZoom(actions));

      case 5:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 6:
        throw new _appiumBaseDriver.errors.NotYetImplementedError('Support for this multi-action is not implemented. Try to use "mobile: *" interface to workaround the issue.');

      case 7:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

commands.nativeClick = function callee$0$0(el) {
  var endpoint;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        el = _appiumSupport.util.unwrapElement(el);
        endpoint = '/element/' + el + '/click';
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(this.proxyCommand(endpoint, 'POST', {}));

      case 4:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 5:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

function isScroll(gestures) {
  if (gestures.length === 3 && gestures[0].action === 'press' && gestures[1].action === 'moveTo' && gestures[2].action === 'release') {
    return true;
  }
  return false;
}

function isPinchOrZoom() {
  var actions = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];

  // symmetric two-finger action consisting of press-moveto-release
  if (actions.length === 2) {
    if (actions[0].length === 3 && actions[1].length === 3) {
      return _lodash2['default'].every(actions, function (gestures) {
        return isScroll(gestures);
      });
    }
  }
  return false;
}

helpers.handleScroll = function callee$0$0(gestures) {
  var dragGestures;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        if (!gestures[1].options.element) {
          context$1$0.next = 4;
          break;
        }

        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(this.mobileScroll({
          element: gestures[1].options.element,
          toVisible: true
        }));

      case 3:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 4:
        dragGestures = [gestures[0], { action: 'wait', options: { ms: 0 } }, gestures[1], gestures[2]];
        context$1$0.next = 7;
        return _regeneratorRuntime.awrap(this.handleDrag(dragGestures));

      case 7:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 8:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

helpers.handleDrag = function callee$0$0(gestures) {
  var press, wait, moveTo, pressCoordinates, duration, moveToCoordinates, params, endpoint;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        press = undefined, wait = undefined, moveTo = undefined;

        if (gestures[0].action === 'longpress') {
          press = gestures[0];
          wait = { action: 'wait', options: { ms: press.options.duration } };
          moveTo = gestures[1];
        } else {
          press = gestures[0];
          wait = gestures[1];
          moveTo = gestures[2];
        }

        // get drag data
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(this.getCoordinates(press));

      case 4:
        pressCoordinates = context$1$0.sent;
        duration = parseInt(wait.options.ms, 10) / 1000;
        context$1$0.next = 8;
        return _regeneratorRuntime.awrap(this.getCoordinates(moveTo));

      case 8:
        moveToCoordinates = context$1$0.sent;

        // update moveTo coordinates with offset
        moveToCoordinates = this.applyMoveToOffset(pressCoordinates, moveToCoordinates);

        // build drag command
        params = {};

        params.fromX = pressCoordinates.x;
        params.fromY = pressCoordinates.y;
        params.toX = moveToCoordinates.x;
        params.toY = moveToCoordinates.y;
        params.duration = duration;

        endpoint = '/wda/dragfromtoforduration';
        context$1$0.next = 19;
        return _regeneratorRuntime.awrap(this.proxyCommand(endpoint, 'POST', params));

      case 19:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 20:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

helpers.handleTap = function callee$0$0(gesture) {
  var options, params, el, endpoint;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        options = gesture.options || {};
        params = {};

        if (_appiumSupport.util.hasValue(options.x) && _appiumSupport.util.hasValue(options.y)) {
          params.x = options.x;
          params.y = options.y;
        }

        el = _appiumSupport.util.hasValue(options.element) ? options.element : '0';
        endpoint = '/wda/tap/' + el;

        if (_appiumSupport.util.hasValue(this.opts.tapWithShortPressDuration)) {
          // in some cases `tap` is too slow, so allow configurable long press
          _logger2['default'].debug('Translating tap into long press with \'' + this.opts.tapWithShortPressDuration + '\' duration');
          params.duration = parseFloat(this.opts.tapWithShortPressDuration);
          endpoint = '/wda/element/' + el + '/touchAndHold';
          params.duration = parseFloat(this.opts.tapWithShortPressDuration);
        }

        context$1$0.next = 8;
        return _regeneratorRuntime.awrap(this.proxyCommand(endpoint, 'POST', params));

      case 8:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 9:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

helpers.handleDoubleTap = function callee$0$0(gestures) {
  var gesture, opts, el, endpoint;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        gesture = gestures[0];
        opts = gesture.options || {};

        if (!opts.element) {
          _logger2['default'].errorAndThrow('WDA double tap needs an element');
        }

        el = _appiumSupport.util.unwrapElement(opts.element);
        endpoint = '/wda/element/' + el + '/doubleTap';
        context$1$0.next = 7;
        return _regeneratorRuntime.awrap(this.proxyCommand(endpoint, 'POST'));

      case 7:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 8:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

helpers.handleLongPress = function callee$0$0(gestures) {
  var pressOpts, el, duration, params, endpoint;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        pressOpts = _lodash2['default'].isPlainObject(gestures[0].options) ? gestures[0].options : {};
        el = _appiumSupport.util.unwrapElement(pressOpts.element);
        duration = undefined;
        // In seconds (not milliseconds)
        if (_appiumSupport.util.hasValue(pressOpts.duration)) {
          duration = pressOpts.duration / 1000;
        } else if (gestures.length === 3 && gestures[1].action === 'wait') {
          // duration is the `wait` action
          // upstream system expects seconds not milliseconds
          duration = parseFloat(gestures[1].options.ms) / 1000;
        } else {
          // give a sane default duration
          duration = 0.8;
        }

        params = {
          duration: duration,
          x: pressOpts.x,
          y: pressOpts.y
        };
        endpoint = undefined;

        if (el) {
          endpoint = '/wda/element/' + el + '/touchAndHold';
        } else {
          params.x = pressOpts.x;
          params.y = pressOpts.y;

          endpoint = '/wda/touchAndHold';
        }
        context$1$0.next = 9;
        return _regeneratorRuntime.awrap(this.proxyCommand(endpoint, 'POST', params));

      case 9:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 10:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

function determinePinchScale(x, y, pinch) {
  var scale = x > y ? x - y : y - x;
  if (pinch) {
    // TODO: revisit this when pinching actually works, since it is impossible to
    // know what the scale factor does at this point (Xcode 8.1)
    scale = 1 / scale;
    if (scale < 0.02) {
      // this is the minimum that Apple will allow
      // but WDA will not throw an error if it is too low
      scale = 0.02;
    }
  } else {
    // for zoom, each 10px is one scale factor
    scale = scale / 10;
  }
  return scale;
}

helpers.handlePinchOrZoom = function callee$0$0(actions) {
  var el, scale, velocity, thumb, forefinger, params;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        // currently we can only do this action on an element
        if (!actions[0][0].options.element || actions[0][0].options.element !== actions[1][0].options.element) {
          _logger2['default'].errorAndThrow('Pinch/zoom actions must be done on a single element');
        }
        el = actions[0][0].options.element;
        scale = undefined, velocity = undefined;

        if (actions[0][0].options.y === actions[0][1].options.y) {
          thumb = actions[0][0].options.x <= actions[1][0].options.x ? actions[0] : actions[1];

          // now decipher pinch vs. zoom,
          //   pinch: thumb moving from left to right
          //   zoom: thumb moving from right to left
          scale = determinePinchScale(thumb[0].options.x, thumb[1].options.x, thumb[0].options.x <= thumb[1].options.x);
        } else {
          forefinger = actions[0][0].options.y <= actions[1][0].options.y ? actions[0] : actions[1];

          // now decipher pinch vs. zoom
          //   pinch: forefinger moving from top to bottom
          //   zoom: forefinger moving from bottom to top
          scale = determinePinchScale(forefinger[0].options.y, forefinger[1].options.y, forefinger[0].options.y <= forefinger[1].options.y);
        }
        velocity = scale < 1 ? -1 : 1;

        _logger2['default'].debug('Decoded ' + (scale < 1 ? 'pinch' : 'zoom') + ' action with scale \'' + scale + '\' and velocity \'' + velocity + '\'');
        if (scale < 1) {
          _logger2['default'].warn('Pinch actions may not work, due to Apple issue.');
        }

        params = {
          scale: scale,
          velocity: velocity
        };
        context$1$0.next = 10;
        return _regeneratorRuntime.awrap(this.proxyCommand('/wda/element/' + el + '/pinch', 'POST', params));

      case 10:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/*
 * See https://github.com/facebook/WebDriverAgent/blob/master/WebDriverAgentLib/Commands/FBElementCommands.m
 * to get the info about available WDA gestures API
 *
 * See https://developer.apple.com/reference/xctest/xcuielement and
 * https://developer.apple.com/reference/xctest/xcuicoordinate to get the detailed description of
 * all XCTest gestures
*/

helpers.mobileScroll = function callee$0$0() {
  var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
  var swipe = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
  var params, msg, element, endpoint;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        if (opts.element) {
          context$1$0.next = 4;
          break;
        }

        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(this.findNativeElementOrElements('class name', 'XCUIElementTypeApplication', false));

      case 3:
        opts.element = context$1$0.sent;

      case 4:
        params = {};

        if (opts.name && !swipe) {
          params.name = opts.name;
        } else if (opts.direction) {
          if (['up', 'down', 'left', 'right'].indexOf(opts.direction.toLowerCase()) < 0) {
            msg = 'Direction must be up, down, left or right';

            _logger2['default'].errorAndThrow(msg);
          }
          params.direction = opts.direction;
        } else if (opts.predicateString && !swipe) {
          params.predicateString = opts.predicateString;
        } else if (opts.toVisible && !swipe) {
          params.toVisible = opts.toVisible;
        } else {
          msg = swipe ? 'Mobile swipe requires direction' : 'Mobile scroll supports the following strategies: name, direction, predicateString, and toVisible. Specify one of these';

          _logger2['default'].errorAndThrow(msg);
        }

        element = opts.element.ELEMENT || opts.element;
        endpoint = '/wda/element/' + element + '/' + (swipe ? 'swipe' : 'scroll');
        context$1$0.next = 10;
        return _regeneratorRuntime.awrap(this.proxyCommand(endpoint, 'POST', params));

      case 10:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 11:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

function parseFloatParameter(paramName, paramValue, methodName) {
  if (_lodash2['default'].isUndefined(paramValue)) {
    _logger2['default'].errorAndThrow('"' + paramName + '" parameter is mandatory for "' + methodName + '" call');
  }
  var result = parseFloat(paramValue);
  if (isNaN(result)) {
    _logger2['default'].errorAndThrow('"' + paramName + '" parameter should be a valid number. "' + paramValue + '" is given instead');
  }
  return result;
}

helpers.mobilePinch = function callee$0$0() {
  var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
  var params, el;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        if (opts.element) {
          context$1$0.next = 4;
          break;
        }

        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(this.findNativeElementOrElements('class name', 'XCUIElementTypeApplication', false));

      case 3:
        opts.element = context$1$0.sent;

      case 4:
        params = {
          scale: parseFloatParameter('scale', opts.scale, 'pinch'),
          velocity: parseFloatParameter('velocity', opts.velocity, 'pinch')
        };
        el = opts.element.ELEMENT || opts.element;
        context$1$0.next = 8;
        return _regeneratorRuntime.awrap(this.proxyCommand('/wda/element/' + el + '/pinch', 'POST', params));

      case 8:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 9:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

helpers.mobileDoubleTap = function callee$0$0() {
  var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
  var el, params;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        if (!opts.element) {
          context$1$0.next = 5;
          break;
        }

        el = opts.element.ELEMENT || opts.element;
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(this.proxyCommand('/wda/element/' + el + '/doubleTap', 'POST'));

      case 4:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 5:
        params = {
          x: parseFloatParameter('x', opts.x, 'doubleTap'),
          y: parseFloatParameter('y', opts.y, 'doubleTap')
        };
        context$1$0.next = 8;
        return _regeneratorRuntime.awrap(this.proxyCommand('/wda/doubleTap', 'POST', params));

      case 8:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 9:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

helpers.mobileTwoFingerTap = function callee$0$0() {
  var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
  var el;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        if (opts.element) {
          context$1$0.next = 4;
          break;
        }

        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(this.findNativeElementOrElements('class name', 'XCUIElementTypeApplication', false));

      case 3:
        opts.element = context$1$0.sent;

      case 4:
        el = opts.element.ELEMENT || opts.element;
        context$1$0.next = 7;
        return _regeneratorRuntime.awrap(this.proxyCommand('/wda/element/' + el + '/twoFingerTap', 'POST'));

      case 7:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 8:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

helpers.mobileTouchAndHold = function callee$0$0() {
  var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
  var params, el;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        params = {
          duration: parseFloatParameter('duration', opts.duration, 'touchAndHold')
        };

        if (!opts.element) {
          context$1$0.next = 6;
          break;
        }

        el = opts.element.ELEMENT || opts.element;
        context$1$0.next = 5;
        return _regeneratorRuntime.awrap(this.proxyCommand('/wda/element/' + el + '/touchAndHold', 'POST', params));

      case 5:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 6:
        // Long tap coordinates
        params.x = parseFloatParameter('x', opts.x, 'touchAndHold');
        params.y = parseFloatParameter('y', opts.y, 'touchAndHold');
        context$1$0.next = 10;
        return _regeneratorRuntime.awrap(this.proxyCommand('/wda/touchAndHold', 'POST', params));

      case 10:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 11:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

helpers.mobileTap = function callee$0$0() {
  var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
  var params, el;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        params = {
          x: parseFloatParameter('x', opts.x, 'tap'),
          y: parseFloatParameter('y', opts.y, 'tap')
        };
        el = opts.element ? opts.element.ELEMENT || opts.element : '0';
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(this.proxyCommand('/wda/tap/' + el, 'POST', params));

      case 4:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 5:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

helpers.mobileDragFromToForDuration = function callee$0$0() {
  var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
  var params, el;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        params = {
          duration: parseFloatParameter('duration', opts.duration, 'dragFromToForDuration'),
          fromX: parseFloatParameter('fromX', opts.fromX, 'dragFromToForDuration'),
          fromY: parseFloatParameter('fromY', opts.fromY, 'dragFromToForDuration'),
          toX: parseFloatParameter('toX', opts.toX, 'dragFromToForDuration'),
          toY: parseFloatParameter('toY', opts.toY, 'dragFromToForDuration')
        };

        if (!opts.element) {
          context$1$0.next = 6;
          break;
        }

        el = opts.element.ELEMENT || opts.element;
        context$1$0.next = 5;
        return _regeneratorRuntime.awrap(this.proxyCommand('/wda/element/' + el + '/dragfromtoforduration', 'POST', params));

      case 5:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 6:
        context$1$0.next = 8;
        return _regeneratorRuntime.awrap(this.proxyCommand('/wda/dragfromtoforduration', 'POST', params));

      case 8:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 9:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

helpers.mobileSelectPickerWheelValue = function callee$0$0() {
  var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
  var el, params;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        if (!opts.element) {
          _logger2['default'].errorAndThrow('Element id is expected to be set for selectPickerWheelValue method');
        }
        if (!_lodash2['default'].isString(opts.order) || ['next', 'previous'].indexOf(opts.order.toLowerCase()) === -1) {
          _logger2['default'].errorAndThrow('The mandatory "order" parameter is expected to be equal either to \'next\' or \'previous\'. ' + ('\'' + opts.order + '\' is given instead'));
        }
        el = opts.element.ELEMENT || opts.element;
        params = { order: opts.order };

        if (opts.offset) {
          params.offset = parseFloatParameter('offset', opts.offset, 'selectPickerWheelValue');
        }
        context$1$0.next = 7;
        return _regeneratorRuntime.awrap(this.proxyCommand('/wda/pickerwheel/' + el + '/select', 'POST', params));

      case 7:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 8:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

helpers.getCoordinates = function callee$0$0(gesture) {
  var el, coordinates, optionX, optionY, rect, pos, size, offsetX, offsetY;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        el = gesture.options.element;
        coordinates = { x: 0, y: 0, areOffsets: false };
        optionX = null;

        if (gesture.options.x) {
          optionX = parseFloatParameter('x', gesture.options.x, 'getCoordinates');
        }
        optionY = null;

        if (gesture.options.y) {
          optionY = parseFloatParameter('y', gesture.options.y, 'getCoordinates');
        }

        // figure out the element coordinates.

        if (!el) {
          context$1$0.next = 19;
          break;
        }

        context$1$0.next = 9;
        return _regeneratorRuntime.awrap(this.getRect(el));

      case 9:
        rect = context$1$0.sent;
        pos = { x: rect.x, y: rect.y };
        size = { w: rect.width, h: rect.height };
        offsetX = 0;
        offsetY = 0;

        // get the real offsets
        if (optionX || optionY) {
          offsetX = optionX || 0;
          offsetY = optionY || 0;
        } else {
          offsetX = size.w / 2;
          offsetY = size.h / 2;
        }

        // apply the offsets
        coordinates.x = pos.x + offsetX;
        coordinates.y = pos.y + offsetY;
        context$1$0.next = 22;
        break;

      case 19:
        // moveTo coordinates are passed in as offsets
        coordinates.areOffsets = gesture.action === 'moveTo';
        coordinates.x = optionX || 0;
        coordinates.y = optionY || 0;

      case 22:
        return context$1$0.abrupt('return', coordinates);

      case 23:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

helpers.applyMoveToOffset = function (firstCoordinates, secondCoordinates) {
  if (secondCoordinates.areOffsets) {
    return {
      x: firstCoordinates.x + secondCoordinates.x,
      y: firstCoordinates.y + secondCoordinates.y
    };
  } else {
    return secondCoordinates;
  }
};

_Object$assign(extensions, helpers, commands);
exports.extensions = extensions;
exports.helpers = helpers;
exports.commands = commands;
exports.isSameGestures = isSameGestures;
exports.gesturesChainToString = gesturesChainToString;
exports['default'] = extensions;

// there are multiple commands that map here, so manually proxy

// atoms-based clicks don't always work in safari 7

// use the to-visible option of scrolling in WDA

// otherwise, for now, just translate into a drag with short duration

// assume that action is in a single plane (x or y, not horizontal at all)
// terminology all assuming right handedness

// horizontal, since y offset is the same in press and moveTo

// vertical

// WDA supports four scrolling strategies: predication based on name, direction,
// predicateString, and toVisible, in that order. Swiping requires direction.

// Double tap element

// Double tap coordinates

// Long tap element

// Drag element

// Drag coordinates

// defaults

// defaults
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9jb21tYW5kcy9nZXN0dXJlLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Z0NBQXVCLG9CQUFvQjs7NkJBQ3RCLGdCQUFnQjs7K0JBQ1QsbUJBQW1COztzQkFDakMsUUFBUTs7OztzQkFDTixXQUFXOzs7O0FBRzNCLElBQUksT0FBTyxHQUFHLEVBQUU7SUFBRSxVQUFVLEdBQUcsRUFBRTtJQUFFLFFBQVEsR0FBRyxFQUFFLENBQUM7O0FBRWpELFFBQVEsQ0FBQyxNQUFNLEdBQUcsNkJBQVksT0FBTyxDQUFDLE1BQU0sQ0FBQzs7QUFFN0MsUUFBUSxDQUFDLEtBQUssR0FBRyxvQkFBZ0IsRUFBRTtNQVUzQixZQUFZOzs7O1lBVGIsSUFBSSxDQUFDLFlBQVksRUFBRTs7Ozs7O3lDQUVULElBQUksQ0FBQyxXQUFXLENBQUMsRUFBRSxDQUFDOzs7Ozs7QUFFbkMsVUFBRSxHQUFHLG9CQUFLLGFBQWEsQ0FBQyxFQUFFLENBQUMsQ0FBQzs7Y0FDeEIsSUFBSSxDQUFDLElBQUksQ0FBQyxZQUFZLElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUE7Ozs7Ozt5Q0FFMUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxFQUFFLENBQUM7Ozs7Ozs7QUFFdkIsb0JBQVksR0FBRyxJQUFJLENBQUMsZUFBZSxDQUFDLEVBQUUsQ0FBQzs7eUNBQzlCLElBQUksQ0FBQyxXQUFXLENBQUMsT0FBTyxFQUFFLENBQUMsWUFBWSxDQUFDLENBQUM7Ozs7Ozs7Ozs7Q0FFekQsQ0FBQzs7QUFFRixTQUFTLGNBQWMsQ0FBRSxRQUFRLEVBQUUsVUFBVSxFQUFFO0FBQzdDLE1BQUk7QUFDRixRQUFJLFFBQVEsQ0FBQyxNQUFNLEtBQUssVUFBVSxDQUFDLE1BQU0sRUFBRTtBQUN6QyxhQUFPLEtBQUssQ0FBQztLQUNkO0FBQ0QsU0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFF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QUMsaUJBQWlCLEdBQUcsVUFBVSxnQkFBZ0IsRUFBRSxpQkFBaUIsRUFBRTtBQUN6RSxNQUFJLGlCQUFpQixDQUFDLFVBQVUsRUFBRTtBQUNoQyxXQUFPO0FBQ0wsT0FBQyxFQUFFLGdCQUFnQixDQUFDLENBQUMsR0FBRyxpQkFBaUIsQ0FBQyxDQUFDO0FBQzNDLE9BQUMsRUFBRSxnQkFBZ0IsQ0FBQyxDQUFDLEdBQUcsaUJBQWlCLENBQUMsQ0FBQztLQUM1QyxDQUFDO0dBQ0gsTUFBTTtBQUNMLFdBQU8saUJBQWlCLENBQUM7R0FDMUI7Q0FDRixDQUFDOztBQUVGLGVBQWMsVUFBVSxFQUFFLE9BQU8sRUFBRSxRQUFRLENBQUMsQ0FBQztRQUNwQyxVQUFVLEdBQVYsVUFBVTtRQUFFLE9BQU8sR0FBUCxPQUFPO1FBQUUsUUFBUSxHQUFSLFFBQVE7UUFBRSxjQUFjLEdBQWQsY0FBYztRQUFFLHFCQUFxQixHQUFyQixxQkFBcUI7cUJBQzlELFVBQVUiLCJmaWxlIjoibGliL2NvbW1hbmRzL2dlc3R1cmUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBlcnJvcnMgfSBmcm9tICdhcHBpdW0tYmFzZS1kcml2ZXInO1xuaW1wb3J0IHsgdXRpbCB9IGZyb20gJ2FwcGl1bS1zdXBwb3J0JztcbmltcG9ydCB7IGlvc0NvbW1hbmRzIH0gZnJvbSAnYXBwaXVtLWlvcy1kcml2ZXInO1xuaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBsb2cgZnJvbSAnLi4vbG9nZ2VyJztcblxuXG5sZXQgaGVscGVycyA9IHt9LCBleHRlbnNpb25zID0ge30sIGNvbW1hbmRzID0ge307XG5cbmNvbW1hbmRzLm1vdmVUbyA9IGlvc0NvbW1hbmRzLmdlc3R1cmUubW92ZVRvO1xuXG5jb21tYW5kcy5jbGljayA9IGFzeW5jIGZ1bmN0aW9uIChlbCkge1xuICBpZiAoIXRoaXMuaXNXZWJDb250ZXh0KCkpIHtcbiAgICAvLyB0aGVyZSBhcmUgbXVsdGlwbGUgY29tbWFuZHMgdGhhdCBtYXAgaGVyZSwgc28gbWFudWFsbHkgcHJveHlcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5uYXRpdmVDbGljayhlbCk7XG4gIH1cbiAgZWwgPSB1dGlsLnVud3JhcEVsZW1lbnQoZWwpO1xuICBpZiAodGhpcy5vcHRzLm5hdGl2ZVdlYlRhcCAmJiAhdGhpcy5pc1JlYWxEZXZpY2UoKSkge1xuICAgIC8vIGF0b21zLWJhc2VkIGNsaWNrcyBkb24ndCBhbHdheXMgd29yayBpbiBzYWZhcmkgN1xuICAgIGF3YWl0IHRoaXMubmF0aXZlV2ViVGFwKGVsKTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgYXRvbXNFbGVtZW50ID0gdGhpcy51c2VBdG9tc0VsZW1lbnQoZWwpO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmV4ZWN1dGVBdG9tKCdjbGljaycsIFthdG9tc0VsZW1lbnRdKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gaXNTYW1lR2VzdHVyZXMgKGdlc3R1cmVzLCBjYW5kaWRhdGVzKSB7XG4gIHRyeSB7XG4gICAgaWYgKGdlc3R1cmVzLmxlbmd0aCAhPT0gY2FuZGlkYXRlcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBnZXN0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZ2VzdHVyZU9iaiA9IGdlc3R1cmVzW2ldO1xuICAgICAgY29uc3QgY2FuZGlkYXRlT2JqID0gY2FuZGlkYXRlc1tpXTtcbiAgICAgIGlmICghXy5pc1BsYWluT2JqZWN0KGdlc3R1cmVPYmopIHx8ICFfLmlzUGxhaW5PYmplY3QoY2FuZGlkYXRlT2JqKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoXy5kaWZmZXJlbmNlKF8ua2V5cyhjYW5kaWRhdGVPYmopLCBfLmtleXMoZ2VzdHVyZU9iaikpLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoZ2VzdHVyZU9iai5hY3Rpb24udG9Mb3dlckNhc2UoKSAhPT0gY2FuZGlkYXRlT2JqLmFjdGlvbi50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChjYW5kaWRhdGVPYmoub3B0aW9ucyAmJiBnZXN0dXJlT2JqLm9wdGlvbnMuY291bnQgIT09IGNhbmRpZGF0ZU9iai5vcHRpb25zLmNvdW50KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGxvZy5kZWJ1ZyhgRXJyb3IgXCIke2Vyci5tZXNzYWdlfVwiIHdoaWxlIGNvbXBhcmluZyBnZXN0dXJlcy4gQ29uc2lkZXJpbmcgdGhlbSBhcyBub3QgZXF1YWxgKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGdlc3R1cmVzQ2hhaW5Ub1N0cmluZyAoZ2VzdHVyZXMsIGtleXNUb0luY2x1ZGUgPSBbJ29wdGlvbnMnXSkge1xuICByZXR1cm4gZ2VzdHVyZXMubWFwKChpdGVtKSA9PiB7XG4gICAgbGV0IG90aGVyS2V5cyA9IF8uZGlmZmVyZW5jZShfLmtleXMoaXRlbSksIFsnYWN0aW9uJ10pO1xuICAgIG90aGVyS2V5cyA9IF8uaXNBcnJheShrZXlzVG9JbmNsdWRlKSA/IF8uaW50ZXJzZWN0aW9uKG90aGVyS2V5cywga2V5c1RvSW5jbHVkZSkgOiBvdGhlcktleXM7XG4gICAgaWYgKG90aGVyS2V5cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBgJHtpdGVtLmFjdGlvbn1gICtcbiAgICAgICAgYCgke18ubWFwKG90aGVyS2V5cywgKHgpID0+IHggKyAnPScgKyAoXy5pc1BsYWluT2JqZWN0KGl0ZW1beF0pID8gSlNPTi5zdHJpbmdpZnkoaXRlbVt4XSkgOiBpdGVtW3hdKSkuam9pbignLCAnKX0pYDtcbiAgICB9XG4gICAgcmV0dXJuIGl0ZW0uYWN0aW9uO1xuICB9KS5qb2luKCctJyk7XG59XG5cbmNvbW1hbmRzLnBlcmZvcm1Ub3VjaCA9IGFzeW5jIGZ1bmN0aW9uIChnZXN0dXJlcykge1xuICBsb2cuZGVidWcoYFJlY2VpdmVkIHRoZSBmb2xsb3dpbmcgdG91Y2ggYWN0aW9uOiAke2dlc3R1cmVzQ2hhaW5Ub1N0cmluZyhnZXN0dXJlcyl9YCk7XG5cbiAgY29uc3Qgc3VwcG9ydGVkR2VzdHVyZXNNYXBwaW5nID0ge1xuICAgIGRvdWJsZVRhcDoge1xuICAgICAgaGFuZGxlcjogYXN5bmMgKHgpID0+IHthd2FpdCB0aGlzLmhhbmRsZURvdWJsZVRhcCh4KTt9LFxuICAgICAgbWF0Y2hlczogW1xuICAgICAgICBbe2FjdGlvbjogJ2RvdWJsZXRhcCd9XSxcbiAgICAgICAgW3thY3Rpb246ICd0YXAnLCBvcHRpb25zOiB7Y291bnQ6IDJ9fV1cbiAgICAgIF1cbiAgICB9LFxuICAgIHRhcDoge1xuICAgICAgaGFuZGxlcjogYXN5bmMgKHgpID0+IHthd2FpdCB0aGlzLmhhbmRsZVRhcCh4WzBdKTt9LFxuICAgICAgbWF0Y2hlczogW1xuICAgICAgICBbe2FjdGlvbjogJ3RhcCd9XSxcbiAgICAgICAgW3thY3Rpb246ICd0YXAnfSwge2FjdGlvbjogJ3JlbGVhc2UnfV0sXG4gICAgICAgIFt7YWN0aW9uOiAncHJlc3MnfSwge2FjdGlvbjogJ3JlbGVhc2UnfV1cbiAgICAgIF1cbiAgICB9LFxuICAgIGxvbmdQcmVzczoge1xuICAgICAgaGFuZGxlcjogYXN5bmMgKHgpID0+IHthd2FpdCB0aGlzLmhhbmRsZUxvbmdQcmVzcyh4KTt9LFxuICAgICAgbWF0Y2hlczogW1xuICAgICAgICBbe2FjdGlvbjogJ2xvbmdwcmVzcyd9XSxcbiAgICAgICAgW3thY3Rpb246ICdsb25ncHJlc3MnfSwge2FjdGlvbjogJ3JlbGVhc2UnfV0sXG4gICAgICAgIFt7YWN0aW9uOiAncHJlc3MnfSwge2FjdGlvbjogJ3dhaXQnfSwge2FjdGlvbjogJ3JlbGVhc2UnfV1cbiAgICAgIF1cbiAgICB9LFxuICAgIGRyYWc6IHtcbiAgICAgIGhhbmRsZXI6IGFzeW5jICh4KSA9PiB7YXdhaXQgdGhpcy5oYW5kbGVEcmFnKHgpO30sXG4gICAgICBtYXRjaGVzOiBbXG4gICAgICAgIFt7YWN0aW9uOiAncHJlc3MnfSwge2FjdGlvbjogJ3dhaXQnfSwge2FjdGlvbjogJ21vdmVUbyd9LCB7YWN0aW9uOiAncmVsZWFzZSd9XSxcbiAgICAgICAgW3thY3Rpb246ICdsb25ncHJlc3MnfSwge2FjdGlvbjogJ21vdmVUbyd9LCB7YWN0aW9uOiAncmVsZWFzZSd9XVxuICAgICAgXVxuICAgIH0sXG4gICAgc2Nyb2xsOiB7XG4gICAgICBoYW5kbGVyOiBhc3luYyAoeCkgPT4ge2F3YWl0IHRoaXMuaGFuZGxlU2Nyb2xsKHgpO30sXG4gICAgICBtYXRjaGVzOiBbXG4gICAgICAgIFt7YWN0aW9uOiAncHJlc3MnfSwge2FjdGlvbjogJ21vdmVUbyd9LCB7YWN0aW9uOiAncmVsZWFzZSd9XVxuICAgICAgXVxuICAgIH1cbiAgfTtcbiAgZm9yIChsZXQgW2NtZCwgaW5mb10gb2YgXy50b1BhaXJzKHN1cHBvcnRlZEdlc3R1cmVzTWFwcGluZykpIHtcbiAgICBmb3IgKGxldCBjYW5kaWRhdGVNYXRjaCBvZiBpbmZvLm1hdGNoZXMpIHtcbiAgICAgIGlmIChpc1NhbWVHZXN0dXJlcyhnZXN0dXJlcywgY2FuZGlkYXRlTWF0Y2gpKSB7XG4gICAgICAgIGxvZy5kZWJ1ZyhgRm91bmQgbWF0Y2hpbmcgZ2VzdHVyZTogJHtjbWR9YCk7XG4gICAgICAgIHJldHVybiBhd2FpdCBpbmZvLmhhbmRsZXIoZ2VzdHVyZXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGxldCBhdmFpbGFibGVHZXN0dXJlcyA9ICcnO1xuICBmb3IgKGxldCBbY21kLCBpbmZvXSBvZiBfLnRvUGFpcnMoc3VwcG9ydGVkR2VzdHVyZXNNYXBwaW5nKSkge1xuICAgIGF2YWlsYWJsZUdlc3R1cmVzICs9IGBcXHQke2NtZH06IGA7XG4gICAgZm9yIChsZXQgY2FuZGlkYXRlTWF0Y2ggb2YgaW5mby5tYXRjaGVzKSB7XG4gICAgICBhdmFpbGFibGVHZXN0dXJlcyArPSBgXFx0XFx0JHtnZXN0dXJlc0NoYWluVG9TdHJpbmcoY2FuZGlkYXRlTWF0Y2gpfVxcbmA7XG4gICAgfVxuICB9XG4gIHRocm93IG5ldyBlcnJvcnMuTm90WWV0SW1wbGVtZW50ZWRFcnJvcihgU3VwcG9ydCBmb3IgJHtnZXN0dXJlc0NoYWluVG9TdHJpbmcoZ2VzdHVyZXMpfSBnZXN0dXJlIGlzIG5vdCBpbXBsZW1lbnRlZC4gYCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgVHJ5IHRvIHVzZSBcIm1vYmlsZTogKlwiIGludGVyZmFjZSB0byB3b3JrYXJvdW5kIHRoZSBpc3N1ZS4gYCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgT25seSB0aGVzZSBnZXN0dXJlcyBhcmUgc3VwcG9ydGVkOlxcbiR7YXZhaWxhYmxlR2VzdHVyZXN9YCk7XG59O1xuXG5jb21tYW5kcy5wZXJmb3JtTXVsdGlBY3Rpb24gPSBhc3luYyBmdW5jdGlvbiAoYWN0aW9ucykge1xuICBsb2cuZGVidWcoYFJlY2VpdmVkIHRoZSBmb2xsb3dpbmcgbXVsdGkgdG91Y2ggYWN0aW9uOmApO1xuICBmb3IgKGxldCBpIGluIGFjdGlvbnMpIHtcbiAgICBsb2cuZGVidWcoYCAgICAke2krMX06ICR7Xy5tYXAoYWN0aW9uc1tpXSwgJ2FjdGlvbicpLmpvaW4oJy0nKX1gKTtcbiAgfVxuXG4gIGlmIChpc1BpbmNoT3Jab29tKGFjdGlvbnMpKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuaGFuZGxlUGluY2hPclpvb20oYWN0aW9ucyk7XG4gIH1cbiAgdGhyb3cgbmV3IGVycm9ycy5Ob3RZZXRJbXBsZW1lbnRlZEVycm9yKCdTdXBwb3J0IGZvciB0aGlzIG11bHRpLWFjdGlvbiBpcyBub3QgaW1wbGVtZW50ZWQuIFRyeSB0byB1c2UgXCJtb2JpbGU6ICpcIiBpbnRlcmZhY2UgdG8gd29ya2Fyb3VuZCB0aGUgaXNzdWUuJyk7XG59O1xuXG5jb21tYW5kcy5uYXRpdmVDbGljayA9IGFzeW5jIGZ1bmN0aW9uIChlbCkge1xuICBlbCA9IHV0aWwudW53cmFwRWxlbWVudChlbCk7XG4gIGxldCBlbmRwb2ludCA9IGAvZWxlbWVudC8ke2VsfS9jbGlja2A7XG4gIHJldHVybiBhd2FpdCB0aGlzLnByb3h5Q29tbWFuZChlbmRwb2ludCwgJ1BPU1QnLCB7fSk7XG59O1xuXG5mdW5jdGlvbiBpc1Njcm9sbCAoZ2VzdHVyZXMpIHtcbiAgaWYgKGdlc3R1cmVzLmxlbmd0aCA9PT0gMyAmJlxuICAgICAgICBnZXN0dXJlc1swXS5hY3Rpb24gPT09ICdwcmVzcycgJiZcbiAgICAgICAgZ2VzdHVyZXNbMV0uYWN0aW9uID09PSAnbW92ZVRvJyAmJlxuICAgICAgICBnZXN0dXJlc1syXS5hY3Rpb24gPT09ICdyZWxlYXNlJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNQaW5jaE9yWm9vbSAoYWN0aW9ucyA9IFtdKSB7XG4gIC8vIHN5bW1ldHJpYyB0d28tZmluZ2VyIGFjdGlvbiBjb25zaXN0aW5nIG9mIHByZXNzLW1vdmV0by1yZWxlYXNlXG4gIGlmIChhY3Rpb25zLmxlbmd0aCA9PT0gMikge1xuICAgIGlmIChhY3Rpb25zWzBdLmxlbmd0aCA9PT0gMyAmJiBhY3Rpb25zWzFdLmxlbmd0aCA9PT0gMykge1xuICAgICAgcmV0dXJuIF8uZXZlcnkoYWN0aW9ucywgKGdlc3R1cmVzKSA9PiBpc1Njcm9sbChnZXN0dXJlcykpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmhlbHBlcnMuaGFuZGxlU2Nyb2xsID0gYXN5bmMgZnVuY3Rpb24gKGdlc3R1cmVzKSB7XG4gIGlmIChnZXN0dXJlc1sxXS5vcHRpb25zLmVsZW1lbnQpIHtcbiAgICAvLyB1c2UgdGhlIHRvLXZpc2libGUgb3B0aW9uIG9mIHNjcm9sbGluZyBpbiBXREFcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5tb2JpbGVTY3JvbGwoe1xuICAgICAgZWxlbWVudDogZ2VzdHVyZXNbMV0ub3B0aW9ucy5lbGVtZW50LFxuICAgICAgdG9WaXNpYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cblxuICAvLyBvdGhlcndpc2UsIGZvciBub3csIGp1c3QgdHJhbnNsYXRlIGludG8gYSBkcmFnIHdpdGggc2hvcnQgZHVyYXRpb25cbiAgbGV0IGRyYWdHZXN0dXJlcyA9IFtcbiAgICBnZXN0dXJlc1swXSxcbiAgICB7YWN0aW9uOiAnd2FpdCcsIG9wdGlvbnM6IHttczogMH19LFxuICAgIGdlc3R1cmVzWzFdLFxuICAgIGdlc3R1cmVzWzJdXG4gIF07XG4gIHJldHVybiBhd2FpdCB0aGlzLmhhbmRsZURyYWcoZHJhZ0dlc3R1cmVzKTtcbn07XG5cbmhlbHBlcnMuaGFuZGxlRHJhZyA9IGFzeW5jIGZ1bmN0aW9uIChnZXN0dXJlcykge1xuICBsZXQgcHJlc3MsIHdhaXQsIG1vdmVUbztcbiAgaWYgKGdlc3R1cmVzWzBdLmFjdGlvbiA9PT0gJ2xvbmdwcmVzcycpIHtcbiAgICBwcmVzcyA9IGdlc3R1cmVzWzBdO1xuICAgIHdhaXQgPSB7YWN0aW9uOiAnd2FpdCcsIG9wdGlvbnM6IHttczogcHJlc3Mub3B0aW9ucy5kdXJhdGlvbn19O1xuICAgIG1vdmVUbyA9IGdlc3R1cmVzWzFdO1xuICB9IGVsc2Uge1xuICAgIHByZXNzID0gZ2VzdHVyZXNbMF07XG4gICAgd2FpdCA9IGdlc3R1cmVzWzFdO1xuICAgIG1vdmVUbyA9IGdlc3R1cmVzWzJdO1xuICB9XG5cbiAgLy8gZ2V0IGRyYWcgZGF0YVxuICBsZXQgcHJlc3NDb29yZGluYXRlcyA9IGF3YWl0IHRoaXMuZ2V0Q29vcmRpbmF0ZXMocHJlc3MpO1xuICBsZXQgZHVyYXRpb24gPSAocGFyc2VJbnQod2FpdC5vcHRpb25zLm1zLCAxMCkgLyAxMDAwKTtcbiAgbGV0IG1vdmVUb0Nvb3JkaW5hdGVzID0gYXdhaXQgdGhpcy5nZXRDb29yZGluYXRlcyhtb3ZlVG8pO1xuXG4gIC8vIHVwZGF0ZSBtb3ZlVG8gY29vcmRpbmF0ZXMgd2l0aCBvZmZzZXRcbiAgbW92ZVRvQ29vcmRpbmF0ZXMgPSB0aGlzLmFwcGx5TW92ZVRvT2Zmc2V0KHByZXNzQ29vcmRpbmF0ZXMsIG1vdmVUb0Nvb3JkaW5hdGVzKTtcblxuICAvLyBidWlsZCBkcmFnIGNvbW1hbmRcbiAgbGV0IHBhcmFtcyA9IHt9O1xuICBwYXJhbXMuZnJvbVggPSBwcmVzc0Nvb3JkaW5hdGVzLng7XG4gIHBhcmFtcy5mcm9tWSA9IHByZXNzQ29vcmRpbmF0ZXMueTtcbiAgcGFyYW1zLnRvWCA9IG1vdmVUb0Nvb3JkaW5hdGVzLng7XG4gIHBhcmFtcy50b1kgPSBtb3ZlVG9Db29yZGluYXRlcy55O1xuICBwYXJhbXMuZHVyYXRpb24gPSBkdXJhdGlvbjtcblxuICBsZXQgZW5kcG9pbnQgPSBgL3dkYS9kcmFnZnJvbXRvZm9yZHVyYXRpb25gO1xuICByZXR1cm4gYXdhaXQgdGhpcy5wcm94eUNvbW1hbmQoZW5kcG9pbnQsICdQT1NUJywgcGFyYW1zKTtcbn07XG5cbmhlbHBlcnMuaGFuZGxlVGFwID0gYXN5bmMgZnVuY3Rpb24gKGdlc3R1cmUpIHtcbiAgbGV0IG9wdGlvbnMgPSBnZXN0dXJlLm9wdGlvbnMgfHwge307XG5cbiAgbGV0IHBhcmFtcyA9IHt9O1xuICBpZiAodXRpbC5oYXNWYWx1ZShvcHRpb25zLngpICYmIHV0aWwuaGFzVmFsdWUob3B0aW9ucy55KSkge1xuICAgIHBhcmFtcy54ID0gb3B0aW9ucy54O1xuICAgIHBhcmFtcy55ID0gb3B0aW9ucy55O1xuICB9XG5cbiAgbGV0IGVsID0gdXRpbC5oYXNWYWx1ZShvcHRpb25zLmVsZW1lbnQpID8gb3B0aW9ucy5lbGVtZW50IDogJzAnO1xuICBsZXQgZW5kcG9pbnQgPSBgL3dkYS90YXAvJHtlbH1gO1xuXG4gIGlmICh1dGlsLmhhc1ZhbHVlKHRoaXMub3B0cy50YXBXaXRoU2hvcnRQcmVzc0R1cmF0aW9uKSkge1xuICAgIC8vIGluIHNvbWUgY2FzZXMgYHRhcGAgaXMgdG9vIHNsb3csIHNvIGFsbG93IGNvbmZpZ3VyYWJsZSBsb25nIHByZXNzXG4gICAgbG9nLmRlYnVnKGBUcmFuc2xhdGluZyB0YXAgaW50byBsb25nIHByZXNzIHdpdGggJyR7dGhpcy5vcHRzLnRhcFdpdGhTaG9ydFByZXNzRHVyYXRpb259JyBkdXJhdGlvbmApO1xuICAgIHBhcmFtcy5kdXJhdGlvbiA9IHBhcnNlRmxvYXQodGhpcy5vcHRzLnRhcFdpdGhTaG9ydFByZXNzRHVyYXRpb24pO1xuICAgIGVuZHBvaW50ID0gYC93ZGEvZWxlbWVudC8ke2VsfS90b3VjaEFuZEhvbGRgO1xuICAgIHBhcmFtcy5kdXJhdGlvbiA9IHBhcnNlRmxvYXQodGhpcy5vcHRzLnRhcFdpdGhTaG9ydFByZXNzRHVyYXRpb24pO1xuICB9XG5cbiAgcmV0dXJuIGF3YWl0IHRoaXMucHJveHlDb21tYW5kKGVuZHBvaW50LCAnUE9TVCcsIHBhcmFtcyk7XG59O1xuXG5oZWxwZXJzLmhhbmRsZURvdWJsZVRhcCA9IGFzeW5jIGZ1bmN0aW9uIChnZXN0dXJlcykge1xuICBsZXQgZ2VzdHVyZSA9IGdlc3R1cmVzWzBdO1xuICBsZXQgb3B0cyA9IGdlc3R1cmUub3B0aW9ucyB8fCB7fTtcblxuICBpZiAoIW9wdHMuZWxlbWVudCkge1xuICAgIGxvZy5lcnJvckFuZFRocm93KCdXREEgZG91YmxlIHRhcCBuZWVkcyBhbiBlbGVtZW50Jyk7XG4gIH1cblxuICBsZXQgZWwgPSB1dGlsLnVud3JhcEVsZW1lbnQob3B0cy5lbGVtZW50KTtcbiAgbGV0IGVuZHBvaW50ID0gYC93ZGEvZWxlbWVudC8ke2VsfS9kb3VibGVUYXBgO1xuXG4gIHJldHVybiBhd2FpdCB0aGlzLnByb3h5Q29tbWFuZChlbmRwb2ludCwgJ1BPU1QnKTtcbn07XG5cbmhlbHBlcnMuaGFuZGxlTG9uZ1ByZXNzID0gYXN5bmMgZnVuY3Rpb24gKGdlc3R1cmVzKSB7XG4gIGxldCBwcmVzc09wdHMgPSBfLmlzUGxhaW5PYmplY3QoZ2VzdHVyZXNbMF0ub3B0aW9ucykgPyBnZXN0dXJlc1swXS5vcHRpb25zIDoge307XG5cbiAgbGV0IGVsID0gdXRpbC51bndyYXBFbGVtZW50KHByZXNzT3B0cy5lbGVtZW50KTtcbiAgbGV0IGR1cmF0aW9uOyAvLyBJbiBzZWNvbmRzIChub3QgbWlsbGlzZWNvbmRzKVxuICBpZiAodXRpbC5oYXNWYWx1ZShwcmVzc09wdHMuZHVyYXRpb24pKSB7XG4gICAgZHVyYXRpb24gPSBwcmVzc09wdHMuZHVyYXRpb24gLyAxMDAwO1xuICB9IGVsc2UgaWYgKGdlc3R1cmVzLmxlbmd0aCA9PT0gMyAmJiBnZXN0dXJlc1sxXS5hY3Rpb24gPT09ICd3YWl0Jykge1xuICAgIC8vIGR1cmF0aW9uIGlzIHRoZSBgd2FpdGAgYWN0aW9uXG4gICAgLy8gdXBzdHJlYW0gc3lzdGVtIGV4cGVjdHMgc2Vjb25kcyBub3QgbWlsbGlzZWNvbmRzXG4gICAgZHVyYXRpb24gPSBwYXJzZUZsb2F0KGdlc3R1cmVzWzFdLm9wdGlvbnMubXMpIC8gMTAwMDtcbiAgfSBlbHNlIHtcbiAgICAvLyBnaXZlIGEgc2FuZSBkZWZhdWx0IGR1cmF0aW9uXG4gICAgZHVyYXRpb24gPSAwLjg7XG4gIH1cblxuICBsZXQgcGFyYW1zID0ge1xuICAgIGR1cmF0aW9uLFxuICAgIHg6IHByZXNzT3B0cy54LFxuICAgIHk6IHByZXNzT3B0cy55LFxuICB9O1xuXG4gIGxldCBlbmRwb2ludDtcbiAgaWYgKGVsKSB7XG4gICAgZW5kcG9pbnQgPSBgL3dkYS9lbGVtZW50LyR7ZWx9L3RvdWNoQW5kSG9sZGA7XG4gIH0gZWxzZSB7XG4gICAgcGFyYW1zLnggPSBwcmVzc09wdHMueDtcbiAgICBwYXJhbXMueSA9IHByZXNzT3B0cy55O1xuXG4gICAgZW5kcG9pbnQgPSAnL3dkYS90b3VjaEFuZEhvbGQnO1xuICB9XG4gIHJldHVybiBhd2FpdCB0aGlzLnByb3h5Q29tbWFuZChlbmRwb2ludCwgJ1BPU1QnLCBwYXJhbXMpO1xufTtcblxuZnVuY3Rpb24gZGV0ZXJtaW5lUGluY2hTY2FsZSAoeCwgeSwgcGluY2gpIHtcbiAgbGV0IHNjYWxlID0geCA+IHkgPyB4IC0geSA6IHkgLSB4O1xuICBpZiAocGluY2gpIHtcbiAgICAvLyBUT0RPOiByZXZpc2l0IHRoaXMgd2hlbiBwaW5jaGluZyBhY3R1YWxseSB3b3Jrcywgc2luY2UgaXQgaXMgaW1wb3NzaWJsZSB0b1xuICAgIC8vIGtub3cgd2hhdCB0aGUgc2NhbGUgZmFjdG9yIGRvZXMgYXQgdGhpcyBwb2ludCAoWGNvZGUgOC4xKVxuICAgIHNjYWxlID0gMSAvIHNjYWxlO1xuICAgIGlmIChzY2FsZSA8IDAuMDIpIHtcbiAgICAgIC8vIHRoaXMgaXMgdGhlIG1pbmltdW0gdGhhdCBBcHBsZSB3aWxsIGFsbG93XG4gICAgICAvLyBidXQgV0RBIHdpbGwgbm90IHRocm93IGFuIGVycm9yIGlmIGl0IGlzIHRvbyBsb3dcbiAgICAgIHNjYWxlID0gMC4wMjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gZm9yIHpvb20sIGVhY2ggMTBweCBpcyBvbmUgc2NhbGUgZmFjdG9yXG4gICAgc2NhbGUgPSBzY2FsZSAvIDEwO1xuICB9XG4gIHJldHVybiBzY2FsZTtcbn1cblxuaGVscGVycy5oYW5kbGVQaW5jaE9yWm9vbSA9IGFzeW5jIGZ1bmN0aW9uIChhY3Rpb25zKSB7XG4gIC8vIGN1cnJlbnRseSB3ZSBjYW4gb25seSBkbyB0aGlzIGFjdGlvbiBvbiBhbiBlbGVtZW50XG4gIGlmICghYWN0aW9uc1swXVswXS5vcHRpb25zLmVsZW1lbnQgfHxcbiAgICAgIGFjdGlvbnNbMF1bMF0ub3B0aW9ucy5lbGVtZW50ICE9PSBhY3Rpb25zWzFdWzBdLm9wdGlvbnMuZWxlbWVudCkge1xuICAgIGxvZy5lcnJvckFuZFRocm93KCdQaW5jaC96b29tIGFjdGlvbnMgbXVzdCBiZSBkb25lIG9uIGEgc2luZ2xlIGVsZW1lbnQnKTtcbiAgfVxuICBsZXQgZWwgPSBhY3Rpb25zWzBdWzBdLm9wdGlvbnMuZWxlbWVudDtcblxuICAvLyBhc3N1bWUgdGhhdCBhY3Rpb24gaXMgaW4gYSBzaW5nbGUgcGxhbmUgKHggb3IgeSwgbm90IGhvcml6b250YWwgYXQgYWxsKVxuICAvLyB0ZXJtaW5vbG9neSBhbGwgYXNzdW1pbmcgcmlnaHQgaGFuZGVkbmVzc1xuICBsZXQgc2NhbGUsIHZlbG9jaXR5O1xuICBpZiAoYWN0aW9uc1swXVswXS5vcHRpb25zLnkgPT09IGFjdGlvbnNbMF1bMV0ub3B0aW9ucy55KSB7XG4gICAgLy8gaG9yaXpvbnRhbCwgc2luY2UgeSBvZmZzZXQgaXMgdGhlIHNhbWUgaW4gcHJlc3MgYW5kIG1vdmVUb1xuICAgIGxldCB0aHVtYiA9IChhY3Rpb25zWzBdWzBdLm9wdGlvbnMueCA8PSBhY3Rpb25zWzFdWzBdLm9wdGlvbnMueCkgPyBhY3Rpb25zWzBdIDogYWN0aW9uc1sxXTtcblxuICAgIC8vIG5vdyBkZWNpcGhlciBwaW5jaCB2cy4gem9vbSxcbiAgICAvLyAgIHBpbmNoOiB0aHVtYiBtb3ZpbmcgZnJvbSBsZWZ0IHRvIHJpZ2h0XG4gICAgLy8gICB6b29tOiB0aHVtYiBtb3ZpbmcgZnJvbSByaWdodCB0byBsZWZ0XG4gICAgc2NhbGUgPSBkZXRlcm1pbmVQaW5jaFNjYWxlKHRodW1iWzBdLm9wdGlvbnMueCwgdGh1bWJbMV0ub3B0aW9ucy54LCB0aHVtYlswXS5vcHRpb25zLnggPD0gdGh1bWJbMV0ub3B0aW9ucy54KTtcbiAgfSBlbHNlIHtcbiAgICAvLyB2ZXJ0aWNhbFxuICAgIGxldCBmb3JlZmluZ2VyID0gKGFjdGlvbnNbMF1bMF0ub3B0aW9ucy55IDw9IGFjdGlvbnNbMV1bMF0ub3B0aW9ucy55KSA/IGFjdGlvbnNbMF0gOiBhY3Rpb25zWzFdO1xuXG4gICAgLy8gbm93IGRlY2lwaGVyIHBpbmNoIHZzLiB6b29tXG4gICAgLy8gICBwaW5jaDogZm9yZWZpbmdlciBtb3ZpbmcgZnJvbSB0b3AgdG8gYm90dG9tXG4gICAgLy8gICB6b29tOiBmb3JlZmluZ2VyIG1vdmluZyBmcm9tIGJvdHRvbSB0byB0b3BcbiAgICBzY2FsZSA9IGRldGVybWluZVBpbmNoU2NhbGUoZm9yZWZpbmdlclswXS5vcHRpb25zLnksIGZvcmVmaW5nZXJbMV0ub3B0aW9ucy55LCBmb3JlZmluZ2VyWzBdLm9wdGlvbnMueSA8PSBmb3JlZmluZ2VyWzFdLm9wdGlvbnMueSk7XG4gIH1cbiAgdmVsb2NpdHkgPSBzY2FsZSA8IDEgPyAtMSA6IDE7XG5cbiAgbG9nLmRlYnVnKGBEZWNvZGVkICR7c2NhbGUgPCAxID8gJ3BpbmNoJyA6ICd6b29tJ30gYWN0aW9uIHdpdGggc2NhbGUgJyR7c2NhbGV9JyBhbmQgdmVsb2NpdHkgJyR7dmVsb2NpdHl9J2ApO1xuICBpZiAoc2NhbGUgPCAxKSB7XG4gICAgbG9nLndhcm4oJ1BpbmNoIGFjdGlvbnMgbWF5IG5vdCB3b3JrLCBkdWUgdG8gQXBwbGUgaXNzdWUuJyk7XG4gIH1cblxuICBsZXQgcGFyYW1zID0ge1xuICAgIHNjYWxlLFxuICAgIHZlbG9jaXR5XG4gIH07XG4gIGF3YWl0IHRoaXMucHJveHlDb21tYW5kKGAvd2RhL2VsZW1lbnQvJHtlbH0vcGluY2hgLCAnUE9TVCcsIHBhcmFtcyk7XG59O1xuXG4vKlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9XZWJEcml2ZXJBZ2VudC9ibG9iL21hc3Rlci9XZWJEcml2ZXJBZ2VudExpYi9Db21tYW5kcy9GQkVsZW1lbnRDb21tYW5kcy5tXG4gKiB0byBnZXQgdGhlIGluZm8gYWJvdXQgYXZhaWxhYmxlIFdEQSBnZXN0dXJlcyBBUElcbiAqXG4gKiBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL3JlZmVyZW5jZS94Y3Rlc3QveGN1aWVsZW1lbnQgYW5kXG4gKiBodHRwczovL2RldmVsb3Blci5hcHBsZS5jb20vcmVmZXJlbmNlL3hjdGVzdC94Y3VpY29vcmRpbmF0ZSB0byBnZXQgdGhlIGRldGFpbGVkIGRlc2NyaXB0aW9uIG9mXG4gKiBhbGwgWENUZXN0IGdlc3R1cmVzXG4qL1xuXG5oZWxwZXJzLm1vYmlsZVNjcm9sbCA9IGFzeW5jIGZ1bmN0aW9uIChvcHRzPXt9LCBzd2lwZT1mYWxzZSkge1xuICBpZiAoIW9wdHMuZWxlbWVudCkge1xuICAgIG9wdHMuZWxlbWVudCA9IGF3YWl0IHRoaXMuZmluZE5hdGl2ZUVsZW1lbnRPckVsZW1lbnRzKGBjbGFzcyBuYW1lYCwgYFhDVUlFbGVtZW50VHlwZUFwcGxpY2F0aW9uYCwgZmFsc2UpO1xuICB9XG4gIC8vIFdEQSBzdXBwb3J0cyBmb3VyIHNjcm9sbGluZyBzdHJhdGVnaWVzOiBwcmVkaWNhdGlvbiBiYXNlZCBvbiBuYW1lLCBkaXJlY3Rpb24sXG4gIC8vIHByZWRpY2F0ZVN0cmluZywgYW5kIHRvVmlzaWJsZSwgaW4gdGhhdCBvcmRlci4gU3dpcGluZyByZXF1aXJlcyBkaXJlY3Rpb24uXG4gIGxldCBwYXJhbXMgPSB7fTtcbiAgaWYgKG9wdHMubmFtZSAmJiAhc3dpcGUpIHtcbiAgICBwYXJhbXMubmFtZSA9IG9wdHMubmFtZTtcbiAgfSBlbHNlIGlmIChvcHRzLmRpcmVjdGlvbikge1xuICAgIGlmIChbJ3VwJywgJ2Rvd24nLCAnbGVmdCcsICdyaWdodCddLmluZGV4T2Yob3B0cy5kaXJlY3Rpb24udG9Mb3dlckNhc2UoKSkgPCAwKSB7XG4gICAgICBsZXQgbXNnID0gJ0RpcmVjdGlvbiBtdXN0IGJlIHVwLCBkb3duLCBsZWZ0IG9yIHJpZ2h0JztcbiAgICAgIGxvZy5lcnJvckFuZFRocm93KG1zZyk7XG4gICAgfVxuICAgIHBhcmFtcy5kaXJlY3Rpb24gPSBvcHRzLmRpcmVjdGlvbjtcbiAgfSAgZWxzZSBpZiAob3B0cy5wcmVkaWNhdGVTdHJpbmcgJiYgIXN3aXBlKSB7XG4gICAgcGFyYW1zLnByZWRpY2F0ZVN0cmluZyA9IG9wdHMucHJlZGljYXRlU3RyaW5nO1xuICB9IGVsc2UgaWYgKG9wdHMudG9WaXNpYmxlICYmICFzd2lwZSkge1xuICAgIHBhcmFtcy50b1Zpc2libGUgPSBvcHRzLnRvVmlzaWJsZTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgbXNnID0gc3dpcGUgPyAnTW9iaWxlIHN3aXBlIHJlcXVpcmVzIGRpcmVjdGlvbicgOiAgJ01vYmlsZSBzY3JvbGwgc3VwcG9ydHMgdGhlIGZvbGxvd2luZyBzdHJhdGVnaWVzOiBuYW1lLCBkaXJlY3Rpb24sIHByZWRpY2F0ZVN0cmluZywgYW5kIHRvVmlzaWJsZS4gU3BlY2lmeSBvbmUgb2YgdGhlc2UnO1xuICAgIGxvZy5lcnJvckFuZFRocm93KG1zZyk7XG4gIH1cblxuICBsZXQgZWxlbWVudCA9IG9wdHMuZWxlbWVudC5FTEVNRU5UIHx8IG9wdHMuZWxlbWVudDtcbiAgbGV0IGVuZHBvaW50ID0gYC93ZGEvZWxlbWVudC8ke2VsZW1lbnR9LyR7c3dpcGUgPyAnc3dpcGUnIDogJ3Njcm9sbCd9YDtcbiAgcmV0dXJuIGF3YWl0IHRoaXMucHJveHlDb21tYW5kKGVuZHBvaW50LCAnUE9TVCcsIHBhcmFtcyk7XG59O1xuXG5mdW5jdGlvbiBwYXJzZUZsb2F0UGFyYW1ldGVyIChwYXJhbU5hbWUsIHBhcmFtVmFsdWUsIG1ldGhvZE5hbWUpIHtcbiAgaWYgKF8uaXNVbmRlZmluZWQocGFyYW1WYWx1ZSkpIHtcbiAgICBsb2cuZXJyb3JBbmRUaHJvdyhgXCIke3BhcmFtTmFtZX1cIiBwYXJhbWV0ZXIgaXMgbWFuZGF0b3J5IGZvciBcIiR7bWV0aG9kTmFtZX1cIiBjYWxsYCk7XG4gIH1cbiAgY29uc3QgcmVzdWx0ID0gcGFyc2VGbG9hdChwYXJhbVZhbHVlKTtcbiAgaWYgKGlzTmFOKHJlc3VsdCkpIHtcbiAgICBsb2cuZXJyb3JBbmRUaHJvdyhgXCIke3BhcmFtTmFtZX1cIiBwYXJhbWV0ZXIgc2hvdWxkIGJlIGEgdmFsaWQgbnVtYmVyLiBcIiR7cGFyYW1WYWx1ZX1cIiBpcyBnaXZlbiBpbnN0ZWFkYCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuaGVscGVycy5tb2JpbGVQaW5jaCA9IGFzeW5jIGZ1bmN0aW9uIChvcHRzPXt9KSB7XG4gIGlmICghb3B0cy5lbGVtZW50KSB7XG4gICAgb3B0cy5lbGVtZW50ID0gYXdhaXQgdGhpcy5maW5kTmF0aXZlRWxlbWVudE9yRWxlbWVudHMoYGNsYXNzIG5hbWVgLCBgWENVSUVsZW1lbnRUeXBlQXBwbGljYXRpb25gLCBmYWxzZSk7XG4gIH1cbiAgY29uc3QgcGFyYW1zID0ge1xuICAgIHNjYWxlOiBwYXJzZUZsb2F0UGFyYW1ldGVyKCdzY2FsZScsIG9wdHMuc2NhbGUsICdwaW5jaCcpLFxuICAgIHZlbG9jaXR5OiBwYXJzZUZsb2F0UGFyYW1ldGVyKCd2ZWxvY2l0eScsIG9wdHMudmVsb2NpdHksICdwaW5jaCcpXG4gIH07XG4gIGNvbnN0IGVsID0gb3B0cy5lbGVtZW50LkVMRU1FTlQgfHwgb3B0cy5lbGVtZW50O1xuICByZXR1cm4gYXdhaXQgdGhpcy5wcm94eUNvbW1hbmQoYC93ZGEvZWxlbWVudC8ke2VsfS9waW5jaGAsICdQT1NUJywgcGFyYW1zKTtcbn07XG5cbmhlbHBlcnMubW9iaWxlRG91YmxlVGFwID0gYXN5bmMgZnVuY3Rpb24gKG9wdHM9e30pIHtcbiAgaWYgKG9wdHMuZWxlbWVudCkge1xuICAgIC8vIERvdWJsZSB0YXAgZWxlbWVudFxuICAgIGNvbnN0IGVsID0gb3B0cy5lbGVtZW50LkVMRU1FTlQgfHwgb3B0cy5lbGVtZW50O1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnByb3h5Q29tbWFuZChgL3dkYS9lbGVtZW50LyR7ZWx9L2RvdWJsZVRhcGAsICdQT1NUJyk7XG4gIH1cbiAgLy8gRG91YmxlIHRhcCBjb29yZGluYXRlc1xuICBjb25zdCBwYXJhbXMgPSB7XG4gICAgeDogcGFyc2VGbG9hdFBhcmFtZXRlcigneCcsIG9wdHMueCwgJ2RvdWJsZVRhcCcpLFxuICAgIHk6IHBhcnNlRmxvYXRQYXJhbWV0ZXIoJ3knLCBvcHRzLnksICdkb3VibGVUYXAnKVxuICB9O1xuICByZXR1cm4gYXdhaXQgdGhpcy5wcm94eUNvbW1hbmQoJy93ZGEvZG91YmxlVGFwJywgJ1BPU1QnLCBwYXJhbXMpO1xufTtcblxuaGVscGVycy5tb2JpbGVUd29GaW5nZXJUYXAgPSBhc3luYyBmdW5jdGlvbiAob3B0cz17fSkge1xuICBpZiAoIW9wdHMuZWxlbWVudCkge1xuICAgIG9wdHMuZWxlbWVudCA9IGF3YWl0IHRoaXMuZmluZE5hdGl2ZUVsZW1lbnRPckVsZW1lbnRzKGBjbGFzcyBuYW1lYCwgYFhDVUlFbGVtZW50VHlwZUFwcGxpY2F0aW9uYCwgZmFsc2UpO1xuICB9XG4gIGNvbnN0IGVsID0gb3B0cy5lbGVtZW50LkVMRU1FTlQgfHwgb3B0cy5lbGVtZW50O1xuICByZXR1cm4gYXdhaXQgdGhpcy5wcm94eUNvbW1hbmQoYC93ZGEvZWxlbWVudC8ke2VsfS90d29GaW5nZXJUYXBgLCAnUE9TVCcpO1xufTtcblxuaGVscGVycy5tb2JpbGVUb3VjaEFuZEhvbGQgPSBhc3luYyBmdW5jdGlvbiAob3B0cz17fSkge1xuICBsZXQgcGFyYW1zID0ge1xuICAgIGR1cmF0aW9uOiBwYXJzZUZsb2F0UGFyYW1ldGVyKCdkdXJhdGlvbicsIG9wdHMuZHVyYXRpb24sICd0b3VjaEFuZEhvbGQnKVxuICB9O1xuICBpZiAob3B0cy5lbGVtZW50KSB7XG4gICAgLy8gTG9uZyB0YXAgZWxlbWVudFxuICAgIGNvbnN0IGVsID0gb3B0cy5lbGVtZW50LkVMRU1FTlQgfHwgb3B0cy5lbGVtZW50O1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnByb3h5Q29tbWFuZChgL3dkYS9lbGVtZW50LyR7ZWx9L3RvdWNoQW5kSG9sZGAsICdQT1NUJywgcGFyYW1zKTtcbiAgfVxuICAvLyBMb25nIHRhcCBjb29yZGluYXRlc1xuICBwYXJhbXMueCA9IHBhcnNlRmxvYXRQYXJhbWV0ZXIoJ3gnLCBvcHRzLngsICd0b3VjaEFuZEhvbGQnKTtcbiAgcGFyYW1zLnkgPSBwYXJzZUZsb2F0UGFyYW1ldGVyKCd5Jywgb3B0cy55LCAndG91Y2hBbmRIb2xkJyk7XG4gIHJldHVybiBhd2FpdCB0aGlzLnByb3h5Q29tbWFuZCgnL3dkYS90b3VjaEFuZEhvbGQnLCAnUE9TVCcsIHBhcmFtcyk7XG59O1xuXG5oZWxwZXJzLm1vYmlsZVRhcCA9IGFzeW5jIGZ1bmN0aW9uIChvcHRzPXt9KSB7XG4gIGNvbnN0IHBhcmFtcyA9IHtcbiAgICB4OiBwYXJzZUZsb2F0UGFyYW1ldGVyKCd4Jywgb3B0cy54LCAndGFwJyksXG4gICAgeTogcGFyc2VGbG9hdFBhcmFtZXRlcigneScsIG9wdHMueSwgJ3RhcCcpXG4gIH07XG4gIGNvbnN0IGVsID0gb3B0cy5lbGVtZW50ID8gKG9wdHMuZWxlbWVudC5FTEVNRU5UIHx8IG9wdHMuZWxlbWVudCkgOiAnMCc7XG4gIHJldHVybiBhd2FpdCB0aGlzLnByb3h5Q29tbWFuZChgL3dkYS90YXAvJHtlbH1gLCAnUE9TVCcsIHBhcmFtcyk7XG59O1xuXG5oZWxwZXJzLm1vYmlsZURyYWdGcm9tVG9Gb3JEdXJhdGlvbiA9IGFzeW5jIGZ1bmN0aW9uIChvcHRzPXt9KSB7XG4gIGNvbnN0IHBhcmFtcyA9IHtcbiAgICBkdXJhdGlvbjogcGFyc2VGbG9hdFBhcmFtZXRlcignZHVyYXRpb24nLCBvcHRzLmR1cmF0aW9uLCAnZHJhZ0Zyb21Ub0ZvckR1cmF0aW9uJyksXG4gICAgZnJvbVg6IHBhcnNlRmxvYXRQYXJhbWV0ZXIoJ2Zyb21YJywgb3B0cy5mcm9tWCwgJ2RyYWdGcm9tVG9Gb3JEdXJhdGlvbicpLFxuICAgIGZyb21ZOiBwYXJzZUZsb2F0UGFyYW1ldGVyKCdmcm9tWScsIG9wdHMuZnJvbVksICdkcmFnRnJvbVRvRm9yRHVyYXRpb24nKSxcbiAgICB0b1g6IHBhcnNlRmxvYXRQYXJhbWV0ZXIoJ3RvWCcsIG9wdHMudG9YLCAnZHJhZ0Zyb21Ub0ZvckR1cmF0aW9uJyksXG4gICAgdG9ZOiBwYXJzZUZsb2F0UGFyYW1ldGVyKCd0b1knLCBvcHRzLnRvWSwgJ2RyYWdGcm9tVG9Gb3JEdXJhdGlvbicpXG4gIH07XG4gIGlmIChvcHRzLmVsZW1lbnQpIHtcbiAgICAvLyBEcmFnIGVsZW1lbnRcbiAgICBjb25zdCBlbCA9IG9wdHMuZWxlbWVudC5FTEVNRU5UIHx8IG9wdHMuZWxlbWVudDtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5wcm94eUNvbW1hbmQoYC93ZGEvZWxlbWVudC8ke2VsfS9kcmFnZnJvbXRvZm9yZHVyYXRpb25gLCAnUE9TVCcsIHBhcmFtcyk7XG4gIH1cbiAgLy8gRHJhZyBjb29yZGluYXRlc1xuICByZXR1cm4gYXdhaXQgdGhpcy5wcm94eUNvbW1hbmQoJy93ZGEvZHJhZ2Zyb210b2ZvcmR1cmF0aW9uJywgJ1BPU1QnLCBwYXJhbXMpO1xufTtcblxuaGVscGVycy5tb2JpbGVTZWxlY3RQaWNrZXJXaGVlbFZhbHVlID0gYXN5bmMgZnVuY3Rpb24gKG9wdHM9e30pIHtcbiAgaWYgKCFvcHRzLmVsZW1lbnQpIHtcbiAgICBsb2cuZXJyb3JBbmRUaHJvdygnRWxlbWVudCBpZCBpcyBleHBlY3RlZCB0byBiZSBzZXQgZm9yIHNlbGVjdFBpY2tlcldoZWVsVmFsdWUgbWV0aG9kJyk7XG4gIH1cbiAgaWYgKCFfLmlzU3RyaW5nKG9wdHMub3JkZXIpIHx8IFsnbmV4dCcsICdwcmV2aW91cyddLmluZGV4T2Yob3B0cy5vcmRlci50b0xvd2VyQ2FzZSgpKSA9PT0gLTEpIHtcbiAgICBsb2cuZXJyb3JBbmRUaHJvdyhgVGhlIG1hbmRhdG9yeSBcIm9yZGVyXCIgcGFyYW1ldGVyIGlzIGV4cGVjdGVkIHRvIGJlIGVxdWFsIGVpdGhlciB0byAnbmV4dCcgb3IgJ3ByZXZpb3VzJy4gYCArXG4gICAgICAgICAgICAgICAgICAgICAgYCcke29wdHMub3JkZXJ9JyBpcyBnaXZlbiBpbnN0ZWFkYCk7XG4gIH1cbiAgY29uc3QgZWwgPSBvcHRzLmVsZW1lbnQuRUxFTUVOVCB8fCBvcHRzLmVsZW1lbnQ7XG4gIGNvbnN0IHBhcmFtcyA9IHtvcmRlcjogb3B0cy5vcmRlcn07XG4gIGlmIChvcHRzLm9mZnNldCkge1xuICAgIHBhcmFtcy5vZmZzZXQgPSBwYXJzZUZsb2F0UGFyYW1ldGVyKCdvZmZzZXQnLCBvcHRzLm9mZnNldCwgJ3NlbGVjdFBpY2tlcldoZWVsVmFsdWUnKTtcbiAgfVxuICByZXR1cm4gYXdhaXQgdGhpcy5wcm94eUNvbW1hbmQoYC93ZGEvcGlja2Vyd2hlZWwvJHtlbH0vc2VsZWN0YCwgJ1BPU1QnLCBwYXJhbXMpO1xufTtcblxuaGVscGVycy5nZXRDb29yZGluYXRlcyA9IGFzeW5jIGZ1bmN0aW9uIChnZXN0dXJlKSB7XG4gIGxldCBlbCA9IGdlc3R1cmUub3B0aW9ucy5lbGVtZW50O1xuXG4gIC8vIGRlZmF1bHRzXG4gIGxldCBjb29yZGluYXRlcyA9IHt4OiAwLCB5OiAwLCBhcmVPZmZzZXRzOiBmYWxzZX07XG5cbiAgbGV0IG9wdGlvblggPSBudWxsO1xuICBpZiAoZ2VzdHVyZS5vcHRpb25zLngpIHtcbiAgICBvcHRpb25YID0gcGFyc2VGbG9hdFBhcmFtZXRlcigneCcsIGdlc3R1cmUub3B0aW9ucy54LCAnZ2V0Q29vcmRpbmF0ZXMnKTtcbiAgfVxuICBsZXQgb3B0aW9uWSA9IG51bGw7XG4gIGlmIChnZXN0dXJlLm9wdGlvbnMueSkge1xuICAgIG9wdGlvblkgPSBwYXJzZUZsb2F0UGFyYW1ldGVyKCd5JywgZ2VzdHVyZS5vcHRpb25zLnksICdnZXRDb29yZGluYXRlcycpO1xuICB9XG5cbiAgLy8gZmlndXJlIG91dCB0aGUgZWxlbWVudCBjb29yZGluYXRlcy5cbiAgaWYgKGVsKSB7XG4gICAgbGV0IHJlY3QgPSBhd2FpdCB0aGlzLmdldFJlY3QoZWwpO1xuICAgIGxldCBwb3MgPSB7eDogcmVjdC54LCB5OiByZWN0Lnl9O1xuICAgIGxldCBzaXplID0ge3c6IHJlY3Qud2lkdGgsIGg6IHJlY3QuaGVpZ2h0fTtcblxuICAgIC8vIGRlZmF1bHRzXG4gICAgbGV0IG9mZnNldFggPSAwO1xuICAgIGxldCBvZmZzZXRZID0gMDtcblxuICAgIC8vIGdldCB0aGUgcmVhbCBvZmZzZXRzXG4gICAgaWYgKG9wdGlvblggfHwgb3B0aW9uWSkge1xuICAgICAgb2Zmc2V0WCA9IChvcHRpb25YIHx8IDApO1xuICAgICAgb2Zmc2V0WSA9IChvcHRpb25ZIHx8IDApO1xuICAgIH0gZWxzZSB7XG4gICAgICBvZmZzZXRYID0gKHNpemUudyAvIDIpO1xuICAgICAgb2Zmc2V0WSA9IChzaXplLmggLyAyKTtcbiAgICB9XG5cbiAgICAvLyBhcHBseSB0aGUgb2Zmc2V0c1xuICAgIGNvb3JkaW5hdGVzLnggPSBwb3MueCArIG9mZnNldFg7XG4gICAgY29vcmRpbmF0ZXMueSA9IHBvcy55ICsgb2Zmc2V0WTtcbiAgfSBlbHNlIHtcbiAgICAvLyBtb3ZlVG8gY29vcmRpbmF0ZXMgYXJlIHBhc3NlZCBpbiBhcyBvZmZzZXRzXG4gICAgY29vcmRpbmF0ZXMuYXJlT2Zmc2V0cyA9IChnZXN0dXJlLmFjdGlvbiA9PT0gJ21vdmVUbycpO1xuICAgIGNvb3JkaW5hdGVzLnggPSAob3B0aW9uWCB8fCAwKTtcbiAgICBjb29yZGluYXRlcy55ID0gKG9wdGlvblkgfHwgMCk7XG4gIH1cbiAgcmV0dXJuIGNvb3JkaW5hdGVzO1xufTtcblxuaGVscGVycy5hcHBseU1vdmVUb09mZnNldCA9IGZ1bmN0aW9uIChmaXJzdENvb3JkaW5hdGVzLCBzZWNvbmRDb29yZGluYXRlcykge1xuICBpZiAoc2Vjb25kQ29vcmRpbmF0ZXMuYXJlT2Zmc2V0cykge1xuICAgIHJldHVybiB7XG4gICAgICB4OiBmaXJzdENvb3JkaW5hdGVzLnggKyBzZWNvbmRDb29yZGluYXRlcy54LFxuICAgICAgeTogZmlyc3RDb29yZGluYXRlcy55ICsgc2Vjb25kQ29vcmRpbmF0ZXMueSxcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzZWNvbmRDb29yZGluYXRlcztcbiAgfVxufTtcblxuT2JqZWN0LmFzc2lnbihleHRlbnNpb25zLCBoZWxwZXJzLCBjb21tYW5kcyk7XG5leHBvcnQgeyBleHRlbnNpb25zLCBoZWxwZXJzLCBjb21tYW5kcywgaXNTYW1lR2VzdHVyZXMsIGdlc3R1cmVzQ2hhaW5Ub1N0cmluZyB9O1xuZXhwb3J0IGRlZmF1bHQgZXh0ZW5zaW9ucztcbiJdLCJzb3VyY2VSb290IjoiLi4vLi4vLi4ifQ==
